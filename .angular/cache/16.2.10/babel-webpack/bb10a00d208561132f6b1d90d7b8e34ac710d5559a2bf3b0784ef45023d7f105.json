{"ast":null,"code":"/**\n * Highcharts JS v11.2.0 (2023-10-30)\n *\n * (c) 2009-2021 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */!function (t, e) {\n  \"object\" == typeof module && module.exports ? (e.default = e, module.exports = t.document ? e(t) : e) : \"function\" == typeof define && define.amd ? define(\"highcharts/highcharts\", function () {\n    return e(t);\n  }) : (t.Highcharts && t.Highcharts.error(16, !0), t.Highcharts = e(t));\n}(\"undefined\" != typeof window ? window : this, function (t) {\n  \"use strict\";\n\n  var e = {};\n  function i(e, i, s, o) {\n    e.hasOwnProperty(i) || (e[i] = o.apply(null, s), \"function\" == typeof CustomEvent && t.dispatchEvent(new CustomEvent(\"HighchartsModuleLoaded\", {\n      detail: {\n        path: i,\n        module: e[i]\n      }\n    })));\n  }\n  return i(e, \"Core/Globals.js\", [], function () {\n    var e, i;\n    return (i = e || (e = {})).SVG_NS = \"http://www.w3.org/2000/svg\", i.product = \"Highcharts\", i.version = \"11.2.0\", i.win = void 0 !== t ? t : {}, i.doc = i.win.document, i.svg = i.doc && i.doc.createElementNS && !!i.doc.createElementNS(i.SVG_NS, \"svg\").createSVGRect, i.userAgent = i.win.navigator && i.win.navigator.userAgent || \"\", i.isChrome = -1 !== i.userAgent.indexOf(\"Chrome\"), i.isFirefox = -1 !== i.userAgent.indexOf(\"Firefox\"), i.isMS = /(edge|msie|trident)/i.test(i.userAgent) && !i.win.opera, i.isSafari = !i.isChrome && -1 !== i.userAgent.indexOf(\"Safari\"), i.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(i.userAgent), i.isWebKit = -1 !== i.userAgent.indexOf(\"AppleWebKit\"), i.deg2rad = 2 * Math.PI / 360, i.hasBidiBug = i.isFirefox && 4 > parseInt(i.userAgent.split(\"Firefox/\")[1], 10), i.hasTouch = !!i.win.TouchEvent, i.marginNames = [\"plotTop\", \"marginRight\", \"marginBottom\", \"plotLeft\"], i.noop = function () {}, i.supportsPassiveEvents = function () {\n      let t = !1;\n      if (!i.isMS) {\n        let e = Object.defineProperty({}, \"passive\", {\n          get: function () {\n            t = !0;\n          }\n        });\n        i.win.addEventListener && i.win.removeEventListener && (i.win.addEventListener(\"testPassive\", i.noop, e), i.win.removeEventListener(\"testPassive\", i.noop, e));\n      }\n      return t;\n    }(), i.charts = [], i.dateFormats = {}, i.seriesTypes = {}, i.symbolSizes = {}, i.chartCount = 0, e;\n  }), i(e, \"Core/Utilities.js\", [e[\"Core/Globals.js\"]], function (t) {\n    let e;\n    let {\n      charts: i,\n      doc: s,\n      win: o\n    } = t;\n    function r(e, i, s, n) {\n      let a = i ? \"Highcharts error\" : \"Highcharts warning\";\n      32 === e && (e = `${a}: Deprecated member`);\n      let h = p(e),\n        l = h ? `${a} #${e}: www.highcharts.com/errors/${e}/` : e.toString();\n      if (void 0 !== n) {\n        let t = \"\";\n        h && (l += \"?\"), S(n, function (e, i) {\n          t += `\n - ${i}: ${e}`, h && (l += encodeURI(i) + \"=\" + encodeURI(e));\n        }), l += t;\n      }\n      C(t, \"displayError\", {\n        chart: s,\n        code: e,\n        message: l,\n        params: n\n      }, function () {\n        if (i) throw Error(l);\n        o.console && -1 === r.messages.indexOf(l) && console.warn(l);\n      }), r.messages.push(l);\n    }\n    function n(t, e) {\n      return parseInt(t, e || 10);\n    }\n    function a(t) {\n      return \"string\" == typeof t;\n    }\n    function h(t) {\n      let e = Object.prototype.toString.call(t);\n      return \"[object Array]\" === e || \"[object Array Iterator]\" === e;\n    }\n    function l(t, e) {\n      return !!t && \"object\" == typeof t && (!e || !h(t));\n    }\n    function d(t) {\n      return l(t) && \"number\" == typeof t.nodeType;\n    }\n    function c(t) {\n      let e = t && t.constructor;\n      return !!(l(t, !0) && !d(t) && e && e.name && \"Object\" !== e.name);\n    }\n    function p(t) {\n      return \"number\" == typeof t && !isNaN(t) && t < 1 / 0 && t > -1 / 0;\n    }\n    function u(t) {\n      return null != t;\n    }\n    function g(t, e, i) {\n      let s;\n      let o = a(e) && !u(i),\n        r = (e, i) => {\n          u(e) ? t.setAttribute(i, e) : o ? (s = t.getAttribute(i)) || \"class\" !== i || (s = t.getAttribute(i + \"Name\")) : t.removeAttribute(i);\n        };\n      return a(e) ? r(i, e) : S(e, r), s;\n    }\n    function f(t) {\n      return h(t) ? t : [t];\n    }\n    function m(t, e) {\n      let i;\n      for (i in t || (t = {}), e) t[i] = e[i];\n      return t;\n    }\n    function x() {\n      let t = arguments,\n        e = t.length;\n      for (let i = 0; i < e; i++) {\n        let e = t[i];\n        if (null != e) return e;\n      }\n    }\n    function y(e, i) {\n      t.isMS && !t.svg && i && u(i.opacity) && (i.filter = `alpha(opacity=${100 * i.opacity})`), m(e.style, i);\n    }\n    function b(t) {\n      return Math.pow(10, Math.floor(Math.log(t) / Math.LN10));\n    }\n    function v(t, e) {\n      return t > 1e14 ? t : parseFloat(t.toPrecision(e || 14));\n    }\n    (r || (r = {})).messages = [], Math.easeInOutSine = function (t) {\n      return -.5 * (Math.cos(Math.PI * t) - 1);\n    };\n    let k = Array.prototype.find ? function (t, e) {\n      return t.find(e);\n    } : function (t, e) {\n      let i;\n      let s = t.length;\n      for (i = 0; i < s; i++) if (e(t[i], i)) return t[i];\n    };\n    function S(t, e, i) {\n      for (let s in t) Object.hasOwnProperty.call(t, s) && e.call(i || t[s], t[s], s, t);\n    }\n    function M(t, e, i) {\n      function s(e, i) {\n        let s = t.removeEventListener;\n        s && s.call(t, e, i, !1);\n      }\n      function o(i) {\n        let o, r;\n        t.nodeName && (e ? (o = {})[e] = !0 : o = i, S(o, function (t, e) {\n          if (i[e]) for (r = i[e].length; r--;) s(e, i[e][r].fn);\n        }));\n      }\n      let r = \"function\" == typeof t && t.prototype || t;\n      if (Object.hasOwnProperty.call(r, \"hcEvents\")) {\n        let t = r.hcEvents;\n        if (e) {\n          let r = t[e] || [];\n          i ? (t[e] = r.filter(function (t) {\n            return i !== t.fn;\n          }), s(e, i)) : (o(t), t[e] = []);\n        } else o(t), delete r.hcEvents;\n      }\n    }\n    function C(e, i, o, r) {\n      let n;\n      if (o = o || {}, s.createEvent && (e.dispatchEvent || e.fireEvent && e !== t)) (n = s.createEvent(\"Events\")).initEvent(i, !0, !0), o = m(n, o), e.dispatchEvent ? e.dispatchEvent(o) : e.fireEvent(i, o);else if (e.hcEvents) {\n        o.target || m(o, {\n          preventDefault: function () {\n            o.defaultPrevented = !0;\n          },\n          target: e,\n          type: i\n        });\n        let t = [],\n          s = e,\n          r = !1;\n        for (; s.hcEvents;) Object.hasOwnProperty.call(s, \"hcEvents\") && s.hcEvents[i] && (t.length && (r = !0), t.unshift.apply(t, s.hcEvents[i])), s = Object.getPrototypeOf(s);\n        r && t.sort((t, e) => t.order - e.order), t.forEach(t => {\n          !1 === t.fn.call(e, o) && o.preventDefault();\n        });\n      }\n      r && !o.defaultPrevented && r.call(e, o);\n    }\n    S({\n      map: \"map\",\n      each: \"forEach\",\n      grep: \"filter\",\n      reduce: \"reduce\",\n      some: \"some\"\n    }, function (e, i) {\n      t[i] = function (t) {\n        return r(32, !1, void 0, {\n          [`Highcharts.${i}`]: `use Array.${e}`\n        }), Array.prototype[e].apply(t, [].slice.call(arguments, 1));\n      };\n    });\n    let w = function () {\n      let t = Math.random().toString(36).substring(2, 9) + \"-\",\n        i = 0;\n      return function () {\n        return \"highcharts-\" + (e ? \"\" : t) + i++;\n      };\n    }();\n    o.jQuery && (o.jQuery.fn.highcharts = function () {\n      let e = [].slice.call(arguments);\n      if (this[0]) return e[0] ? (new t[a(e[0]) ? e.shift() : \"Chart\"](this[0], e[0], e[1]), this) : i[g(this[0], \"data-highcharts-chart\")];\n    });\n    let T = {\n      addEvent: function (e, i, s, o = {}) {\n        let r = \"function\" == typeof e && e.prototype || e;\n        Object.hasOwnProperty.call(r, \"hcEvents\") || (r.hcEvents = {});\n        let n = r.hcEvents;\n        t.Point && e instanceof t.Point && e.series && e.series.chart && (e.series.chart.runTrackerClick = !0);\n        let a = e.addEventListener;\n        a && a.call(e, i, s, !!t.supportsPassiveEvents && {\n          passive: void 0 === o.passive ? -1 !== i.indexOf(\"touch\") : o.passive,\n          capture: !1\n        }), n[i] || (n[i] = []);\n        let h = {\n          fn: s,\n          order: \"number\" == typeof o.order ? o.order : 1 / 0\n        };\n        return n[i].push(h), n[i].sort((t, e) => t.order - e.order), function () {\n          M(e, i, s);\n        };\n      },\n      arrayMax: function (t) {\n        let e = t.length,\n          i = t[0];\n        for (; e--;) t[e] > i && (i = t[e]);\n        return i;\n      },\n      arrayMin: function (t) {\n        let e = t.length,\n          i = t[0];\n        for (; e--;) t[e] < i && (i = t[e]);\n        return i;\n      },\n      attr: g,\n      clamp: function (t, e, i) {\n        return t > e ? t < i ? t : i : e;\n      },\n      clearTimeout: function (t) {\n        u(t) && clearTimeout(t);\n      },\n      correctFloat: v,\n      createElement: function (t, e, i, o, r) {\n        let n = s.createElement(t);\n        return e && m(n, e), r && y(n, {\n          padding: \"0\",\n          border: \"none\",\n          margin: \"0\"\n        }), i && y(n, i), o && o.appendChild(n), n;\n      },\n      css: y,\n      defined: u,\n      destroyObjectProperties: function (t, e) {\n        S(t, function (i, s) {\n          i && i !== e && i.destroy && i.destroy(), delete t[s];\n        });\n      },\n      diffObjects: function (t, e, i, s) {\n        let o = {};\n        return function t(e, o, r, n) {\n          let a = i ? o : e;\n          S(e, function (i, d) {\n            if (!n && s && s.indexOf(d) > -1 && o[d]) {\n              i = f(i), r[d] = [];\n              for (let e = 0; e < Math.max(i.length, o[d].length); e++) o[d][e] && (void 0 === i[e] ? r[d][e] = o[d][e] : (r[d][e] = {}, t(i[e], o[d][e], r[d][e], n + 1)));\n            } else l(i, !0) && !i.nodeType ? (r[d] = h(i) ? [] : {}, t(i, o[d] || {}, r[d], n + 1), 0 !== Object.keys(r[d]).length || \"colorAxis\" === d && 0 === n || delete r[d]) : (e[d] !== o[d] || d in e && !(d in o)) && (r[d] = a[d]);\n          });\n        }(t, e, o, 0), o;\n      },\n      discardElement: function (t) {\n        t && t.parentElement && t.parentElement.removeChild(t);\n      },\n      erase: function (t, e) {\n        let i = t.length;\n        for (; i--;) if (t[i] === e) {\n          t.splice(i, 1);\n          break;\n        }\n      },\n      error: r,\n      extend: m,\n      extendClass: function (t, e) {\n        let i = function () {};\n        return i.prototype = new t(), m(i.prototype, e), i;\n      },\n      find: k,\n      fireEvent: C,\n      getClosestDistance: function (t, e) {\n        let i, s, o;\n        let r = !e;\n        return t.forEach(t => {\n          if (t.length > 1) for (o = t.length - 1; o > 0; o--) (s = t[o] - t[o - 1]) < 0 && !r ? (e?.(), e = void 0) : s && (void 0 === i || s < i) && (i = s);\n        }), i;\n      },\n      getMagnitude: b,\n      getNestedProperty: function (t, e) {\n        let i = t.split(\".\");\n        for (; i.length && u(e);) {\n          let t = i.shift();\n          if (void 0 === t || \"__proto__\" === t) return;\n          if (\"this\" === t) {\n            let t;\n            return l(e) && (t = e[\"@this\"]), t ?? e;\n          }\n          let s = e[t];\n          if (!u(s) || \"function\" == typeof s || \"number\" == typeof s.nodeType || s === o) return;\n          e = s;\n        }\n        return e;\n      },\n      getStyle: function t(e, i, s) {\n        let r;\n        if (\"width\" === i) {\n          let i = Math.min(e.offsetWidth, e.scrollWidth),\n            s = e.getBoundingClientRect && e.getBoundingClientRect().width;\n          return s < i && s >= i - 1 && (i = Math.floor(s)), Math.max(0, i - (t(e, \"padding-left\", !0) || 0) - (t(e, \"padding-right\", !0) || 0));\n        }\n        if (\"height\" === i) return Math.max(0, Math.min(e.offsetHeight, e.scrollHeight) - (t(e, \"padding-top\", !0) || 0) - (t(e, \"padding-bottom\", !0) || 0));\n        let a = o.getComputedStyle(e, void 0);\n        return a && (r = a.getPropertyValue(i), x(s, \"opacity\" !== i) && (r = n(r))), r;\n      },\n      inArray: function (t, e, i) {\n        return r(32, !1, void 0, {\n          \"Highcharts.inArray\": \"use Array.indexOf\"\n        }), e.indexOf(t, i);\n      },\n      insertItem: function (t, e) {\n        let i;\n        let s = t.options.index,\n          o = e.length;\n        for (i = t.options.isInternal ? o : 0; i < o + 1; i++) if (!e[i] || p(s) && s < x(e[i].options.index, e[i]._i) || e[i].options.isInternal) {\n          e.splice(i, 0, t);\n          break;\n        }\n        return i;\n      },\n      isArray: h,\n      isClass: c,\n      isDOMElement: d,\n      isFunction: function (t) {\n        return \"function\" == typeof t;\n      },\n      isNumber: p,\n      isObject: l,\n      isString: a,\n      keys: function (t) {\n        return r(32, !1, void 0, {\n          \"Highcharts.keys\": \"use Object.keys\"\n        }), Object.keys(t);\n      },\n      merge: function () {\n        let t,\n          e = arguments,\n          i = {},\n          s = function (t, e) {\n            return \"object\" != typeof t && (t = {}), S(e, function (i, o) {\n              \"__proto__\" !== o && \"constructor\" !== o && (!l(i, !0) || c(i) || d(i) ? t[o] = e[o] : t[o] = s(t[o] || {}, i));\n            }), t;\n          };\n        !0 === e[0] && (i = e[1], e = Array.prototype.slice.call(e, 2));\n        let o = e.length;\n        for (t = 0; t < o; t++) i = s(i, e[t]);\n        return i;\n      },\n      normalizeTickInterval: function (t, e, i, s, o) {\n        let r,\n          n = t;\n        i = x(i, b(t));\n        let a = t / i;\n        for (!e && (e = o ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], !1 === s && (1 === i ? e = e.filter(function (t) {\n          return t % 1 == 0;\n        }) : i <= .1 && (e = [1 / i]))), r = 0; r < e.length && (n = e[r], (!o || !(n * i >= t)) && (o || !(a <= (e[r] + (e[r + 1] || e[r])) / 2))); r++);\n        return v(n * i, -Math.round(Math.log(.001) / Math.LN10));\n      },\n      objectEach: S,\n      offset: function (t) {\n        let e = s.documentElement,\n          i = t.parentElement || t.parentNode ? t.getBoundingClientRect() : {\n            top: 0,\n            left: 0,\n            width: 0,\n            height: 0\n          };\n        return {\n          top: i.top + (o.pageYOffset || e.scrollTop) - (e.clientTop || 0),\n          left: i.left + (o.pageXOffset || e.scrollLeft) - (e.clientLeft || 0),\n          width: i.width,\n          height: i.height\n        };\n      },\n      pad: function (t, e, i) {\n        return Array((e || 2) + 1 - String(t).replace(\"-\", \"\").length).join(i || \"0\") + t;\n      },\n      pick: x,\n      pInt: n,\n      pushUnique: function (t, e) {\n        return 0 > t.indexOf(e) && !!t.push(e);\n      },\n      relativeLength: function (t, e, i) {\n        return /%$/.test(t) ? e * parseFloat(t) / 100 + (i || 0) : parseFloat(t);\n      },\n      removeEvent: M,\n      splat: f,\n      stableSort: function (t, e) {\n        let i, s;\n        let o = t.length;\n        for (s = 0; s < o; s++) t[s].safeI = s;\n        for (t.sort(function (t, s) {\n          return 0 === (i = e(t, s)) ? t.safeI - s.safeI : i;\n        }), s = 0; s < o; s++) delete t[s].safeI;\n      },\n      syncTimeout: function (t, e, i) {\n        return e > 0 ? setTimeout(t, e, i) : (t.call(0, i), -1);\n      },\n      timeUnits: {\n        millisecond: 1,\n        second: 1e3,\n        minute: 6e4,\n        hour: 36e5,\n        day: 864e5,\n        week: 6048e5,\n        month: 24192e5,\n        year: 314496e5\n      },\n      uniqueKey: w,\n      useSerialIds: function (t) {\n        return e = x(t, e);\n      },\n      wrap: function (t, e, i) {\n        let s = t[e];\n        t[e] = function () {\n          let t = arguments,\n            e = this;\n          return i.apply(this, [function () {\n            return s.apply(e, arguments.length ? arguments : t);\n          }].concat([].slice.call(arguments)));\n        };\n      }\n    };\n    return T;\n  }), i(e, \"Core/Chart/ChartDefaults.js\", [], function () {\n    return {\n      alignThresholds: !1,\n      panning: {\n        enabled: !1,\n        type: \"x\"\n      },\n      styledMode: !1,\n      borderRadius: 0,\n      colorCount: 10,\n      allowMutatingData: !0,\n      ignoreHiddenSeries: !0,\n      spacing: [10, 10, 15, 10],\n      resetZoomButton: {\n        theme: {},\n        position: {}\n      },\n      reflow: !0,\n      type: \"line\",\n      zooming: {\n        singleTouch: !1,\n        resetButton: {\n          theme: {\n            zIndex: 6\n          },\n          position: {\n            align: \"right\",\n            x: -10,\n            y: 10\n          }\n        }\n      },\n      width: null,\n      height: null,\n      borderColor: \"#334eff\",\n      backgroundColor: \"#ffffff\",\n      plotBorderColor: \"#cccccc\"\n    };\n  }), i(e, \"Core/Color/Palettes.js\", [], function () {\n    return {\n      colors: [\"#2caffe\", \"#544fc5\", \"#00e272\", \"#fe6a35\", \"#6b8abc\", \"#d568fb\", \"#2ee0ca\", \"#fa4b42\", \"#feb56a\", \"#91e8e1\"]\n    };\n  }), i(e, \"Core/Time.js\", [e[\"Core/Globals.js\"], e[\"Core/Utilities.js\"]], function (t, e) {\n    let {\n        win: i\n      } = t,\n      {\n        defined: s,\n        error: o,\n        extend: r,\n        isObject: n,\n        merge: a,\n        objectEach: h,\n        pad: l,\n        pick: d,\n        splat: c,\n        timeUnits: p\n      } = e,\n      u = t.isSafari && i.Intl && i.Intl.DateTimeFormat.prototype.formatRange,\n      g = t.isSafari && i.Intl && !i.Intl.DateTimeFormat.prototype.formatRange;\n    return class {\n      constructor(t) {\n        this.options = {}, this.useUTC = !1, this.variableTimezone = !1, this.Date = i.Date, this.getTimezoneOffset = this.timezoneOffsetFunction(), this.update(t);\n      }\n      get(t, e) {\n        if (this.variableTimezone || this.timezoneOffset) {\n          let i = e.getTime(),\n            s = i - this.getTimezoneOffset(e);\n          e.setTime(s);\n          let o = e[\"getUTC\" + t]();\n          return e.setTime(i), o;\n        }\n        return this.useUTC ? e[\"getUTC\" + t]() : e[\"get\" + t]();\n      }\n      set(t, e, i) {\n        if (this.variableTimezone || this.timezoneOffset) {\n          if (\"Milliseconds\" === t || \"Seconds\" === t || \"Minutes\" === t && this.getTimezoneOffset(e) % 36e5 == 0) return e[\"setUTC\" + t](i);\n          let s = this.getTimezoneOffset(e),\n            o = e.getTime() - s;\n          e.setTime(o), e[\"setUTC\" + t](i);\n          let r = this.getTimezoneOffset(e);\n          return o = e.getTime() + r, e.setTime(o);\n        }\n        return this.useUTC || u && \"FullYear\" === t ? e[\"setUTC\" + t](i) : e[\"set\" + t](i);\n      }\n      update(t = {}) {\n        let e = d(t.useUTC, !0);\n        this.options = t = a(!0, this.options, t), this.Date = t.Date || i.Date || Date, this.useUTC = e, this.timezoneOffset = e && t.timezoneOffset || void 0, this.getTimezoneOffset = this.timezoneOffsetFunction(), this.variableTimezone = e && !!(t.getTimezoneOffset || t.timezone);\n      }\n      makeTime(t, e, i, s, o, r) {\n        let n, a, h;\n        return this.useUTC ? (n = this.Date.UTC.apply(0, arguments), a = this.getTimezoneOffset(n), n += a, a !== (h = this.getTimezoneOffset(n)) ? n += h - a : a - 36e5 !== this.getTimezoneOffset(n - 36e5) || g || (n -= 36e5)) : n = new this.Date(t, e, d(i, 1), d(s, 0), d(o, 0), d(r, 0)).getTime(), n;\n      }\n      timezoneOffsetFunction() {\n        let t = this,\n          e = this.options,\n          s = e.getTimezoneOffset,\n          r = e.moment || i.moment;\n        if (!this.useUTC) return function (t) {\n          return 6e4 * new Date(t.toString()).getTimezoneOffset();\n        };\n        if (e.timezone) {\n          if (r) return function (t) {\n            return -(6e4 * r.tz(t, e.timezone).utcOffset());\n          };\n          o(25);\n        }\n        return this.useUTC && s ? function (t) {\n          return 6e4 * s(t.valueOf());\n        } : function () {\n          return 6e4 * (t.timezoneOffset || 0);\n        };\n      }\n      dateFormat(e, i, o) {\n        if (!s(i) || isNaN(i)) return t.defaultOptions.lang && t.defaultOptions.lang.invalidDate || \"\";\n        e = d(e, \"%Y-%m-%d %H:%M:%S\");\n        let n = this,\n          a = new this.Date(i),\n          c = this.get(\"Hours\", a),\n          p = this.get(\"Day\", a),\n          u = this.get(\"Date\", a),\n          g = this.get(\"Month\", a),\n          f = this.get(\"FullYear\", a),\n          m = t.defaultOptions.lang,\n          x = m && m.weekdays,\n          y = m && m.shortWeekdays,\n          b = r({\n            a: y ? y[p] : x[p].substr(0, 3),\n            A: x[p],\n            d: l(u),\n            e: l(u, 2, \" \"),\n            w: p,\n            b: m.shortMonths[g],\n            B: m.months[g],\n            m: l(g + 1),\n            o: g + 1,\n            y: f.toString().substr(2, 2),\n            Y: f,\n            H: l(c),\n            k: c,\n            I: l(c % 12 || 12),\n            l: c % 12 || 12,\n            M: l(this.get(\"Minutes\", a)),\n            p: c < 12 ? \"AM\" : \"PM\",\n            P: c < 12 ? \"am\" : \"pm\",\n            S: l(this.get(\"Seconds\", a)),\n            L: l(Math.floor(i % 1e3), 3)\n          }, t.dateFormats);\n        return h(b, function (t, s) {\n          for (; -1 !== e.indexOf(\"%\" + s);) e = e.replace(\"%\" + s, \"function\" == typeof t ? t.call(n, i) : t);\n        }), o ? e.substr(0, 1).toUpperCase() + e.substr(1) : e;\n      }\n      resolveDTLFormat(t) {\n        return n(t, !0) ? t : {\n          main: (t = c(t))[0],\n          from: t[1],\n          to: t[2]\n        };\n      }\n      getTimeTicks(t, e, i, o) {\n        let n, a, h, l;\n        let c = this,\n          u = c.Date,\n          g = [],\n          f = {},\n          m = new u(e),\n          x = t.unitRange,\n          y = t.count || 1;\n        if (o = d(o, 1), s(e)) {\n          c.set(\"Milliseconds\", m, x >= p.second ? 0 : y * Math.floor(c.get(\"Milliseconds\", m) / y)), x >= p.second && c.set(\"Seconds\", m, x >= p.minute ? 0 : y * Math.floor(c.get(\"Seconds\", m) / y)), x >= p.minute && c.set(\"Minutes\", m, x >= p.hour ? 0 : y * Math.floor(c.get(\"Minutes\", m) / y)), x >= p.hour && c.set(\"Hours\", m, x >= p.day ? 0 : y * Math.floor(c.get(\"Hours\", m) / y)), x >= p.day && c.set(\"Date\", m, x >= p.month ? 1 : Math.max(1, y * Math.floor(c.get(\"Date\", m) / y))), x >= p.month && (c.set(\"Month\", m, x >= p.year ? 0 : y * Math.floor(c.get(\"Month\", m) / y)), a = c.get(\"FullYear\", m)), x >= p.year && (a -= a % y, c.set(\"FullYear\", m, a)), x === p.week && (l = c.get(\"Day\", m), c.set(\"Date\", m, c.get(\"Date\", m) - l + o + (l < o ? -7 : 0))), a = c.get(\"FullYear\", m);\n          let t = c.get(\"Month\", m),\n            r = c.get(\"Date\", m),\n            d = c.get(\"Hours\", m);\n          e = m.getTime(), (c.variableTimezone || !c.useUTC) && s(i) && (h = i - e > 4 * p.month || c.getTimezoneOffset(e) !== c.getTimezoneOffset(i));\n          let u = m.getTime();\n          for (n = 1; u < i;) g.push(u), x === p.year ? u = c.makeTime(a + n * y, 0) : x === p.month ? u = c.makeTime(a, t + n * y) : h && (x === p.day || x === p.week) ? u = c.makeTime(a, t, r + n * y * (x === p.day ? 1 : 7)) : h && x === p.hour && y > 1 ? u = c.makeTime(a, t, r, d + n * y) : u += x * y, n++;\n          g.push(u), x <= p.hour && g.length < 1e4 && g.forEach(function (t) {\n            t % 18e5 == 0 && \"000000000\" === c.dateFormat(\"%H%M%S%L\", t) && (f[t] = \"day\");\n          });\n        }\n        return g.info = r(t, {\n          higherRanks: f,\n          totalRange: x * y\n        }), g;\n      }\n      getDateFormat(t, e, i, s) {\n        let o = this.dateFormat(\"%m-%d %H:%M:%S.%L\", e),\n          r = \"01-01 00:00:00.000\",\n          n = {\n            millisecond: 15,\n            second: 12,\n            minute: 9,\n            hour: 6,\n            day: 3\n          },\n          a = \"millisecond\",\n          h = a;\n        for (a in p) {\n          if (t === p.week && +this.dateFormat(\"%w\", e) === i && o.substr(6) === r.substr(6)) {\n            a = \"week\";\n            break;\n          }\n          if (p[a] > t) {\n            a = h;\n            break;\n          }\n          if (n[a] && o.substr(n[a]) !== r.substr(n[a])) break;\n          \"week\" !== a && (h = a);\n        }\n        return this.resolveDTLFormat(s[a]).main;\n      }\n    };\n  }), i(e, \"Core/Defaults.js\", [e[\"Core/Chart/ChartDefaults.js\"], e[\"Core/Globals.js\"], e[\"Core/Color/Palettes.js\"], e[\"Core/Time.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s, o) {\n    let {\n        isTouchDevice: r,\n        svg: n\n      } = e,\n      {\n        merge: a\n      } = o,\n      h = {\n        colors: i.colors,\n        symbols: [\"circle\", \"diamond\", \"square\", \"triangle\", \"triangle-down\"],\n        lang: {\n          loading: \"Loading...\",\n          months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n          shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"],\n          weekdays: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n          decimalPoint: \".\",\n          numericSymbols: [\"k\", \"M\", \"G\", \"T\", \"P\", \"E\"],\n          resetZoom: \"Reset zoom\",\n          resetZoomTitle: \"Reset zoom level 1:1\",\n          thousandsSep: \" \"\n        },\n        global: {},\n        time: {\n          Date: void 0,\n          getTimezoneOffset: void 0,\n          timezone: void 0,\n          timezoneOffset: 0,\n          useUTC: !0\n        },\n        chart: t,\n        title: {\n          style: {\n            color: \"#333333\",\n            fontWeight: \"bold\"\n          },\n          text: \"Chart title\",\n          align: \"center\",\n          margin: 15,\n          widthAdjust: -44\n        },\n        subtitle: {\n          style: {\n            color: \"#666666\",\n            fontSize: \"0.8em\"\n          },\n          text: \"\",\n          align: \"center\",\n          widthAdjust: -44\n        },\n        caption: {\n          margin: 15,\n          style: {\n            color: \"#666666\",\n            fontSize: \"0.8em\"\n          },\n          text: \"\",\n          align: \"left\",\n          verticalAlign: \"bottom\"\n        },\n        plotOptions: {},\n        legend: {\n          enabled: !0,\n          align: \"center\",\n          alignColumns: !0,\n          className: \"highcharts-no-tooltip\",\n          layout: \"horizontal\",\n          itemMarginBottom: 2,\n          itemMarginTop: 2,\n          labelFormatter: function () {\n            return this.name;\n          },\n          borderColor: \"#999999\",\n          borderRadius: 0,\n          navigation: {\n            style: {\n              fontSize: \"0.8em\"\n            },\n            activeColor: \"#0022ff\",\n            inactiveColor: \"#cccccc\"\n          },\n          itemStyle: {\n            color: \"#333333\",\n            cursor: \"pointer\",\n            fontSize: \"0.8em\",\n            textDecoration: \"none\",\n            textOverflow: \"ellipsis\"\n          },\n          itemHoverStyle: {\n            color: \"#000000\"\n          },\n          itemHiddenStyle: {\n            color: \"#666666\",\n            textDecoration: \"line-through\"\n          },\n          shadow: !1,\n          itemCheckboxStyle: {\n            position: \"absolute\",\n            width: \"13px\",\n            height: \"13px\"\n          },\n          squareSymbol: !0,\n          symbolPadding: 5,\n          verticalAlign: \"bottom\",\n          x: 0,\n          y: 0,\n          title: {\n            style: {\n              fontSize: \"0.8em\",\n              fontWeight: \"bold\"\n            }\n          }\n        },\n        loading: {\n          labelStyle: {\n            fontWeight: \"bold\",\n            position: \"relative\",\n            top: \"45%\"\n          },\n          style: {\n            position: \"absolute\",\n            backgroundColor: \"#ffffff\",\n            opacity: .5,\n            textAlign: \"center\"\n          }\n        },\n        tooltip: {\n          enabled: !0,\n          animation: n,\n          borderRadius: 3,\n          dateTimeLabelFormats: {\n            millisecond: \"%A, %e %b, %H:%M:%S.%L\",\n            second: \"%A, %e %b, %H:%M:%S\",\n            minute: \"%A, %e %b, %H:%M\",\n            hour: \"%A, %e %b, %H:%M\",\n            day: \"%A, %e %b %Y\",\n            week: \"Week from %A, %e %b %Y\",\n            month: \"%B %Y\",\n            year: \"%Y\"\n          },\n          footerFormat: \"\",\n          headerShape: \"callout\",\n          hideDelay: 500,\n          padding: 8,\n          shape: \"callout\",\n          shared: !1,\n          snap: r ? 25 : 10,\n          headerFormat: '<span style=\"font-size: 0.8em\">{point.key}</span><br/>',\n          pointFormat: '<span style=\"color:{point.color}\">‚óè</span> {series.name}: <b>{point.y}</b><br/>',\n          backgroundColor: \"#ffffff\",\n          borderWidth: void 0,\n          shadow: !0,\n          stickOnContact: !1,\n          style: {\n            color: \"#333333\",\n            cursor: \"default\",\n            fontSize: \"0.8em\"\n          },\n          useHTML: !1\n        },\n        credits: {\n          enabled: !0,\n          href: \"https://www.highcharts.com?credits\",\n          position: {\n            align: \"right\",\n            x: -10,\n            verticalAlign: \"bottom\",\n            y: -5\n          },\n          style: {\n            cursor: \"pointer\",\n            color: \"#999999\",\n            fontSize: \"0.6em\"\n          },\n          text: \"Highcharts.com\"\n        }\n      };\n    h.chart.styledMode = !1;\n    let l = new s(h.time);\n    return {\n      defaultOptions: h,\n      defaultTime: l,\n      getOptions: function () {\n        return h;\n      },\n      setOptions: function (t) {\n        return a(!0, h, t), (t.time || t.global) && (e.time ? e.time.update(a(h.global, h.time, t.global, t.time)) : e.time = l), h;\n      }\n    };\n  }), i(e, \"Core/Color/Color.js\", [e[\"Core/Globals.js\"], e[\"Core/Utilities.js\"]], function (t, e) {\n    let {\n      isNumber: i,\n      merge: s,\n      pInt: o\n    } = e;\n    class r {\n      static parse(t) {\n        return t ? new r(t) : r.None;\n      }\n      constructor(e) {\n        this.rgba = [NaN, NaN, NaN, NaN], this.input = e;\n        let i = t.Color;\n        if (i && i !== r) return new i(e);\n        this.init(e);\n      }\n      init(t) {\n        let e, i, s, o;\n        if (\"object\" == typeof t && void 0 !== t.stops) this.stops = t.stops.map(t => new r(t[1]));else if (\"string\" == typeof t) {\n          if (this.input = t = r.names[t.toLowerCase()] || t, \"#\" === t.charAt(0)) {\n            let e = t.length,\n              s = parseInt(t.substr(1), 16);\n            7 === e ? i = [(16711680 & s) >> 16, (65280 & s) >> 8, 255 & s, 1] : 4 === e && (i = [(3840 & s) >> 4 | (3840 & s) >> 8, (240 & s) >> 4 | 240 & s, (15 & s) << 4 | 15 & s, 1]);\n          }\n          if (!i) for (s = r.parsers.length; s-- && !i;) (e = (o = r.parsers[s]).regex.exec(t)) && (i = o.parse(e));\n        }\n        i && (this.rgba = i);\n      }\n      get(t) {\n        let e = this.input,\n          o = this.rgba;\n        if (\"object\" == typeof e && void 0 !== this.stops) {\n          let i = s(e);\n          return i.stops = [].slice.call(i.stops), this.stops.forEach((e, s) => {\n            i.stops[s] = [i.stops[s][0], e.get(t)];\n          }), i;\n        }\n        return o && i(o[0]) ? \"rgb\" !== t && (t || 1 !== o[3]) ? \"a\" === t ? `${o[3]}` : \"rgba(\" + o.join(\",\") + \")\" : \"rgb(\" + o[0] + \",\" + o[1] + \",\" + o[2] + \")\" : e;\n      }\n      brighten(t) {\n        let e = this.rgba;\n        if (this.stops) this.stops.forEach(function (e) {\n          e.brighten(t);\n        });else if (i(t) && 0 !== t) for (let i = 0; i < 3; i++) e[i] += o(255 * t), e[i] < 0 && (e[i] = 0), e[i] > 255 && (e[i] = 255);\n        return this;\n      }\n      setOpacity(t) {\n        return this.rgba[3] = t, this;\n      }\n      tweenTo(t, e) {\n        let s = this.rgba,\n          o = t.rgba;\n        if (!i(s[0]) || !i(o[0])) return t.input || \"none\";\n        let r = 1 !== o[3] || 1 !== s[3];\n        return (r ? \"rgba(\" : \"rgb(\") + Math.round(o[0] + (s[0] - o[0]) * (1 - e)) + \",\" + Math.round(o[1] + (s[1] - o[1]) * (1 - e)) + \",\" + Math.round(o[2] + (s[2] - o[2]) * (1 - e)) + (r ? \",\" + (o[3] + (s[3] - o[3]) * (1 - e)) : \"\") + \")\";\n      }\n    }\n    return r.names = {\n      white: \"#ffffff\",\n      black: \"#000000\"\n    }, r.parsers = [{\n      regex: /rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]?(?:\\.[0-9]+)?)\\s*\\)/,\n      parse: function (t) {\n        return [o(t[1]), o(t[2]), o(t[3]), parseFloat(t[4], 10)];\n      }\n    }, {\n      regex: /rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/,\n      parse: function (t) {\n        return [o(t[1]), o(t[2]), o(t[3]), 1];\n      }\n    }], r.None = new r(\"\"), r;\n  }), i(e, \"Core/Animation/Fx.js\", [e[\"Core/Color/Color.js\"], e[\"Core/Globals.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    let {\n        parse: s\n      } = t,\n      {\n        win: o\n      } = e,\n      {\n        isNumber: r,\n        objectEach: n\n      } = i;\n    class a {\n      constructor(t, e, i) {\n        this.pos = NaN, this.options = e, this.elem = t, this.prop = i;\n      }\n      dSetter() {\n        let t = this.paths,\n          e = t && t[0],\n          i = t && t[1],\n          s = this.now || 0,\n          o = [];\n        if (1 !== s && e && i) {\n          if (e.length === i.length && s < 1) for (let t = 0; t < i.length; t++) {\n            let n = e[t],\n              a = i[t],\n              h = [];\n            for (let t = 0; t < a.length; t++) {\n              let e = n[t],\n                i = a[t];\n              r(e) && r(i) && !(\"A\" === a[0] && (4 === t || 5 === t)) ? h[t] = e + s * (i - e) : h[t] = i;\n            }\n            o.push(h);\n          } else o = i;\n        } else o = this.toD || [];\n        this.elem.attr(\"d\", o, void 0, !0);\n      }\n      update() {\n        let t = this.elem,\n          e = this.prop,\n          i = this.now,\n          s = this.options.step;\n        this[e + \"Setter\"] ? this[e + \"Setter\"]() : t.attr ? t.element && t.attr(e, i, null, !0) : t.style[e] = i + this.unit, s && s.call(t, i, this);\n      }\n      run(t, e, i) {\n        let s = this,\n          r = s.options,\n          n = function (t) {\n            return !n.stopped && s.step(t);\n          },\n          h = o.requestAnimationFrame || function (t) {\n            setTimeout(t, 13);\n          },\n          l = function () {\n            for (let t = 0; t < a.timers.length; t++) a.timers[t]() || a.timers.splice(t--, 1);\n            a.timers.length && h(l);\n          };\n        t !== e || this.elem[\"forceAnimate:\" + this.prop] ? (this.startTime = +new Date(), this.start = t, this.end = e, this.unit = i, this.now = this.start, this.pos = 0, n.elem = this.elem, n.prop = this.prop, n() && 1 === a.timers.push(n) && h(l)) : (delete r.curAnim[this.prop], r.complete && 0 === Object.keys(r.curAnim).length && r.complete.call(this.elem));\n      }\n      step(t) {\n        let e, i;\n        let s = +new Date(),\n          o = this.options,\n          r = this.elem,\n          a = o.complete,\n          h = o.duration,\n          l = o.curAnim;\n        return r.attr && !r.element ? e = !1 : t || s >= h + this.startTime ? (this.now = this.end, this.pos = 1, this.update(), l[this.prop] = !0, i = !0, n(l, function (t) {\n          !0 !== t && (i = !1);\n        }), i && a && a.call(r), e = !1) : (this.pos = o.easing((s - this.startTime) / h), this.now = this.start + (this.end - this.start) * this.pos, this.update(), e = !0), e;\n      }\n      initPath(t, e, i) {\n        let s = t.startX,\n          o = t.endX,\n          n = i.slice(),\n          a = t.isArea,\n          h = a ? 2 : 1,\n          l,\n          d,\n          c,\n          p,\n          u = e && e.slice();\n        if (!u) return [n, n];\n        function g(t, e) {\n          for (; t.length < d;) {\n            let i = t[0],\n              s = e[d - t.length];\n            if (s && \"M\" === i[0] && (\"C\" === s[0] ? t[0] = [\"C\", i[1], i[2], i[1], i[2], i[1], i[2]] : t[0] = [\"L\", i[1], i[2]]), t.unshift(i), a) {\n              let e = t.pop();\n              t.push(t[t.length - 1], e);\n            }\n          }\n        }\n        function f(t, e) {\n          for (; t.length < d;) {\n            let e = t[Math.floor(t.length / h) - 1].slice();\n            if (\"C\" === e[0] && (e[1] = e[5], e[2] = e[6]), a) {\n              let i = t[Math.floor(t.length / h)].slice();\n              t.splice(t.length / 2, 0, e, i);\n            } else t.push(e);\n          }\n        }\n        if (s && o && o.length) {\n          for (c = 0; c < s.length; c++) {\n            if (s[c] === o[0]) {\n              l = c;\n              break;\n            }\n            if (s[0] === o[o.length - s.length + c]) {\n              l = c, p = !0;\n              break;\n            }\n            if (s[s.length - 1] === o[o.length - s.length + c]) {\n              l = s.length - c;\n              break;\n            }\n          }\n          void 0 === l && (u = []);\n        }\n        return u.length && r(l) && (d = n.length + l * h, p ? (g(u, n), f(n, u)) : (g(n, u), f(u, n))), [u, n];\n      }\n      fillSetter() {\n        a.prototype.strokeSetter.apply(this, arguments);\n      }\n      strokeSetter() {\n        this.elem.attr(this.prop, s(this.start).tweenTo(s(this.end), this.pos), void 0, !0);\n      }\n    }\n    return a.timers = [], a;\n  }), i(e, \"Core/Animation/AnimationUtilities.js\", [e[\"Core/Animation/Fx.js\"], e[\"Core/Utilities.js\"]], function (t, e) {\n    let {\n      defined: i,\n      getStyle: s,\n      isArray: o,\n      isNumber: r,\n      isObject: n,\n      merge: a,\n      objectEach: h,\n      pick: l\n    } = e;\n    function d(t) {\n      return n(t) ? a({\n        duration: 500,\n        defer: 0\n      }, t) : {\n        duration: t ? 500 : 0,\n        defer: 0\n      };\n    }\n    function c(e, i) {\n      let s = t.timers.length;\n      for (; s--;) t.timers[s].elem !== e || i && i !== t.timers[s].prop || (t.timers[s].stopped = !0);\n    }\n    return {\n      animate: function (e, i, l) {\n        let d,\n          p = \"\",\n          u,\n          g,\n          f;\n        n(l) || (f = arguments, l = {\n          duration: f[2],\n          easing: f[3],\n          complete: f[4]\n        }), r(l.duration) || (l.duration = 400), l.easing = \"function\" == typeof l.easing ? l.easing : Math[l.easing] || Math.easeInOutSine, l.curAnim = a(i), h(i, function (r, n) {\n          c(e, n), g = new t(e, l, n), u = void 0, \"d\" === n && o(i.d) ? (g.paths = g.initPath(e, e.pathArray, i.d), g.toD = i.d, d = 0, u = 1) : e.attr ? d = e.attr(n) : (d = parseFloat(s(e, n)) || 0, \"opacity\" !== n && (p = \"px\")), u || (u = r), \"string\" == typeof u && u.match(\"px\") && (u = u.replace(/px/g, \"\")), g.run(d, u, p);\n        });\n      },\n      animObject: d,\n      getDeferredAnimation: function (t, e, s) {\n        let o = d(e),\n          r = s ? [s] : t.series,\n          n = 0,\n          a = 0;\n        r.forEach(t => {\n          let s = d(t.options.animation);\n          n = e && i(e.defer) ? o.defer : Math.max(n, s.duration + s.defer), a = Math.min(o.duration, s.duration);\n        }), t.renderer.forExport && (n = 0);\n        let h = {\n          defer: Math.max(0, n - a),\n          duration: Math.min(n, a)\n        };\n        return h;\n      },\n      setAnimation: function (t, e) {\n        e.renderer.globalAnimation = l(t, e.options.chart.animation, !0);\n      },\n      stop: c\n    };\n  }), i(e, \"Core/Renderer/HTML/AST.js\", [e[\"Core/Globals.js\"], e[\"Core/Utilities.js\"]], function (t, e) {\n    let {\n        SVG_NS: i,\n        win: s\n      } = t,\n      {\n        attr: o,\n        createElement: r,\n        css: n,\n        error: a,\n        isFunction: h,\n        isString: l,\n        objectEach: d,\n        splat: c\n      } = e,\n      {\n        trustedTypes: p\n      } = s,\n      u = p && h(p.createPolicy) && p.createPolicy(\"highcharts\", {\n        createHTML: t => t\n      }),\n      g = u ? u.createHTML(\"\") : \"\",\n      f = function () {\n        try {\n          return !!new DOMParser().parseFromString(g, \"text/html\");\n        } catch (t) {\n          return !1;\n        }\n      }();\n    class m {\n      static filterUserAttributes(t) {\n        return d(t, (e, i) => {\n          let s = !0;\n          -1 === m.allowedAttributes.indexOf(i) && (s = !1), -1 !== [\"background\", \"dynsrc\", \"href\", \"lowsrc\", \"src\"].indexOf(i) && (s = l(e) && m.allowedReferences.some(t => 0 === e.indexOf(t))), s || (a(33, !1, void 0, {\n            \"Invalid attribute in config\": `${i}`\n          }), delete t[i]), l(e) && t[i] && (t[i] = e.replace(/</g, \"&lt;\"));\n        }), t;\n      }\n      static parseStyle(t) {\n        return t.split(\";\").reduce((t, e) => {\n          let i = e.split(\":\").map(t => t.trim()),\n            s = i.shift();\n          return s && i.length && (t[s.replace(/-([a-z])/g, t => t[1].toUpperCase())] = i.join(\":\")), t;\n        }, {});\n      }\n      static setElementHTML(t, e) {\n        if (t.innerHTML = m.emptyHTML, e) {\n          let i = new m(e);\n          i.addToDOM(t);\n        }\n      }\n      constructor(t) {\n        this.nodes = \"string\" == typeof t ? this.parseMarkup(t) : t;\n      }\n      addToDOM(e) {\n        return function e(s, r) {\n          let h;\n          return c(s).forEach(function (s) {\n            let l;\n            let c = s.tagName,\n              p = s.textContent ? t.doc.createTextNode(s.textContent) : void 0,\n              u = m.bypassHTMLFiltering;\n            if (c) {\n              if (\"#text\" === c) l = p;else if (-1 !== m.allowedTags.indexOf(c) || u) {\n                let a = \"svg\" === c ? i : r.namespaceURI || i,\n                  h = t.doc.createElementNS(a, c),\n                  g = s.attributes || {};\n                d(s, function (t, e) {\n                  \"tagName\" !== e && \"attributes\" !== e && \"children\" !== e && \"style\" !== e && \"textContent\" !== e && (g[e] = t);\n                }), o(h, u ? g : m.filterUserAttributes(g)), s.style && n(h, s.style), p && h.appendChild(p), e(s.children || [], h), l = h;\n              } else a(33, !1, void 0, {\n                \"Invalid tagName in config\": c\n              });\n            }\n            l && r.appendChild(l), h = l;\n          }), h;\n        }(this.nodes, e);\n      }\n      parseMarkup(t) {\n        let e;\n        let i = [];\n        if (t = t.trim().replace(/ style=([\"'])/g, \" data-style=$1\"), f) e = new DOMParser().parseFromString(u ? u.createHTML(t) : t, \"text/html\");else {\n          let i = r(\"div\");\n          i.innerHTML = t, e = {\n            body: i\n          };\n        }\n        let s = (t, e) => {\n          let i = t.nodeName.toLowerCase(),\n            o = {\n              tagName: i\n            };\n          \"#text\" === i && (o.textContent = t.textContent || \"\");\n          let r = t.attributes;\n          if (r) {\n            let t = {};\n            [].forEach.call(r, e => {\n              \"data-style\" === e.name ? o.style = m.parseStyle(e.value) : t[e.name] = e.value;\n            }), o.attributes = t;\n          }\n          if (t.childNodes.length) {\n            let e = [];\n            [].forEach.call(t.childNodes, t => {\n              s(t, e);\n            }), e.length && (o.children = e);\n          }\n          e.push(o);\n        };\n        return [].forEach.call(e.body.childNodes, t => s(t, i)), i;\n      }\n    }\n    return m.allowedAttributes = [\"alt\", \"aria-controls\", \"aria-describedby\", \"aria-expanded\", \"aria-haspopup\", \"aria-hidden\", \"aria-label\", \"aria-labelledby\", \"aria-live\", \"aria-pressed\", \"aria-readonly\", \"aria-roledescription\", \"aria-selected\", \"class\", \"clip-path\", \"color\", \"colspan\", \"cx\", \"cy\", \"d\", \"dx\", \"dy\", \"disabled\", \"fill\", \"filterUnits\", \"flood-color\", \"flood-opacity\", \"height\", \"href\", \"id\", \"in\", \"markerHeight\", \"markerWidth\", \"offset\", \"opacity\", \"orient\", \"padding\", \"paddingLeft\", \"paddingRight\", \"patternUnits\", \"r\", \"refX\", \"refY\", \"role\", \"scope\", \"slope\", \"src\", \"startOffset\", \"stdDeviation\", \"stroke\", \"stroke-linecap\", \"stroke-width\", \"style\", \"tableValues\", \"result\", \"rowspan\", \"summary\", \"target\", \"tabindex\", \"text-align\", \"text-anchor\", \"textAnchor\", \"textLength\", \"title\", \"type\", \"valign\", \"width\", \"x\", \"x1\", \"x2\", \"xlink:href\", \"y\", \"y1\", \"y2\", \"zIndex\"], m.allowedReferences = [\"https://\", \"http://\", \"mailto:\", \"/\", \"../\", \"./\", \"#\"], m.allowedTags = [\"a\", \"abbr\", \"b\", \"br\", \"button\", \"caption\", \"circle\", \"clipPath\", \"code\", \"dd\", \"defs\", \"div\", \"dl\", \"dt\", \"em\", \"feComponentTransfer\", \"feDropShadow\", \"feFuncA\", \"feFuncB\", \"feFuncG\", \"feFuncR\", \"feGaussianBlur\", \"feOffset\", \"feMerge\", \"feMergeNode\", \"filter\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"hr\", \"i\", \"img\", \"li\", \"linearGradient\", \"marker\", \"ol\", \"p\", \"path\", \"pattern\", \"pre\", \"rect\", \"small\", \"span\", \"stop\", \"strong\", \"style\", \"sub\", \"sup\", \"svg\", \"table\", \"text\", \"textPath\", \"thead\", \"title\", \"tbody\", \"tspan\", \"td\", \"th\", \"tr\", \"u\", \"ul\", \"#text\"], m.emptyHTML = g, m.bypassHTMLFiltering = !1, m;\n  }), i(e, \"Core/Templating.js\", [e[\"Core/Defaults.js\"], e[\"Core/Utilities.js\"]], function (t, e) {\n    let {\n        defaultOptions: i,\n        defaultTime: s\n      } = t,\n      {\n        extend: o,\n        getNestedProperty: r,\n        isArray: n,\n        isNumber: a,\n        isObject: h,\n        isString: l,\n        pick: d,\n        pInt: c\n      } = e,\n      p = {\n        add: (t, e) => t + e,\n        divide: (t, e) => 0 !== e ? t / e : \"\",\n        eq: (t, e) => t == e,\n        each: function (t) {\n          let e = arguments[arguments.length - 1];\n          return !!n(t) && t.map((i, s) => u(e.body, o(h(i) ? i : {\n            \"@this\": i\n          }, {\n            \"@index\": s,\n            \"@first\": 0 === s,\n            \"@last\": s === t.length - 1\n          }))).join(\"\");\n        },\n        ge: (t, e) => t >= e,\n        gt: (t, e) => t > e,\n        if: t => !!t,\n        le: (t, e) => t <= e,\n        lt: (t, e) => t < e,\n        multiply: (t, e) => t * e,\n        ne: (t, e) => t != e,\n        subtract: (t, e) => t - e,\n        unless: t => !t\n      };\n    function u(t = \"\", e, o) {\n      let n = /\\{([a-zA-Z0-9\\:\\.\\,;\\-\\/<>%_@\"'= #\\(\\)]+)\\}/g,\n        a = /\\(([a-zA-Z0-9\\:\\.\\,;\\-\\/<>%_@\"'= ]+)\\)/g,\n        h = [],\n        l = /f$/,\n        c = /\\.([0-9])/,\n        f = i.lang,\n        m = o && o.time || s,\n        x = o && o.numberFormatter || g,\n        y = (t = \"\") => {\n          let i;\n          return \"true\" === t || \"false\" !== t && ((i = Number(t)).toString() === t ? i : r(t, e));\n        },\n        b,\n        v,\n        k = 0,\n        S;\n      for (; null !== (b = n.exec(t));) {\n        let i = a.exec(b[1]);\n        i && (b = i, S = !0), v && v.isBlock || (v = {\n          ctx: e,\n          expression: b[1],\n          find: b[0],\n          isBlock: \"#\" === b[1].charAt(0),\n          start: b.index,\n          startInner: b.index + b[0].length,\n          length: b[0].length\n        });\n        let s = b[1].split(\" \")[0].replace(\"#\", \"\");\n        p[s] && (v.isBlock && s === v.fn && k++, v.fn || (v.fn = s));\n        let o = \"else\" === b[1];\n        if (v.isBlock && v.fn && (b[1] === `/${v.fn}` || o)) {\n          if (k) !o && k--;else {\n            let e = v.startInner,\n              i = t.substr(e, b.index - e);\n            void 0 === v.body ? (v.body = i, v.startInner = b.index + b[0].length) : v.elseBody = i, v.find += i + b[0], o || (h.push(v), v = void 0);\n          }\n        } else v.isBlock || h.push(v);\n        if (i && !v?.isBlock) break;\n      }\n      return h.forEach(i => {\n        let s, o;\n        let {\n          body: r,\n          elseBody: n,\n          expression: a,\n          fn: h\n        } = i;\n        if (h) {\n          let t = [i],\n            l = a.split(\" \");\n          for (o = p[h].length; o--;) t.unshift(y(l[o + 1]));\n          s = p[h].apply(e, t), i.isBlock && \"boolean\" == typeof s && (s = u(s ? r : n, e));\n        } else {\n          let t = a.split(\":\");\n          if (s = y(t.shift() || \"\"), t.length && \"number\" == typeof s) {\n            let e = t.join(\":\");\n            if (l.test(e)) {\n              let t = parseInt((e.match(c) || [\"\", \"-1\"])[1], 10);\n              null !== s && (s = x(s, t, f.decimalPoint, e.indexOf(\",\") > -1 ? f.thousandsSep : \"\"));\n            } else s = m.dateFormat(e, s);\n          }\n        }\n        t = t.replace(i.find, d(s, \"\"));\n      }), S ? u(t, e, o) : t;\n    }\n    function g(t, e, s, o) {\n      let r, n;\n      t = +t || 0, e = +e;\n      let h = i.lang,\n        l = (t.toString().split(\".\")[1] || \"\").split(\"e\")[0].length,\n        p = t.toString().split(\"e\"),\n        u = e;\n      -1 === e ? e = Math.min(l, 20) : a(e) ? e && p[1] && p[1] < 0 && ((n = e + +p[1]) >= 0 ? (p[0] = (+p[0]).toExponential(n).split(\"e\")[0], e = n) : (p[0] = p[0].split(\".\")[0] || 0, t = e < 20 ? (p[0] * Math.pow(10, p[1])).toFixed(e) : 0, p[1] = 0)) : e = 2;\n      let g = (Math.abs(p[1] ? p[0] : t) + Math.pow(10, -Math.max(e, l) - 1)).toFixed(e),\n        f = String(c(g)),\n        m = f.length > 3 ? f.length % 3 : 0;\n      return s = d(s, h.decimalPoint), o = d(o, h.thousandsSep), r = (t < 0 ? \"-\" : \"\") + (m ? f.substr(0, m) + o : \"\"), 0 > +p[1] && !u ? r = \"0\" : r += f.substr(m).replace(/(\\d{3})(?=\\d)/g, \"$1\" + o), e && (r += s + g.slice(-e)), p[1] && 0 != +r && (r += \"e\" + p[1]), r;\n    }\n    return {\n      dateFormat: function (t, e, i) {\n        return s.dateFormat(t, e, i);\n      },\n      format: u,\n      helpers: p,\n      numberFormat: g\n    };\n  }), i(e, \"Core/Renderer/RendererUtilities.js\", [e[\"Core/Utilities.js\"]], function (t) {\n    var e;\n    let {\n      clamp: i,\n      pick: s,\n      pushUnique: o,\n      stableSort: r\n    } = t;\n    return (e || (e = {})).distribute = function t(e, n, a) {\n      let h = e,\n        l = h.reducedLen || n,\n        d = (t, e) => t.target - e.target,\n        c = [],\n        p = e.length,\n        u = [],\n        g = c.push,\n        f,\n        m,\n        x,\n        y = !0,\n        b,\n        v,\n        k = 0,\n        S;\n      for (f = p; f--;) k += e[f].size;\n      if (k > l) {\n        for (r(e, (t, e) => (e.rank || 0) - (t.rank || 0)), x = (S = e[0].rank === e[e.length - 1].rank) ? p / 2 : -1, m = S ? x : p - 1; x && k > l;) b = e[f = Math.floor(m)], o(u, f) && (k -= b.size), m += x, S && m >= e.length && (x /= 2, m = x);\n        u.sort((t, e) => e - t).forEach(t => g.apply(c, e.splice(t, 1)));\n      }\n      for (r(e, d), e = e.map(t => ({\n        size: t.size,\n        targets: [t.target],\n        align: s(t.align, .5)\n      })); y;) {\n        for (f = e.length; f--;) b = e[f], v = (Math.min.apply(0, b.targets) + Math.max.apply(0, b.targets)) / 2, b.pos = i(v - b.size * b.align, 0, n - b.size);\n        for (f = e.length, y = !1; f--;) f > 0 && e[f - 1].pos + e[f - 1].size > e[f].pos && (e[f - 1].size += e[f].size, e[f - 1].targets = e[f - 1].targets.concat(e[f].targets), e[f - 1].align = .5, e[f - 1].pos + e[f - 1].size > n && (e[f - 1].pos = n - e[f - 1].size), e.splice(f, 1), y = !0);\n      }\n      return g.apply(h, c), f = 0, e.some(e => {\n        let i = 0;\n        return (e.targets || []).some(() => (h[f].pos = e.pos + i, void 0 !== a && Math.abs(h[f].pos - h[f].target) > a) ? (h.slice(0, f + 1).forEach(t => delete t.pos), h.reducedLen = (h.reducedLen || n) - .1 * n, h.reducedLen > .1 * n && t(h, n, a), !0) : (i += h[f].size, f++, !1));\n      }), r(h, d), h;\n    }, e;\n  }), i(e, \"Core/Renderer/SVG/SVGElement.js\", [e[\"Core/Animation/AnimationUtilities.js\"], e[\"Core/Color/Color.js\"], e[\"Core/Globals.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s) {\n    let {\n        animate: o,\n        animObject: r,\n        stop: n\n      } = t,\n      {\n        deg2rad: a,\n        doc: h,\n        noop: l,\n        svg: d,\n        SVG_NS: c,\n        win: p\n      } = i,\n      {\n        addEvent: u,\n        attr: g,\n        createElement: f,\n        css: m,\n        defined: x,\n        erase: y,\n        extend: b,\n        fireEvent: v,\n        isArray: k,\n        isFunction: S,\n        isObject: M,\n        isString: C,\n        merge: w,\n        objectEach: T,\n        pick: A,\n        pInt: P,\n        syncTimeout: L,\n        uniqueKey: O\n      } = s;\n    class D {\n      constructor() {\n        this.element = void 0, this.onEvents = {}, this.opacity = 1, this.renderer = void 0, this.SVG_NS = c;\n      }\n      _defaultGetter(t) {\n        let e = A(this[t + \"Value\"], this[t], this.element ? this.element.getAttribute(t) : null, 0);\n        return /^[\\-0-9\\.]+$/.test(e) && (e = parseFloat(e)), e;\n      }\n      _defaultSetter(t, e, i) {\n        i.setAttribute(e, t);\n      }\n      add(t) {\n        let e;\n        let i = this.renderer,\n          s = this.element;\n        return t && (this.parentGroup = t), void 0 !== this.textStr && \"text\" === this.element.nodeName && i.buildText(this), this.added = !0, (!t || t.handleZ || this.zIndex) && (e = this.zIndexSetter()), e || (t ? t.element : i.box).appendChild(s), this.onAdd && this.onAdd(), this;\n      }\n      addClass(t, e) {\n        let i = e ? \"\" : this.attr(\"class\") || \"\";\n        return (t = (t || \"\").split(/ /g).reduce(function (t, e) {\n          return -1 === i.indexOf(e) && t.push(e), t;\n        }, i ? [i] : []).join(\" \")) !== i && this.attr(\"class\", t), this;\n      }\n      afterSetters() {\n        this.doTransform && (this.updateTransform(), this.doTransform = !1);\n      }\n      align(t, e, i) {\n        let s, o, r, n, a;\n        let h = {},\n          l = this.renderer,\n          d = l.alignedObjects;\n        t ? (this.alignOptions = t, this.alignByTranslate = e, (!i || C(i)) && (this.alignTo = r = i || \"renderer\", y(d, this), d.push(this), i = void 0)) : (t = this.alignOptions, e = this.alignByTranslate, r = this.alignTo), i = A(i, l[r], \"scrollablePlotBox\" === r ? l.plotBox : void 0, l);\n        let c = t.align,\n          p = t.verticalAlign;\n        return s = (i.x || 0) + (t.x || 0), o = (i.y || 0) + (t.y || 0), \"right\" === c ? n = 1 : \"center\" === c && (n = 2), n && (s += (i.width - (t.width || 0)) / n), h[e ? \"translateX\" : \"x\"] = Math.round(s), \"bottom\" === p ? a = 1 : \"middle\" === p && (a = 2), a && (o += (i.height - (t.height || 0)) / a), h[e ? \"translateY\" : \"y\"] = Math.round(o), this[this.placed ? \"animate\" : \"attr\"](h), this.placed = !0, this.alignAttr = h, this;\n      }\n      alignSetter(t) {\n        let e = {\n          left: \"start\",\n          center: \"middle\",\n          right: \"end\"\n        };\n        e[t] && (this.alignValue = t, this.element.setAttribute(\"text-anchor\", e[t]));\n      }\n      animate(t, e, i) {\n        let s = r(A(e, this.renderer.globalAnimation, !0)),\n          n = s.defer;\n        return h.hidden && (s.duration = 0), 0 !== s.duration ? (i && (s.complete = i), L(() => {\n          this.element && o(this, t, s);\n        }, n)) : (this.attr(t, void 0, i || s.complete), T(t, function (t, e) {\n          s.step && s.step.call(this, t, {\n            prop: e,\n            pos: 1,\n            elem: this\n          });\n        }, this)), this;\n      }\n      applyTextOutline(t) {\n        let e = this.element,\n          s = -1 !== t.indexOf(\"contrast\");\n        s && (t = t.replace(/contrast/g, this.renderer.getContrast(e.style.fill)));\n        let o = t.split(\" \"),\n          r = o[o.length - 1],\n          n = o[0];\n        if (n && \"none\" !== n && i.svg) {\n          this.fakeTS = !0, n = n.replace(/(^[\\d\\.]+)(.*?)$/g, function (t, e, i) {\n            return 2 * Number(e) + i;\n          }), this.removeTextOutline();\n          let t = h.createElementNS(c, \"tspan\");\n          g(t, {\n            class: \"highcharts-text-outline\",\n            fill: r,\n            stroke: r,\n            \"stroke-width\": n,\n            \"stroke-linejoin\": \"round\"\n          });\n          let i = e.querySelector(\"textPath\") || e;\n          [].forEach.call(i.childNodes, e => {\n            let i = e.cloneNode(!0);\n            i.removeAttribute && [\"fill\", \"stroke\", \"stroke-width\", \"stroke\"].forEach(t => i.removeAttribute(t)), t.appendChild(i);\n          });\n          let s = 0;\n          [].forEach.call(i.querySelectorAll(\"text tspan\"), t => {\n            s += Number(t.getAttribute(\"dy\"));\n          });\n          let o = h.createElementNS(c, \"tspan\");\n          o.textContent = \"‚Äã\", g(o, {\n            x: Number(e.getAttribute(\"x\")),\n            dy: -s\n          }), t.appendChild(o), i.insertBefore(t, i.firstChild);\n        }\n      }\n      attr(t, e, i, s) {\n        let o = this.element,\n          r = D.symbolCustomAttribs,\n          a,\n          h,\n          l = this,\n          d;\n        return \"string\" == typeof t && void 0 !== e && (a = t, (t = {})[a] = e), \"string\" == typeof t ? l = (this[t + \"Getter\"] || this._defaultGetter).call(this, t, o) : (T(t, function (e, i) {\n          d = !1, s || n(this, i), this.symbolName && -1 !== r.indexOf(i) && (h || (this.symbolAttr(t), h = !0), d = !0), this.rotation && (\"x\" === i || \"y\" === i) && (this.doTransform = !0), d || (this[i + \"Setter\"] || this._defaultSetter).call(this, e, i, o);\n        }, this), this.afterSetters()), i && i.call(this), l;\n      }\n      clip(t) {\n        return this.attr(\"clip-path\", t ? \"url(\" + this.renderer.url + \"#\" + t.id + \")\" : \"none\");\n      }\n      crisp(t, e) {\n        e = e || t.strokeWidth || 0;\n        let i = Math.round(e) % 2 / 2;\n        return t.x = Math.floor(t.x || this.x || 0) + i, t.y = Math.floor(t.y || this.y || 0) + i, t.width = Math.floor((t.width || this.width || 0) - 2 * i), t.height = Math.floor((t.height || this.height || 0) - 2 * i), x(t.strokeWidth) && (t.strokeWidth = e), t;\n      }\n      complexColor(t, i, s) {\n        let o = this.renderer,\n          r,\n          n,\n          a,\n          h,\n          l,\n          d,\n          c,\n          p,\n          u,\n          g,\n          f = [],\n          m;\n        v(this.renderer, \"complexColor\", {\n          args: arguments\n        }, function () {\n          if (t.radialGradient ? n = \"radialGradient\" : t.linearGradient && (n = \"linearGradient\"), n) {\n            if (a = t[n], l = o.gradients, d = t.stops, u = s.radialReference, k(a) && (t[n] = a = {\n              x1: a[0],\n              y1: a[1],\n              x2: a[2],\n              y2: a[3],\n              gradientUnits: \"userSpaceOnUse\"\n            }), \"radialGradient\" === n && u && !x(a.gradientUnits) && (h = a, a = w(a, o.getRadialAttr(u, h), {\n              gradientUnits: \"userSpaceOnUse\"\n            })), T(a, function (t, e) {\n              \"id\" !== e && f.push(e, t);\n            }), T(d, function (t) {\n              f.push(t);\n            }), l[f = f.join(\",\")]) g = l[f].attr(\"id\");else {\n              a.id = g = O();\n              let t = l[f] = o.createElement(n).attr(a).add(o.defs);\n              t.radAttr = h, t.stops = [], d.forEach(function (i) {\n                0 === i[1].indexOf(\"rgba\") ? (c = (r = e.parse(i[1])).get(\"rgb\"), p = r.get(\"a\")) : (c = i[1], p = 1);\n                let s = o.createElement(\"stop\").attr({\n                  offset: i[0],\n                  \"stop-color\": c,\n                  \"stop-opacity\": p\n                }).add(t);\n                t.stops.push(s);\n              });\n            }\n            m = \"url(\" + o.url + \"#\" + g + \")\", s.setAttribute(i, m), s.gradient = f, t.toString = function () {\n              return m;\n            };\n          }\n        });\n      }\n      css(t) {\n        let e = this.styles,\n          i = {},\n          s = this.element,\n          o,\n          r = !e;\n        if (e && T(t, function (t, s) {\n          e && e[s] !== t && (i[s] = t, r = !0);\n        }), r) {\n          e && (t = b(e, i)), null === t.width || \"auto\" === t.width ? delete this.textWidth : \"text\" === s.nodeName.toLowerCase() && t.width && (o = this.textWidth = P(t.width)), this.styles = t, o && !d && this.renderer.forExport && delete t.width;\n          let r = w(t);\n          s.namespaceURI === this.SVG_NS && ([\"textOutline\", \"textOverflow\", \"width\"].forEach(t => r && delete r[t]), r.color && (r.fill = r.color)), m(s, r);\n        }\n        return this.added && (\"text\" === this.element.nodeName && this.renderer.buildText(this), t.textOutline && this.applyTextOutline(t.textOutline)), this;\n      }\n      dashstyleSetter(t) {\n        let e,\n          i = this[\"stroke-width\"];\n        if (\"inherit\" === i && (i = 1), t = t && t.toLowerCase()) {\n          let s = t.replace(\"shortdashdotdot\", \"3,1,1,1,1,1,\").replace(\"shortdashdot\", \"3,1,1,1\").replace(\"shortdot\", \"1,1,\").replace(\"shortdash\", \"3,1,\").replace(\"longdash\", \"8,3,\").replace(/dot/g, \"1,3,\").replace(\"dash\", \"4,3,\").replace(/,$/, \"\").split(\",\");\n          for (e = s.length; e--;) s[e] = \"\" + P(s[e]) * A(i, NaN);\n          t = s.join(\",\").replace(/NaN/g, \"none\"), this.element.setAttribute(\"stroke-dasharray\", t);\n        }\n      }\n      destroy() {\n        let t = this,\n          e = t.element || {},\n          i = t.renderer,\n          s = e.ownerSVGElement,\n          o = \"SPAN\" === e.nodeName && t.parentGroup || void 0,\n          r,\n          a;\n        if (e.onclick = e.onmouseout = e.onmouseover = e.onmousemove = e.point = null, n(t), t.clipPath && s) {\n          let e = t.clipPath;\n          [].forEach.call(s.querySelectorAll(\"[clip-path],[CLIP-PATH]\"), function (t) {\n            t.getAttribute(\"clip-path\").indexOf(e.element.id) > -1 && t.removeAttribute(\"clip-path\");\n          }), t.clipPath = e.destroy();\n        }\n        if (t.connector = t.connector?.destroy(), t.stops) {\n          for (a = 0; a < t.stops.length; a++) t.stops[a].destroy();\n          t.stops.length = 0, t.stops = void 0;\n        }\n        for (t.safeRemoveChild(e); o && o.div && 0 === o.div.childNodes.length;) r = o.parentGroup, t.safeRemoveChild(o.div), delete o.div, o = r;\n        t.alignTo && y(i.alignedObjects, t), T(t, function (e, i) {\n          t[i] && t[i].parentGroup === t && t[i].destroy && t[i].destroy(), delete t[i];\n        });\n      }\n      dSetter(t, e, i) {\n        k(t) && (\"string\" == typeof t[0] && (t = this.renderer.pathToSegments(t)), this.pathArray = t, t = t.reduce((t, e, i) => e && e.join ? (i ? t + \" \" : \"\") + e.join(\" \") : (e || \"\").toString(), \"\")), /(NaN| {2}|^$)/.test(t) && (t = \"M 0 0\"), this[e] !== t && (i.setAttribute(e, t), this[e] = t);\n      }\n      fillSetter(t, e, i) {\n        \"string\" == typeof t ? i.setAttribute(e, t) : t && this.complexColor(t, e, i);\n      }\n      hrefSetter(t, e, i) {\n        i.setAttributeNS(\"http://www.w3.org/1999/xlink\", e, t);\n      }\n      getBBox(t, e) {\n        let i, s, o, r, n;\n        let {\n            alignValue: h,\n            element: l,\n            renderer: d,\n            styles: c,\n            textStr: p\n          } = this,\n          {\n            cache: u,\n            cacheKeys: g\n          } = d,\n          f = l.namespaceURI === this.SVG_NS,\n          y = A(e, this.rotation, 0),\n          v = d.styledMode ? l && D.prototype.getStyle.call(l, \"font-size\") : c && c.fontSize;\n        if (x(p) && (-1 === (n = p.toString()).indexOf(\"<\") && (n = n.replace(/[0-9]/g, \"0\")), n += [\"\", d.rootFontSize, v, y, this.textWidth, h, c && c.textOverflow, c && c.fontWeight].join(\",\")), n && !t && (i = u[n]), !i) {\n          if (f || d.forExport) {\n            try {\n              r = this.fakeTS && function (t) {\n                let e = l.querySelector(\".highcharts-text-outline\");\n                e && m(e, {\n                  display: t\n                });\n              }, S(r) && r(\"none\"), i = l.getBBox ? b({}, l.getBBox()) : {\n                width: l.offsetWidth,\n                height: l.offsetHeight,\n                x: 0,\n                y: 0\n              }, S(r) && r(\"\");\n            } catch (t) {}\n            (!i || i.width < 0) && (i = {\n              x: 0,\n              y: 0,\n              width: 0,\n              height: 0\n            });\n          } else i = this.htmlGetBBox();\n          if (s = i.width, o = i.height, f && (i.height = o = {\n            \"11px,17\": 14,\n            \"13px,20\": 16\n          }[`${v || \"\"},${Math.round(o)}`] || o), y) {\n            let t = Number(l.getAttribute(\"y\") || 0) - i.y,\n              e = {\n                right: 1,\n                center: .5\n              }[h || 0] || 0,\n              r = y * a,\n              n = (y - 90) * a,\n              d = s * Math.cos(r),\n              c = s * Math.sin(r),\n              p = Math.cos(n),\n              u = Math.sin(n),\n              g = i.x + e * (s - d),\n              f = i.y + t - e * c,\n              m = g + t * p,\n              x = m + d,\n              b = x - o * p,\n              v = b - d,\n              k = f + t * u,\n              S = k + c,\n              M = S - o * u,\n              C = M - c;\n            i.x = Math.min(m, x, b, v), i.y = Math.min(k, S, M, C), i.width = Math.max(m, x, b, v) - i.x, i.height = Math.max(k, S, M, C) - i.y;\n          }\n        }\n        if (n && (\"\" === p || i.height > 0)) {\n          for (; g.length > 250;) delete u[g.shift()];\n          u[n] || g.push(n), u[n] = i;\n        }\n        return i;\n      }\n      getStyle(t) {\n        return p.getComputedStyle(this.element || this, \"\").getPropertyValue(t);\n      }\n      hasClass(t) {\n        return -1 !== (\"\" + this.attr(\"class\")).split(\" \").indexOf(t);\n      }\n      hide() {\n        return this.attr({\n          visibility: \"hidden\"\n        });\n      }\n      htmlGetBBox() {\n        return {\n          height: 0,\n          width: 0,\n          x: 0,\n          y: 0\n        };\n      }\n      init(t, e) {\n        this.element = \"span\" === e ? f(e) : h.createElementNS(this.SVG_NS, e), this.renderer = t, v(this, \"afterInit\");\n      }\n      on(t, e) {\n        let {\n          onEvents: i\n        } = this;\n        return i[t] && i[t](), i[t] = u(this.element, t, e), this;\n      }\n      opacitySetter(t, e, i) {\n        let s = Number(Number(t).toFixed(3));\n        this.opacity = s, i.setAttribute(e, s);\n      }\n      removeClass(t) {\n        return this.attr(\"class\", (\"\" + this.attr(\"class\")).replace(C(t) ? RegExp(`(^| )${t}( |$)`) : t, \" \").replace(/ +/g, \" \").trim());\n      }\n      removeTextOutline() {\n        let t = this.element.querySelector(\"tspan.highcharts-text-outline\");\n        t && this.safeRemoveChild(t);\n      }\n      safeRemoveChild(t) {\n        let e = t.parentNode;\n        e && e.removeChild(t);\n      }\n      setRadialReference(t) {\n        let e = this.element.gradient && this.renderer.gradients[this.element.gradient];\n        return this.element.radialReference = t, e && e.radAttr && e.animate(this.renderer.getRadialAttr(t, e.radAttr)), this;\n      }\n      setTextPath(t, e) {\n        e = w(!0, {\n          enabled: !0,\n          attributes: {\n            dy: -5,\n            startOffset: \"50%\",\n            textAnchor: \"middle\"\n          }\n        }, e);\n        let i = this.renderer.url,\n          s = this.text || this,\n          o = s.textPath,\n          {\n            attributes: r,\n            enabled: n\n          } = e;\n        if (t = t || o && o.path, o && o.undo(), t && n) {\n          let e = u(s, \"afterModifyTree\", e => {\n            if (t && n) {\n              let o = t.attr(\"id\");\n              o || t.attr(\"id\", o = O());\n              let n = {\n                x: 0,\n                y: 0\n              };\n              x(r.dx) && (n.dx = r.dx, delete r.dx), x(r.dy) && (n.dy = r.dy, delete r.dy), s.attr(n), this.attr({\n                transform: \"\"\n              }), this.box && (this.box = this.box.destroy());\n              let a = e.nodes.slice(0);\n              e.nodes.length = 0, e.nodes[0] = {\n                tagName: \"textPath\",\n                attributes: b(r, {\n                  \"text-anchor\": r.textAnchor,\n                  href: `${i}#${o}`\n                }),\n                children: a\n              };\n            }\n          });\n          s.textPath = {\n            path: t,\n            undo: e\n          };\n        } else s.attr({\n          dx: 0,\n          dy: 0\n        }), delete s.textPath;\n        return this.added && (s.textCache = \"\", this.renderer.buildText(s)), this;\n      }\n      shadow(t) {\n        let {\n            renderer: e\n          } = this,\n          i = w(this.parentGroup?.rotation === 90 ? {\n            offsetX: -1,\n            offsetY: -1\n          } : {}, M(t) ? t : {}),\n          s = e.shadowDefinition(i);\n        return this.attr({\n          filter: t ? `url(${e.url}#${s})` : \"none\"\n        });\n      }\n      show(t = !0) {\n        return this.attr({\n          visibility: t ? \"inherit\" : \"visible\"\n        });\n      }\n      \"stroke-widthSetter\"(t, e, i) {\n        this[e] = t, i.setAttribute(e, t);\n      }\n      strokeWidth() {\n        if (!this.renderer.styledMode) return this[\"stroke-width\"] || 0;\n        let t = this.getStyle(\"stroke-width\"),\n          e = 0,\n          i;\n        return t.indexOf(\"px\") === t.length - 2 ? e = P(t) : \"\" !== t && (g(i = h.createElementNS(c, \"rect\"), {\n          width: t,\n          \"stroke-width\": 0\n        }), this.element.parentNode.appendChild(i), e = i.getBBox().width, i.parentNode.removeChild(i)), e;\n      }\n      symbolAttr(t) {\n        let e = this;\n        D.symbolCustomAttribs.forEach(function (i) {\n          e[i] = A(t[i], e[i]);\n        }), e.attr({\n          d: e.renderer.symbols[e.symbolName](e.x, e.y, e.width, e.height, e)\n        });\n      }\n      textSetter(t) {\n        t !== this.textStr && (delete this.textPxLength, this.textStr = t, this.added && this.renderer.buildText(this));\n      }\n      titleSetter(t) {\n        let e = this.element,\n          i = e.getElementsByTagName(\"title\")[0] || h.createElementNS(this.SVG_NS, \"title\");\n        e.insertBefore ? e.insertBefore(i, e.firstChild) : e.appendChild(i), i.textContent = String(A(t, \"\")).replace(/<[^>]*>/g, \"\").replace(/&lt;/g, \"<\").replace(/&gt;/g, \">\");\n      }\n      toFront() {\n        let t = this.element;\n        return t.parentNode.appendChild(t), this;\n      }\n      translate(t, e) {\n        return this.attr({\n          translateX: t,\n          translateY: e\n        });\n      }\n      updateTransform() {\n        let {\n            element: t,\n            matrix: e,\n            rotation: i = 0,\n            scaleX: s,\n            scaleY: o,\n            translateX: r = 0,\n            translateY: n = 0\n          } = this,\n          a = [\"translate(\" + r + \",\" + n + \")\"];\n        x(e) && a.push(\"matrix(\" + e.join(\",\") + \")\"), i && a.push(\"rotate(\" + i + \" \" + A(this.rotationOriginX, t.getAttribute(\"x\"), 0) + \" \" + A(this.rotationOriginY, t.getAttribute(\"y\") || 0) + \")\"), (x(s) || x(o)) && a.push(\"scale(\" + A(s, 1) + \" \" + A(o, 1) + \")\"), a.length && !(this.text || this).textPath && t.setAttribute(\"transform\", a.join(\" \"));\n      }\n      visibilitySetter(t, e, i) {\n        \"inherit\" === t ? i.removeAttribute(e) : this[e] !== t && i.setAttribute(e, t), this[e] = t;\n      }\n      xGetter(t) {\n        return \"circle\" === this.element.nodeName && (\"x\" === t ? t = \"cx\" : \"y\" === t && (t = \"cy\")), this._defaultGetter(t);\n      }\n      zIndexSetter(t, e) {\n        let i = this.renderer,\n          s = this.parentGroup,\n          o = s || i,\n          r = o.element || i.box,\n          n = this.element,\n          a = r === i.box,\n          h,\n          l,\n          d,\n          c = !1,\n          p,\n          u = this.added,\n          g;\n        if (x(t) ? (n.setAttribute(\"data-z-index\", t), t = +t, this[e] === t && (u = !1)) : x(this[e]) && n.removeAttribute(\"data-z-index\"), this[e] = t, u) {\n          for ((t = this.zIndex) && s && (s.handleZ = !0), g = (h = r.childNodes).length - 1; g >= 0 && !c; g--) p = !x(d = (l = h[g]).getAttribute(\"data-z-index\")), l !== n && (t < 0 && p && !a && !g ? (r.insertBefore(n, h[g]), c = !0) : (P(d) <= t || p && (!x(t) || t >= 0)) && (r.insertBefore(n, h[g + 1]), c = !0));\n          c || (r.insertBefore(n, h[a ? 3 : 0]), c = !0);\n        }\n        return c;\n      }\n    }\n    return D.symbolCustomAttribs = [\"anchorX\", \"anchorY\", \"clockwise\", \"end\", \"height\", \"innerR\", \"r\", \"start\", \"width\", \"x\", \"y\"], D.prototype.strokeSetter = D.prototype.fillSetter, D.prototype.yGetter = D.prototype.xGetter, D.prototype.matrixSetter = D.prototype.rotationOriginXSetter = D.prototype.rotationOriginYSetter = D.prototype.rotationSetter = D.prototype.scaleXSetter = D.prototype.scaleYSetter = D.prototype.translateXSetter = D.prototype.translateYSetter = D.prototype.verticalAlignSetter = function (t, e) {\n      this[e] = t, this.doTransform = !0;\n    }, D;\n  }), i(e, \"Core/Renderer/RendererRegistry.js\", [e[\"Core/Globals.js\"]], function (t) {\n    var e, i;\n    let s;\n    return (i = e || (e = {})).rendererTypes = {}, i.getRendererType = function (t = s) {\n      return i.rendererTypes[t] || i.rendererTypes[s];\n    }, i.registerRendererType = function (e, o, r) {\n      i.rendererTypes[e] = o, (!s || r) && (s = e, t.Renderer = o);\n    }, e;\n  }), i(e, \"Core/Renderer/SVG/SVGLabel.js\", [e[\"Core/Renderer/SVG/SVGElement.js\"], e[\"Core/Utilities.js\"]], function (t, e) {\n    let {\n      defined: i,\n      extend: s,\n      isNumber: o,\n      merge: r,\n      pick: n,\n      removeEvent: a\n    } = e;\n    class h extends t {\n      constructor(t, e, i, s, o, r, n, a, l, d) {\n        let c;\n        super(), this.paddingLeftSetter = this.paddingSetter, this.paddingRightSetter = this.paddingSetter, this.init(t, \"g\"), this.textStr = e, this.x = i, this.y = s, this.anchorX = r, this.anchorY = n, this.baseline = l, this.className = d, this.addClass(\"button\" === d ? \"highcharts-no-tooltip\" : \"highcharts-label\"), d && this.addClass(\"highcharts-\" + d), this.text = t.text(void 0, 0, 0, a).attr({\n          zIndex: 1\n        }), \"string\" == typeof o && ((c = /^url\\((.*?)\\)$/.test(o)) || this.renderer.symbols[o]) && (this.symbolKey = o), this.bBox = h.emptyBBox, this.padding = 3, this.baselineOffset = 0, this.needsBox = t.styledMode || c, this.deferredAttr = {}, this.alignFactor = 0;\n      }\n      alignSetter(t) {\n        let e = {\n          left: 0,\n          center: .5,\n          right: 1\n        }[t];\n        e !== this.alignFactor && (this.alignFactor = e, this.bBox && o(this.xSetting) && this.attr({\n          x: this.xSetting\n        }));\n      }\n      anchorXSetter(t, e) {\n        this.anchorX = t, this.boxAttr(e, Math.round(t) - this.getCrispAdjust() - this.xSetting);\n      }\n      anchorYSetter(t, e) {\n        this.anchorY = t, this.boxAttr(e, t - this.ySetting);\n      }\n      boxAttr(t, e) {\n        this.box ? this.box.attr(t, e) : this.deferredAttr[t] = e;\n      }\n      css(e) {\n        if (e) {\n          let t = {};\n          e = r(e), h.textProps.forEach(i => {\n            void 0 !== e[i] && (t[i] = e[i], delete e[i]);\n          }), this.text.css(t), \"fontSize\" in t || \"fontWeight\" in t ? this.updateTextPadding() : (\"width\" in t || \"textOverflow\" in t) && this.updateBoxSize();\n        }\n        return t.prototype.css.call(this, e);\n      }\n      destroy() {\n        a(this.element, \"mouseenter\"), a(this.element, \"mouseleave\"), this.text && this.text.destroy(), this.box && (this.box = this.box.destroy()), t.prototype.destroy.call(this);\n      }\n      fillSetter(t, e) {\n        t && (this.needsBox = !0), this.fill = t, this.boxAttr(e, t);\n      }\n      getBBox() {\n        this.textStr && 0 === this.bBox.width && 0 === this.bBox.height && this.updateBoxSize();\n        let t = this.padding,\n          e = n(this.paddingLeft, t);\n        return {\n          width: this.width || 0,\n          height: this.height || 0,\n          x: this.bBox.x - e,\n          y: this.bBox.y - t\n        };\n      }\n      getCrispAdjust() {\n        return this.renderer.styledMode && this.box ? this.box.strokeWidth() % 2 / 2 : (this[\"stroke-width\"] ? parseInt(this[\"stroke-width\"], 10) : 0) % 2 / 2;\n      }\n      heightSetter(t) {\n        this.heightSetting = t;\n      }\n      onAdd() {\n        this.text.add(this), this.attr({\n          text: n(this.textStr, \"\"),\n          x: this.x || 0,\n          y: this.y || 0\n        }), this.box && i(this.anchorX) && this.attr({\n          anchorX: this.anchorX,\n          anchorY: this.anchorY\n        });\n      }\n      paddingSetter(t, e) {\n        o(t) ? t !== this[e] && (this[e] = t, this.updateTextPadding()) : this[e] = void 0;\n      }\n      rSetter(t, e) {\n        this.boxAttr(e, t);\n      }\n      strokeSetter(t, e) {\n        this.stroke = t, this.boxAttr(e, t);\n      }\n      \"stroke-widthSetter\"(t, e) {\n        t && (this.needsBox = !0), this[\"stroke-width\"] = t, this.boxAttr(e, t);\n      }\n      \"text-alignSetter\"(t) {\n        this.textAlign = t;\n      }\n      textSetter(t) {\n        void 0 !== t && this.text.attr({\n          text: t\n        }), this.updateTextPadding();\n      }\n      updateBoxSize() {\n        let t;\n        let e = this.text,\n          r = {},\n          n = this.padding,\n          a = this.bBox = (!o(this.widthSetting) || !o(this.heightSetting) || this.textAlign) && i(e.textStr) ? e.getBBox() : h.emptyBBox;\n        this.width = this.getPaddedWidth(), this.height = (this.heightSetting || a.height || 0) + 2 * n;\n        let l = this.renderer.fontMetrics(e);\n        if (this.baselineOffset = n + Math.min((this.text.firstLineMetrics || l).b, a.height || 1 / 0), this.heightSetting && (this.baselineOffset += (this.heightSetting - l.h) / 2), this.needsBox && !e.textPath) {\n          if (!this.box) {\n            let t = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect();\n            t.addClass((\"button\" === this.className ? \"\" : \"highcharts-label-box\") + (this.className ? \" highcharts-\" + this.className + \"-box\" : \"\")), t.add(this);\n          }\n          t = this.getCrispAdjust(), r.x = t, r.y = (this.baseline ? -this.baselineOffset : 0) + t, r.width = Math.round(this.width), r.height = Math.round(this.height), this.box.attr(s(r, this.deferredAttr)), this.deferredAttr = {};\n        }\n      }\n      updateTextPadding() {\n        let t = this.text;\n        if (!t.textPath) {\n          this.updateBoxSize();\n          let e = this.baseline ? 0 : this.baselineOffset,\n            s = n(this.paddingLeft, this.padding);\n          i(this.widthSetting) && this.bBox && (\"center\" === this.textAlign || \"right\" === this.textAlign) && (s += {\n            center: .5,\n            right: 1\n          }[this.textAlign] * (this.widthSetting - this.bBox.width)), (s !== t.x || e !== t.y) && (t.attr(\"x\", s), t.hasBoxWidthChanged && (this.bBox = t.getBBox(!0)), void 0 !== e && t.attr(\"y\", e)), t.x = s, t.y = e;\n        }\n      }\n      widthSetter(t) {\n        this.widthSetting = o(t) ? t : void 0;\n      }\n      getPaddedWidth() {\n        let t = this.padding,\n          e = n(this.paddingLeft, t),\n          i = n(this.paddingRight, t);\n        return (this.widthSetting || this.bBox.width || 0) + e + i;\n      }\n      xSetter(t) {\n        this.x = t, this.alignFactor && (t -= this.alignFactor * this.getPaddedWidth(), this[\"forceAnimate:x\"] = !0), this.xSetting = Math.round(t), this.attr(\"translateX\", this.xSetting);\n      }\n      ySetter(t) {\n        this.ySetting = this.y = Math.round(t), this.attr(\"translateY\", this.ySetting);\n      }\n    }\n    return h.emptyBBox = {\n      width: 0,\n      height: 0,\n      x: 0,\n      y: 0\n    }, h.textProps = [\"color\", \"direction\", \"fontFamily\", \"fontSize\", \"fontStyle\", \"fontWeight\", \"lineHeight\", \"textAlign\", \"textDecoration\", \"textOutline\", \"textOverflow\", \"whiteSpace\", \"width\"], h;\n  }), i(e, \"Core/Renderer/SVG/Symbols.js\", [e[\"Core/Utilities.js\"]], function (t) {\n    let {\n      defined: e,\n      isNumber: i,\n      pick: s\n    } = t;\n    function o(t, i, o, r, n) {\n      let a = [];\n      if (n) {\n        let h = n.start || 0,\n          l = s(n.r, o),\n          d = s(n.r, r || o),\n          c = .001 > Math.abs((n.end || 0) - h - 2 * Math.PI),\n          p = (n.end || 0) - .001,\n          u = n.innerR,\n          g = s(n.open, c),\n          f = Math.cos(h),\n          m = Math.sin(h),\n          x = Math.cos(p),\n          y = Math.sin(p),\n          b = s(n.longArc, p - h - Math.PI < .001 ? 0 : 1),\n          v = [\"A\", l, d, 0, b, s(n.clockwise, 1), t + l * x, i + d * y];\n        v.params = {\n          start: h,\n          end: p,\n          cx: t,\n          cy: i\n        }, a.push([\"M\", t + l * f, i + d * m], v), e(u) && ((v = [\"A\", u, u, 0, b, e(n.clockwise) ? 1 - n.clockwise : 0, t + u * f, i + u * m]).params = {\n          start: p,\n          end: h,\n          cx: t,\n          cy: i\n        }, a.push(g ? [\"M\", t + u * x, i + u * y] : [\"L\", t + u * x, i + u * y], v)), g || a.push([\"Z\"]);\n      }\n      return a;\n    }\n    function r(t, e, i, s, o) {\n      return o && o.r ? n(t, e, i, s, o) : [[\"M\", t, e], [\"L\", t + i, e], [\"L\", t + i, e + s], [\"L\", t, e + s], [\"Z\"]];\n    }\n    function n(t, e, i, s, o) {\n      let r = o?.r || 0;\n      return [[\"M\", t + r, e], [\"L\", t + i - r, e], [\"A\", r, r, 0, 0, 1, t + i, e + r], [\"L\", t + i, e + s - r], [\"A\", r, r, 0, 0, 1, t + i - r, e + s], [\"L\", t + r, e + s], [\"A\", r, r, 0, 0, 1, t, e + s - r], [\"L\", t, e + r], [\"A\", r, r, 0, 0, 1, t + r, e], [\"Z\"]];\n    }\n    return {\n      arc: o,\n      callout: function (t, e, s, o, r) {\n        let a = Math.min(r && r.r || 0, s, o),\n          h = a + 6,\n          l = r && r.anchorX,\n          d = r && r.anchorY || 0,\n          c = n(t, e, s, o, {\n            r: a\n          });\n        if (!i(l) || l < s && l > 0 && d < o && d > 0) return c;\n        if (t + l > s - h) {\n          if (d > e + h && d < e + o - h) c.splice(3, 1, [\"L\", t + s, d - 6], [\"L\", t + s + 6, d], [\"L\", t + s, d + 6], [\"L\", t + s, e + o - a]);else if (l < s) {\n            let i = d < e + h,\n              r = i ? e : e + o;\n            c.splice(i ? 2 : 5, 0, [\"L\", l, d], [\"L\", t + s - a, r]);\n          } else c.splice(3, 1, [\"L\", t + s, o / 2], [\"L\", l, d], [\"L\", t + s, o / 2], [\"L\", t + s, e + o - a]);\n        } else if (t + l < h) {\n          if (d > e + h && d < e + o - h) c.splice(7, 1, [\"L\", t, d + 6], [\"L\", t - 6, d], [\"L\", t, d - 6], [\"L\", t, e + a]);else if (l > 0) {\n            let i = d < e + h,\n              s = i ? e : e + o;\n            c.splice(i ? 1 : 6, 0, [\"L\", l, d], [\"L\", t + a, s]);\n          } else c.splice(7, 1, [\"L\", t, o / 2], [\"L\", l, d], [\"L\", t, o / 2], [\"L\", t, e + a]);\n        } else d > o && l < s - h ? c.splice(5, 1, [\"L\", l + 6, e + o], [\"L\", l, e + o + 6], [\"L\", l - 6, e + o], [\"L\", t + a, e + o]) : d < 0 && l > h && c.splice(1, 1, [\"L\", l - 6, e], [\"L\", l, e - 6], [\"L\", l + 6, e], [\"L\", s - a, e]);\n        return c;\n      },\n      circle: function (t, e, i, s) {\n        return o(t + i / 2, e + s / 2, i / 2, s / 2, {\n          start: .5 * Math.PI,\n          end: 2.5 * Math.PI,\n          open: !1\n        });\n      },\n      diamond: function (t, e, i, s) {\n        return [[\"M\", t + i / 2, e], [\"L\", t + i, e + s / 2], [\"L\", t + i / 2, e + s], [\"L\", t, e + s / 2], [\"Z\"]];\n      },\n      rect: r,\n      roundedRect: n,\n      square: r,\n      triangle: function (t, e, i, s) {\n        return [[\"M\", t + i / 2, e], [\"L\", t + i, e + s], [\"L\", t, e + s], [\"Z\"]];\n      },\n      \"triangle-down\": function (t, e, i, s) {\n        return [[\"M\", t, e], [\"L\", t + i, e], [\"L\", t + i / 2, e + s], [\"Z\"]];\n      }\n    };\n  }), i(e, \"Core/Renderer/SVG/TextBuilder.js\", [e[\"Core/Renderer/HTML/AST.js\"], e[\"Core/Globals.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    let {\n        doc: s,\n        SVG_NS: o,\n        win: r\n      } = e,\n      {\n        attr: n,\n        extend: a,\n        fireEvent: h,\n        isString: l,\n        objectEach: d,\n        pick: c\n      } = i;\n    return class {\n      constructor(t) {\n        let e = t.styles;\n        this.renderer = t.renderer, this.svgElement = t, this.width = t.textWidth, this.textLineHeight = e && e.lineHeight, this.textOutline = e && e.textOutline, this.ellipsis = !!(e && \"ellipsis\" === e.textOverflow), this.noWrap = !!(e && \"nowrap\" === e.whiteSpace);\n      }\n      buildSVG() {\n        let e = this.svgElement,\n          i = e.element,\n          o = e.renderer,\n          r = c(e.textStr, \"\").toString(),\n          n = -1 !== r.indexOf(\"<\"),\n          a = i.childNodes,\n          h = !e.added && o.box,\n          d = [r, this.ellipsis, this.noWrap, this.textLineHeight, this.textOutline, e.getStyle(\"font-size\"), this.width].join(\",\");\n        if (d !== e.textCache) {\n          e.textCache = d, delete e.actualWidth;\n          for (let t = a.length; t--;) i.removeChild(a[t]);\n          if (n || this.ellipsis || this.width || e.textPath || -1 !== r.indexOf(\" \") && (!this.noWrap || /<br.*?>/g.test(r))) {\n            if (\"\" !== r) {\n              h && h.appendChild(i);\n              let s = new t(r);\n              this.modifyTree(s.nodes), s.addToDOM(i), this.modifyDOM(), this.ellipsis && -1 !== (i.textContent || \"\").indexOf(\"‚Ä¶\") && e.attr(\"title\", this.unescapeEntities(e.textStr || \"\", [\"&lt;\", \"&gt;\"])), h && h.removeChild(i);\n            }\n          } else i.appendChild(s.createTextNode(this.unescapeEntities(r)));\n          l(this.textOutline) && e.applyTextOutline && e.applyTextOutline(this.textOutline);\n        }\n      }\n      modifyDOM() {\n        let t;\n        let e = this.svgElement,\n          i = n(e.element, \"x\");\n        for (e.firstLineMetrics = void 0; t = e.element.firstChild;) if (/^[\\s\\u200B]*$/.test(t.textContent || \" \")) e.element.removeChild(t);else break;\n        [].forEach.call(e.element.querySelectorAll(\"tspan.highcharts-br\"), (t, s) => {\n          t.nextSibling && t.previousSibling && (0 === s && 1 === t.previousSibling.nodeType && (e.firstLineMetrics = e.renderer.fontMetrics(t.previousSibling)), n(t, {\n            dy: this.getLineHeight(t.nextSibling),\n            x: i\n          }));\n        });\n        let a = this.width || 0;\n        if (!a) return;\n        let h = (t, r) => {\n            let h = t.textContent || \"\",\n              l = h.replace(/([^\\^])-/g, \"$1- \").split(\" \"),\n              d = !this.noWrap && (l.length > 1 || e.element.childNodes.length > 1),\n              c = this.getLineHeight(r),\n              p = 0,\n              u = e.actualWidth;\n            if (this.ellipsis) h && this.truncate(t, h, void 0, 0, Math.max(0, a - .8 * c), (t, e) => t.substring(0, e) + \"‚Ä¶\");else if (d) {\n              let h = [],\n                d = [];\n              for (; r.firstChild && r.firstChild !== t;) d.push(r.firstChild), r.removeChild(r.firstChild);\n              for (; l.length;) l.length && !this.noWrap && p > 0 && (h.push(t.textContent || \"\"), t.textContent = l.join(\" \").replace(/- /g, \"-\")), this.truncate(t, void 0, l, 0 === p && u || 0, a, (t, e) => l.slice(0, e).join(\" \").replace(/- /g, \"-\")), u = e.actualWidth, p++;\n              d.forEach(e => {\n                r.insertBefore(e, t);\n              }), h.forEach(e => {\n                r.insertBefore(s.createTextNode(e), t);\n                let a = s.createElementNS(o, \"tspan\");\n                a.textContent = \"‚Äã\", n(a, {\n                  dy: c,\n                  x: i\n                }), r.insertBefore(a, t);\n              });\n            }\n          },\n          l = t => {\n            let i = [].slice.call(t.childNodes);\n            i.forEach(i => {\n              i.nodeType === r.Node.TEXT_NODE ? h(i, t) : (-1 !== i.className.baseVal.indexOf(\"highcharts-br\") && (e.actualWidth = 0), l(i));\n            });\n          };\n        l(e.element);\n      }\n      getLineHeight(t) {\n        let e = t.nodeType === r.Node.TEXT_NODE ? t.parentElement : t;\n        return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(e || this.svgElement.element).h;\n      }\n      modifyTree(t) {\n        let e = (i, s) => {\n          let {\n              attributes: o = {},\n              children: r,\n              style: n = {},\n              tagName: h\n            } = i,\n            l = this.renderer.styledMode;\n          if (\"b\" === h || \"strong\" === h ? l ? o.class = \"highcharts-strong\" : n.fontWeight = \"bold\" : (\"i\" === h || \"em\" === h) && (l ? o.class = \"highcharts-emphasized\" : n.fontStyle = \"italic\"), n && n.color && (n.fill = n.color), \"br\" === h) {\n            o.class = \"highcharts-br\", i.textContent = \"‚Äã\";\n            let e = t[s + 1];\n            e && e.textContent && (e.textContent = e.textContent.replace(/^ +/gm, \"\"));\n          } else \"a\" === h && r && r.some(t => \"#text\" === t.tagName) && (i.children = [{\n            children: r,\n            tagName: \"tspan\"\n          }]);\n          \"#text\" !== h && \"a\" !== h && (i.tagName = \"tspan\"), a(i, {\n            attributes: o,\n            style: n\n          }), r && r.filter(t => \"#text\" !== t.tagName).forEach(e);\n        };\n        t.forEach(e), h(this.svgElement, \"afterModifyTree\", {\n          nodes: t\n        });\n      }\n      truncate(t, e, i, s, o, r) {\n        let n, a;\n        let h = this.svgElement,\n          {\n            renderer: l,\n            rotation: d\n          } = h,\n          c = [],\n          p = i ? 1 : 0,\n          u = (e || i || \"\").length,\n          g = u,\n          f = function (e, o) {\n            let r = o || e,\n              n = t.parentNode;\n            if (n && void 0 === c[r] && n.getSubStringLength) try {\n              c[r] = s + n.getSubStringLength(0, i ? r + 1 : r);\n            } catch (t) {}\n            return c[r];\n          };\n        if (h.rotation = 0, s + (a = f(t.textContent.length)) > o) {\n          for (; p <= u;) g = Math.ceil((p + u) / 2), i && (n = r(i, g)), a = f(g, n && n.length - 1), p === u ? p = u + 1 : a > o ? u = g - 1 : p = g;\n          0 === u ? t.textContent = \"\" : e && u === e.length - 1 || (t.textContent = n || r(e || i, g));\n        }\n        i && i.splice(0, g), h.actualWidth = a, h.rotation = d;\n      }\n      unescapeEntities(t, e) {\n        return d(this.renderer.escapes, function (i, s) {\n          e && -1 !== e.indexOf(i) || (t = t.toString().replace(RegExp(i, \"g\"), s));\n        }), t;\n      }\n    };\n  }), i(e, \"Core/Renderer/SVG/SVGRenderer.js\", [e[\"Core/Renderer/HTML/AST.js\"], e[\"Core/Color/Color.js\"], e[\"Core/Globals.js\"], e[\"Core/Renderer/RendererRegistry.js\"], e[\"Core/Renderer/SVG/SVGElement.js\"], e[\"Core/Renderer/SVG/SVGLabel.js\"], e[\"Core/Renderer/SVG/Symbols.js\"], e[\"Core/Renderer/SVG/TextBuilder.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s, o, r, n, a, h) {\n    let l;\n    let {\n        charts: d,\n        deg2rad: c,\n        doc: p,\n        isFirefox: u,\n        isMS: g,\n        isWebKit: f,\n        noop: m,\n        SVG_NS: x,\n        symbolSizes: y,\n        win: b\n      } = i,\n      {\n        addEvent: v,\n        attr: k,\n        createElement: S,\n        css: M,\n        defined: C,\n        destroyObjectProperties: w,\n        extend: T,\n        isArray: A,\n        isNumber: P,\n        isObject: L,\n        isString: O,\n        merge: D,\n        pick: E,\n        pInt: I,\n        uniqueKey: B\n      } = h;\n    class j {\n      constructor(t, e, i, s, o, r, n) {\n        this.alignedObjects = void 0, this.box = void 0, this.boxWrapper = void 0, this.cache = void 0, this.cacheKeys = void 0, this.chartIndex = void 0, this.defs = void 0, this.globalAnimation = void 0, this.gradients = void 0, this.height = void 0, this.imgCount = void 0, this.style = void 0, this.url = void 0, this.width = void 0, this.init(t, e, i, s, o, r, n);\n      }\n      init(t, e, i, s, o, r, n) {\n        let a, h;\n        let l = this.createElement(\"svg\").attr({\n            version: \"1.1\",\n            class: \"highcharts-root\"\n          }),\n          d = l.element;\n        n || l.css(this.getStyle(s)), t.appendChild(d), k(t, \"dir\", \"ltr\"), -1 === t.innerHTML.indexOf(\"xmlns\") && k(d, \"xmlns\", this.SVG_NS), this.box = d, this.boxWrapper = l, this.alignedObjects = [], this.url = this.getReferenceURL();\n        let c = this.createElement(\"desc\").add();\n        c.element.appendChild(p.createTextNode(\"Created with Highcharts 11.2.0\")), this.defs = this.createElement(\"defs\").add(), this.allowHTML = r, this.forExport = o, this.styledMode = n, this.gradients = {}, this.cache = {}, this.cacheKeys = [], this.imgCount = 0, this.rootFontSize = l.getStyle(\"font-size\"), this.setSize(e, i, !1), u && t.getBoundingClientRect && ((a = function () {\n          M(t, {\n            left: 0,\n            top: 0\n          }), h = t.getBoundingClientRect(), M(t, {\n            left: Math.ceil(h.left) - h.left + \"px\",\n            top: Math.ceil(h.top) - h.top + \"px\"\n          });\n        })(), this.unSubPixelFix = v(b, \"resize\", a));\n      }\n      definition(e) {\n        let i = new t([e]);\n        return i.addToDOM(this.defs.element);\n      }\n      getReferenceURL() {\n        if ((u || f) && p.getElementsByTagName(\"base\").length) {\n          if (!C(l)) {\n            let e = B(),\n              i = new t([{\n                tagName: \"svg\",\n                attributes: {\n                  width: 8,\n                  height: 8\n                },\n                children: [{\n                  tagName: \"defs\",\n                  children: [{\n                    tagName: \"clipPath\",\n                    attributes: {\n                      id: e\n                    },\n                    children: [{\n                      tagName: \"rect\",\n                      attributes: {\n                        width: 4,\n                        height: 4\n                      }\n                    }]\n                  }]\n                }, {\n                  tagName: \"rect\",\n                  attributes: {\n                    id: \"hitme\",\n                    width: 8,\n                    height: 8,\n                    \"clip-path\": `url(#${e})`,\n                    fill: \"rgba(0,0,0,0.001)\"\n                  }\n                }]\n              }]),\n              s = i.addToDOM(p.body);\n            M(s, {\n              position: \"fixed\",\n              top: 0,\n              left: 0,\n              zIndex: 9e5\n            });\n            let o = p.elementFromPoint(6, 6);\n            l = \"hitme\" === (o && o.id), p.body.removeChild(s);\n          }\n          if (l) return b.location.href.split(\"#\")[0].replace(/<[^>]*>/g, \"\").replace(/([\\('\\)])/g, \"\\\\$1\").replace(/ /g, \"%20\");\n        }\n        return \"\";\n      }\n      getStyle(t) {\n        return this.style = T({\n          fontFamily: \"Helvetica, Arial, sans-serif\",\n          fontSize: \"1rem\"\n        }, t), this.style;\n      }\n      setStyle(t) {\n        this.boxWrapper.css(this.getStyle(t));\n      }\n      isHidden() {\n        return !this.boxWrapper.getBBox().width;\n      }\n      destroy() {\n        let t = this.defs;\n        return this.box = null, this.boxWrapper = this.boxWrapper.destroy(), w(this.gradients || {}), this.gradients = null, this.defs = t.destroy(), this.unSubPixelFix && this.unSubPixelFix(), this.alignedObjects = null, null;\n      }\n      createElement(t) {\n        let e = new this.Element();\n        return e.init(this, t), e;\n      }\n      getRadialAttr(t, e) {\n        return {\n          cx: t[0] - t[2] / 2 + (e.cx || 0) * t[2],\n          cy: t[1] - t[2] / 2 + (e.cy || 0) * t[2],\n          r: (e.r || 0) * t[2]\n        };\n      }\n      shadowDefinition(t) {\n        let e = [`highcharts-drop-shadow-${this.chartIndex}`, ...Object.keys(t).map(e => `${e}-${t[e]}`)].join(\"-\").toLowerCase().replace(/[^a-z0-9\\-]/g, \"\"),\n          i = D({\n            color: \"#000000\",\n            offsetX: 1,\n            offsetY: 1,\n            opacity: .15,\n            width: 5\n          }, t);\n        return this.defs.element.querySelector(`#${e}`) || this.definition({\n          tagName: \"filter\",\n          attributes: {\n            id: e,\n            filterUnits: i.filterUnits\n          },\n          children: [{\n            tagName: \"feDropShadow\",\n            attributes: {\n              dx: i.offsetX,\n              dy: i.offsetY,\n              \"flood-color\": i.color,\n              \"flood-opacity\": Math.min(5 * i.opacity, 1),\n              stdDeviation: i.width / 2\n            }\n          }]\n        }), e;\n      }\n      buildText(t) {\n        new a(t).buildSVG();\n      }\n      getContrast(t) {\n        let i = e.parse(t).rgba.map(t => {\n            let e = t / 255;\n            return e <= .03928 ? e / 12.92 : Math.pow((e + .055) / 1.055, 2.4);\n          }),\n          s = .2126 * i[0] + .7152 * i[1] + .0722 * i[2];\n        return 1.05 / (s + .05) > (s + .05) / .05 ? \"#FFFFFF\" : \"#000000\";\n      }\n      button(e, i, s, o, r = {}, n, a, h, l, d) {\n        let c, p, u;\n        let f = this.label(e, i, s, l, void 0, void 0, d, void 0, \"button\"),\n          m = this.styledMode,\n          x = r.states || {},\n          y = 0;\n        r = D(r), delete r.states;\n        let b = D({\n          color: \"#333333\",\n          cursor: \"pointer\",\n          fontSize: \"0.8em\",\n          fontWeight: \"normal\"\n        }, r.style);\n        delete r.style;\n        let k = t.filterUserAttributes(r);\n        return f.attr(D({\n          padding: 8,\n          r: 2\n        }, k)), m || (k = D({\n          fill: \"#f7f7f7\",\n          stroke: \"#cccccc\",\n          \"stroke-width\": 1\n        }, k), c = (n = D(k, {\n          fill: \"#e6e6e6\"\n        }, t.filterUserAttributes(n || x.hover || {}))).style, delete n.style, p = (a = D(k, {\n          fill: \"#e6e9ff\",\n          style: {\n            color: \"#000000\",\n            fontWeight: \"bold\"\n          }\n        }, t.filterUserAttributes(a || x.select || {}))).style, delete a.style, u = (h = D(k, {\n          style: {\n            color: \"#cccccc\"\n          }\n        }, t.filterUserAttributes(h || x.disabled || {}))).style, delete h.style), v(f.element, g ? \"mouseover\" : \"mouseenter\", function () {\n          3 !== y && f.setState(1);\n        }), v(f.element, g ? \"mouseout\" : \"mouseleave\", function () {\n          3 !== y && f.setState(y);\n        }), f.setState = function (t) {\n          if (1 !== t && (f.state = y = t), f.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass(\"highcharts-button-\" + [\"normal\", \"hover\", \"pressed\", \"disabled\"][t || 0]), !m) {\n            f.attr([k, n, a, h][t || 0]);\n            let e = [b, c, p, u][t || 0];\n            L(e) && f.css(e);\n          }\n        }, !m && (f.attr(k).css(T({\n          cursor: \"default\"\n        }, b)), d && f.text.css({\n          pointerEvents: \"none\"\n        })), f.on(\"touchstart\", t => t.stopPropagation()).on(\"click\", function (t) {\n          3 !== y && o.call(f, t);\n        });\n      }\n      crispLine(t, e, i = \"round\") {\n        let s = t[0],\n          o = t[1];\n        return C(s[1]) && s[1] === o[1] && (s[1] = o[1] = Math[i](s[1]) - e % 2 / 2), C(s[2]) && s[2] === o[2] && (s[2] = o[2] = Math[i](s[2]) + e % 2 / 2), t;\n      }\n      path(t) {\n        let e = this.styledMode ? {} : {\n          fill: \"none\"\n        };\n        return A(t) ? e.d = t : L(t) && T(e, t), this.createElement(\"path\").attr(e);\n      }\n      circle(t, e, i) {\n        let s = L(t) ? t : void 0 === t ? {} : {\n            x: t,\n            y: e,\n            r: i\n          },\n          o = this.createElement(\"circle\");\n        return o.xSetter = o.ySetter = function (t, e, i) {\n          i.setAttribute(\"c\" + e, t);\n        }, o.attr(s);\n      }\n      arc(t, e, i, s, o, r) {\n        let n;\n        L(t) ? (e = (n = t).y, i = n.r, s = n.innerR, o = n.start, r = n.end, t = n.x) : n = {\n          innerR: s,\n          start: o,\n          end: r\n        };\n        let a = this.symbol(\"arc\", t, e, i, i, n);\n        return a.r = i, a;\n      }\n      rect(t, e, i, s, o, r) {\n        let n = L(t) ? t : void 0 === t ? {} : {\n            x: t,\n            y: e,\n            r: o,\n            width: Math.max(i || 0, 0),\n            height: Math.max(s || 0, 0)\n          },\n          a = this.createElement(\"rect\");\n        return this.styledMode || (void 0 !== r && (n[\"stroke-width\"] = r, T(n, a.crisp(n))), n.fill = \"none\"), a.rSetter = function (t, e, i) {\n          a.r = t, k(i, {\n            rx: t,\n            ry: t\n          });\n        }, a.rGetter = function () {\n          return a.r || 0;\n        }, a.attr(n);\n      }\n      roundedRect(t) {\n        return this.symbol(\"roundedRect\").attr(t);\n      }\n      setSize(t, e, i) {\n        this.width = t, this.height = e, this.boxWrapper.animate({\n          width: t,\n          height: e\n        }, {\n          step: function () {\n            this.attr({\n              viewBox: \"0 0 \" + this.attr(\"width\") + \" \" + this.attr(\"height\")\n            });\n          },\n          duration: E(i, !0) ? void 0 : 0\n        }), this.alignElements();\n      }\n      g(t) {\n        let e = this.createElement(\"g\");\n        return t ? e.attr({\n          class: \"highcharts-\" + t\n        }) : e;\n      }\n      image(t, e, i, s, o, r) {\n        let n = {\n          preserveAspectRatio: \"none\"\n        };\n        P(e) && (n.x = e), P(i) && (n.y = i), P(s) && (n.width = s), P(o) && (n.height = o);\n        let a = this.createElement(\"image\").attr(n),\n          h = function (e) {\n            a.attr({\n              href: t\n            }), r.call(a, e);\n          };\n        if (r) {\n          a.attr({\n            href: \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"\n          });\n          let e = new b.Image();\n          v(e, \"load\", h), e.src = t, e.complete && h({});\n        } else a.attr({\n          href: t\n        });\n        return a;\n      }\n      symbol(t, e, i, s, o, r) {\n        let n, a, h, l;\n        let c = this,\n          u = /^url\\((.*?)\\)$/,\n          g = u.test(t),\n          f = !g && (this.symbols[t] ? t : \"circle\"),\n          m = f && this.symbols[f];\n        if (m) \"number\" == typeof e && (a = m.call(this.symbols, Math.round(e || 0), Math.round(i || 0), s || 0, o || 0, r)), n = this.path(a), c.styledMode || n.attr(\"fill\", \"none\"), T(n, {\n          symbolName: f || void 0,\n          x: e,\n          y: i,\n          width: s,\n          height: o\n        }), r && T(n, r);else if (g) {\n          h = t.match(u)[1];\n          let s = n = this.image(h);\n          s.imgwidth = E(r && r.width, y[h] && y[h].width), s.imgheight = E(r && r.height, y[h] && y[h].height), l = t => t.attr({\n            width: t.width,\n            height: t.height\n          }), [\"width\", \"height\"].forEach(t => {\n            s[`${t}Setter`] = function (t, e) {\n              this[e] = t;\n              let {\n                  alignByTranslate: i,\n                  element: s,\n                  width: o,\n                  height: n,\n                  imgwidth: a,\n                  imgheight: h\n                } = this,\n                l = \"width\" === e ? a : h,\n                d = 1;\n              r && \"within\" === r.backgroundSize && o && n && a && h ? (d = Math.min(o / a, n / h), k(s, {\n                width: Math.round(a * d),\n                height: Math.round(h * d)\n              })) : s && l && s.setAttribute(e, l), !i && a && h && this.translate(((o || 0) - a * d) / 2, ((n || 0) - h * d) / 2);\n            };\n          }), C(e) && s.attr({\n            x: e,\n            y: i\n          }), s.isImg = !0, C(s.imgwidth) && C(s.imgheight) ? l(s) : (s.attr({\n            width: 0,\n            height: 0\n          }), S(\"img\", {\n            onload: function () {\n              let t = d[c.chartIndex];\n              0 === this.width && (M(this, {\n                position: \"absolute\",\n                top: \"-999em\"\n              }), p.body.appendChild(this)), y[h] = {\n                width: this.width,\n                height: this.height\n              }, s.imgwidth = this.width, s.imgheight = this.height, s.element && l(s), this.parentNode && this.parentNode.removeChild(this), c.imgCount--, c.imgCount || !t || t.hasLoaded || t.onload();\n            },\n            src: h\n          }), this.imgCount++);\n        }\n        return n;\n      }\n      clipRect(t, e, i, s) {\n        let o = B() + \"-\",\n          r = this.createElement(\"clipPath\").attr({\n            id: o\n          }).add(this.defs),\n          n = this.rect(t, e, i, s, 0).add(r);\n        return n.id = o, n.clipPath = r, n.count = 0, n;\n      }\n      text(t, e, i, s) {\n        let o = {};\n        if (s && (this.allowHTML || !this.forExport)) return this.html(t, e, i);\n        o.x = Math.round(e || 0), i && (o.y = Math.round(i)), C(t) && (o.text = t);\n        let r = this.createElement(\"text\").attr(o);\n        return s && (!this.forExport || this.allowHTML) || (r.xSetter = function (t, e, i) {\n          let s = i.getElementsByTagName(\"tspan\"),\n            o = i.getAttribute(e);\n          for (let i = 0, r; i < s.length; i++) (r = s[i]).getAttribute(e) === o && r.setAttribute(e, t);\n          i.setAttribute(e, t);\n        }), r;\n      }\n      fontMetrics(t) {\n        let e = I(o.prototype.getStyle.call(t, \"font-size\") || 0),\n          i = e < 24 ? e + 3 : Math.round(1.2 * e),\n          s = Math.round(.8 * i);\n        return {\n          h: i,\n          b: s,\n          f: e\n        };\n      }\n      rotCorr(t, e, i) {\n        let s = t;\n        return e && i && (s = Math.max(s * Math.cos(e * c), 4)), {\n          x: -t / 3 * Math.sin(e * c),\n          y: s\n        };\n      }\n      pathToSegments(t) {\n        let e = [],\n          i = [],\n          s = {\n            A: 8,\n            C: 7,\n            H: 2,\n            L: 3,\n            M: 3,\n            Q: 5,\n            S: 5,\n            T: 3,\n            V: 2\n          };\n        for (let o = 0; o < t.length; o++) O(i[0]) && P(t[o]) && i.length === s[i[0].toUpperCase()] && t.splice(o, 0, i[0].replace(\"M\", \"L\").replace(\"m\", \"l\")), \"string\" == typeof t[o] && (i.length && e.push(i.slice(0)), i.length = 0), i.push(t[o]);\n        return e.push(i.slice(0)), e;\n      }\n      label(t, e, i, s, o, n, a, h, l) {\n        return new r(this, t, e, i, s, o, n, a, h, l);\n      }\n      alignElements() {\n        this.alignedObjects.forEach(t => t.align());\n      }\n    }\n    return T(j.prototype, {\n      Element: o,\n      SVG_NS: x,\n      escapes: {\n        \"&\": \"&amp;\",\n        \"<\": \"&lt;\",\n        \">\": \"&gt;\",\n        \"'\": \"&#39;\",\n        '\"': \"&quot;\"\n      },\n      symbols: n,\n      draw: m\n    }), s.registerRendererType(\"svg\", j, !0), j;\n  }), i(e, \"Core/Renderer/HTML/HTMLElement.js\", [e[\"Core/Globals.js\"], e[\"Core/Renderer/SVG/SVGElement.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    let {\n        isFirefox: s,\n        isMS: o,\n        isWebKit: r,\n        win: n\n      } = t,\n      {\n        css: a,\n        defined: h,\n        extend: l,\n        pick: d,\n        pInt: c\n      } = i,\n      p = [];\n    class u extends e {\n      static compose(t) {\n        if (i.pushUnique(p, t)) {\n          let e = u.prototype,\n            i = t.prototype;\n          i.getSpanCorrection = e.getSpanCorrection, i.htmlCss = e.htmlCss, i.htmlGetBBox = e.htmlGetBBox, i.htmlUpdateTransform = e.htmlUpdateTransform, i.setSpanRotation = e.setSpanRotation;\n        }\n        return t;\n      }\n      getSpanCorrection(t, e, i) {\n        this.xCorr = -t * i, this.yCorr = -e;\n      }\n      htmlCss(t) {\n        let e;\n        let i = this.element,\n          s = \"SPAN\" === i.tagName && t && \"width\" in t,\n          o = d(s && t.width, void 0);\n        return s && (delete t.width, this.textWidth = o, e = !0), t && \"ellipsis\" === t.textOverflow && (t.whiteSpace = \"nowrap\", t.overflow = \"hidden\"), this.styles = l(this.styles, t), a(this.element, t), e && this.htmlUpdateTransform(), this;\n      }\n      htmlGetBBox() {\n        let t = this.element;\n        return {\n          x: t.offsetLeft,\n          y: t.offsetTop,\n          width: t.offsetWidth,\n          height: t.offsetHeight\n        };\n      }\n      htmlUpdateTransform() {\n        if (!this.added) {\n          this.alignOnAdd = !0;\n          return;\n        }\n        let t = this.renderer,\n          e = this.element,\n          i = this.translateX || 0,\n          s = this.translateY || 0,\n          o = this.x || 0,\n          r = this.y || 0,\n          n = this.textAlign || \"left\",\n          l = {\n            left: 0,\n            center: .5,\n            right: 1\n          }[n],\n          d = this.styles,\n          p = d && d.whiteSpace;\n        if (a(e, {\n          marginLeft: i,\n          marginTop: s\n        }), \"SPAN\" === e.tagName) {\n          let i = this.rotation,\n            s = this.textWidth && c(this.textWidth),\n            d = [i, n, e.innerHTML, this.textWidth, this.textAlign].join(\",\"),\n            u,\n            g = !1;\n          if (s !== this.oldTextWidth) {\n            let t = this.textPxLength ? this.textPxLength : (a(e, {\n              width: \"\",\n              whiteSpace: p || \"nowrap\"\n            }), e.offsetWidth);\n            (s > this.oldTextWidth || t > s) && (/[ \\-]/.test(e.textContent || e.innerText) || \"ellipsis\" === e.style.textOverflow) && (a(e, {\n              width: t > s || i ? s + \"px\" : \"auto\",\n              display: \"block\",\n              whiteSpace: p || \"normal\"\n            }), this.oldTextWidth = s, g = !0);\n          }\n          this.hasBoxWidthChanged = g, d !== this.cTT && (u = t.fontMetrics(e).b, h(i) && (i !== (this.oldRotation || 0) || n !== this.oldAlign) && this.setSpanRotation(i, l, u), this.getSpanCorrection(!h(i) && this.textPxLength || e.offsetWidth, u, l, i, n)), a(e, {\n            left: o + (this.xCorr || 0) + \"px\",\n            top: r + (this.yCorr || 0) + \"px\"\n          }), this.cTT = d, this.oldRotation = i, this.oldAlign = n;\n        }\n      }\n      setSpanRotation(t, e, i) {\n        let h = {},\n          l = o && !/Edge/.test(n.navigator.userAgent) ? \"-ms-transform\" : r ? \"-webkit-transform\" : s ? \"MozTransform\" : n.opera ? \"-o-transform\" : void 0;\n        l && (h[l] = h.transform = \"rotate(\" + t + \"deg)\", h[l + (s ? \"Origin\" : \"-origin\")] = h.transformOrigin = 100 * e + \"% \" + i + \"px\", a(this.element, h));\n      }\n    }\n    return u;\n  }), i(e, \"Core/Renderer/HTML/HTMLRenderer.js\", [e[\"Core/Renderer/HTML/AST.js\"], e[\"Core/Renderer/SVG/SVGElement.js\"], e[\"Core/Renderer/SVG/SVGRenderer.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s) {\n    let {\n        attr: o,\n        createElement: r,\n        extend: n,\n        pick: a\n      } = s,\n      h = [];\n    class l extends i {\n      static compose(t) {\n        if (s.pushUnique(h, t)) {\n          let e = l.prototype,\n            i = t.prototype;\n          i.html = e.html;\n        }\n        return t;\n      }\n      html(i, s, h) {\n        let l = this.createElement(\"span\"),\n          d = l.element,\n          c = l.renderer,\n          p = function (t, i) {\n            [\"opacity\", \"visibility\"].forEach(function (s) {\n              t[s + \"Setter\"] = function (o, r, n) {\n                let a = t.div ? t.div.style : i;\n                e.prototype[s + \"Setter\"].call(this, o, r, n), a && (a[r] = o);\n              };\n            }), t.addedSetters = !0;\n          };\n        return l.textSetter = function (e) {\n          e !== this.textStr && (delete this.bBox, delete this.oldTextWidth, t.setElementHTML(this.element, a(e, \"\")), this.textStr = e, l.doTransform = !0);\n        }, p(l, l.element.style), l.xSetter = l.ySetter = l.alignSetter = l.rotationSetter = function (t, e) {\n          \"align\" === e ? l.alignValue = l.textAlign = t : l[e] = t, l.doTransform = !0;\n        }, l.afterSetters = function () {\n          this.doTransform && (this.htmlUpdateTransform(), this.doTransform = !1);\n        }, l.attr({\n          text: i,\n          x: Math.round(s),\n          y: Math.round(h)\n        }).css({\n          position: \"absolute\"\n        }), c.styledMode || l.css({\n          fontFamily: this.style.fontFamily,\n          fontSize: this.style.fontSize\n        }), d.style.whiteSpace = \"nowrap\", l.css = l.htmlCss, l.add = function (t) {\n          let e, i;\n          let s = c.box.parentNode,\n            a = [];\n          if (this.parentGroup = t, t) {\n            if (!(e = t.div)) {\n              for (i = t; i;) a.push(i), i = i.parentGroup;\n              a.reverse().forEach(function (t) {\n                var i;\n                let h = o(t.element, \"class\"),\n                  d = t.css;\n                function c(e, i) {\n                  t[i] = e, \"translateX\" === i ? g.left = e + \"px\" : g.top = e + \"px\", t.doTransform = !0;\n                }\n                let u = t.styles || {};\n                e = t.div = t.div || r(\"div\", h ? {\n                  className: h\n                } : void 0, {\n                  position: \"absolute\",\n                  left: (t.translateX || 0) + \"px\",\n                  top: (t.translateY || 0) + \"px\",\n                  display: t.display,\n                  opacity: t.opacity,\n                  visibility: t.visibility\n                }, e || s);\n                let g = e.style;\n                n(t, {\n                  classSetter: (i = e, function (t) {\n                    this.element.setAttribute(\"class\", t), i.className = t;\n                  }),\n                  css: function (e) {\n                    return d.call(t, e), [\"cursor\", \"pointerEvents\"].forEach(t => {\n                      e[t] && (g[t] = e[t]);\n                    }), t;\n                  },\n                  on: function () {\n                    return a[0].div && l.on.apply({\n                      element: a[0].div,\n                      onEvents: t.onEvents\n                    }, arguments), t;\n                  },\n                  translateXSetter: c,\n                  translateYSetter: c\n                }), t.addedSetters || p(t), t.css(u);\n              });\n            }\n          } else e = s;\n          return e.appendChild(d), l.added = !0, l.alignOnAdd && l.htmlUpdateTransform(), l;\n        }, l;\n      }\n    }\n    return l;\n  }), i(e, \"Core/Axis/AxisDefaults.js\", [], function () {\n    var t, e;\n    return (e = t || (t = {})).defaultXAxisOptions = {\n      alignTicks: !0,\n      allowDecimals: void 0,\n      panningEnabled: !0,\n      zIndex: 2,\n      zoomEnabled: !0,\n      dateTimeLabelFormats: {\n        millisecond: {\n          main: \"%H:%M:%S.%L\",\n          range: !1\n        },\n        second: {\n          main: \"%H:%M:%S\",\n          range: !1\n        },\n        minute: {\n          main: \"%H:%M\",\n          range: !1\n        },\n        hour: {\n          main: \"%H:%M\",\n          range: !1\n        },\n        day: {\n          main: \"%e %b\"\n        },\n        week: {\n          main: \"%e %b\"\n        },\n        month: {\n          main: \"%b '%y\"\n        },\n        year: {\n          main: \"%Y\"\n        }\n      },\n      endOnTick: !1,\n      gridLineDashStyle: \"Solid\",\n      gridZIndex: 1,\n      labels: {\n        autoRotation: void 0,\n        autoRotationLimit: 80,\n        distance: 15,\n        enabled: !0,\n        indentation: 10,\n        overflow: \"justify\",\n        padding: 5,\n        reserveSpace: void 0,\n        rotation: void 0,\n        staggerLines: 0,\n        step: 0,\n        useHTML: !1,\n        zIndex: 7,\n        style: {\n          color: \"#333333\",\n          cursor: \"default\",\n          fontSize: \"0.8em\"\n        }\n      },\n      maxPadding: .01,\n      minorGridLineDashStyle: \"Solid\",\n      minorTickLength: 2,\n      minorTickPosition: \"outside\",\n      minorTicksPerMajor: 5,\n      minPadding: .01,\n      offset: void 0,\n      opposite: !1,\n      reversed: void 0,\n      reversedStacks: !1,\n      showEmpty: !0,\n      showFirstLabel: !0,\n      showLastLabel: !0,\n      startOfWeek: 1,\n      startOnTick: !1,\n      tickLength: 10,\n      tickPixelInterval: 100,\n      tickmarkPlacement: \"between\",\n      tickPosition: \"outside\",\n      title: {\n        align: \"middle\",\n        rotation: 0,\n        useHTML: !1,\n        x: 0,\n        y: 0,\n        style: {\n          color: \"#666666\",\n          fontSize: \"0.8em\"\n        }\n      },\n      type: \"linear\",\n      uniqueNames: !0,\n      visible: !0,\n      minorGridLineColor: \"#f2f2f2\",\n      minorGridLineWidth: 1,\n      minorTickColor: \"#999999\",\n      lineColor: \"#333333\",\n      lineWidth: 1,\n      gridLineColor: \"#e6e6e6\",\n      gridLineWidth: void 0,\n      tickColor: \"#333333\"\n    }, e.defaultYAxisOptions = {\n      reversedStacks: !0,\n      endOnTick: !0,\n      maxPadding: .05,\n      minPadding: .05,\n      tickPixelInterval: 72,\n      showLastLabel: !0,\n      labels: {\n        x: void 0\n      },\n      startOnTick: !0,\n      title: {\n        rotation: 270,\n        text: \"Values\"\n      },\n      stackLabels: {\n        animation: {},\n        allowOverlap: !1,\n        enabled: !1,\n        crop: !0,\n        overflow: \"justify\",\n        formatter: function () {\n          let {\n            numberFormatter: t\n          } = this.axis.chart;\n          return t(this.total || 0, -1);\n        },\n        style: {\n          color: \"#000000\",\n          fontSize: \"0.7em\",\n          fontWeight: \"bold\",\n          textOutline: \"1px contrast\"\n        }\n      },\n      gridLineWidth: 1,\n      lineWidth: 0\n    }, e.defaultLeftAxisOptions = {\n      title: {\n        rotation: 270\n      }\n    }, e.defaultRightAxisOptions = {\n      title: {\n        rotation: 90\n      }\n    }, e.defaultBottomAxisOptions = {\n      labels: {\n        autoRotation: [-45]\n      },\n      margin: 15,\n      title: {\n        rotation: 0\n      }\n    }, e.defaultTopAxisOptions = {\n      labels: {\n        autoRotation: [-45]\n      },\n      margin: 15,\n      title: {\n        rotation: 0\n      }\n    }, t;\n  }), i(e, \"Core/Foundation.js\", [e[\"Core/Utilities.js\"]], function (t) {\n    var e;\n    let {\n      addEvent: i,\n      isFunction: s,\n      objectEach: o,\n      removeEvent: r\n    } = t;\n    return (e || (e = {})).registerEventOptions = function (t, e) {\n      t.eventOptions = t.eventOptions || {}, o(e.events, function (e, o) {\n        t.eventOptions[o] !== e && (t.eventOptions[o] && (r(t, o, t.eventOptions[o]), delete t.eventOptions[o]), s(e) && (t.eventOptions[o] = e, i(t, o, e, {\n          order: 0\n        })));\n      });\n    }, e;\n  }), i(e, \"Core/Axis/Tick.js\", [e[\"Core/Templating.js\"], e[\"Core/Globals.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    let {\n        deg2rad: s\n      } = e,\n      {\n        clamp: o,\n        correctFloat: r,\n        defined: n,\n        destroyObjectProperties: a,\n        extend: h,\n        fireEvent: l,\n        isNumber: d,\n        merge: c,\n        objectEach: p,\n        pick: u\n      } = i;\n    return class {\n      constructor(t, e, i, s, o) {\n        this.isNew = !0, this.isNewLabel = !0, this.axis = t, this.pos = e, this.type = i || \"\", this.parameters = o || {}, this.tickmarkOffset = this.parameters.tickmarkOffset, this.options = this.parameters.options, l(this, \"init\"), i || s || this.addLabel();\n      }\n      addLabel() {\n        let e = this,\n          i = e.axis,\n          s = i.options,\n          o = i.chart,\n          a = i.categories,\n          c = i.logarithmic,\n          p = i.names,\n          g = e.pos,\n          f = u(e.options && e.options.labels, s.labels),\n          m = i.tickPositions,\n          x = g === m[0],\n          y = g === m[m.length - 1],\n          b = (!f.step || 1 === f.step) && 1 === i.tickInterval,\n          v = m.info,\n          k = e.label,\n          S,\n          M,\n          C,\n          w = this.parameters.category || (a ? u(a[g], p[g], g) : g);\n        c && d(w) && (w = r(c.lin2log(w))), i.dateTime && (v ? S = (M = o.time.resolveDTLFormat(s.dateTimeLabelFormats[!s.grid && v.higherRanks[g] || v.unitName])).main : d(w) && (S = i.dateTime.getXDateFormat(w, s.dateTimeLabelFormats || {}))), e.isFirst = x, e.isLast = y;\n        let T = {\n          axis: i,\n          chart: o,\n          dateTimeLabelFormat: S,\n          isFirst: x,\n          isLast: y,\n          pos: g,\n          tick: e,\n          tickPositionInfo: v,\n          value: w\n        };\n        l(this, \"labelFormat\", T);\n        let A = e => f.formatter ? f.formatter.call(e, e) : f.format ? (e.text = i.defaultLabelFormatter.call(e, e), t.format(f.format, e, o)) : i.defaultLabelFormatter.call(e, e),\n          P = A.call(T, T),\n          L = M && M.list;\n        L ? e.shortenLabel = function () {\n          for (C = 0; C < L.length; C++) if (h(T, {\n            dateTimeLabelFormat: L[C]\n          }), k.attr({\n            text: A.call(T, T)\n          }), k.getBBox().width < i.getSlotWidth(e) - 2 * f.padding) return;\n          k.attr({\n            text: \"\"\n          });\n        } : e.shortenLabel = void 0, b && i._addedPlotLB && e.moveLabel(P, f), n(k) || e.movedLabel ? k && k.textStr !== P && !b && (!k.textWidth || f.style.width || k.styles.width || k.css({\n          width: null\n        }), k.attr({\n          text: P\n        }), k.textPxLength = k.getBBox().width) : (e.label = k = e.createLabel({\n          x: 0,\n          y: 0\n        }, P, f), e.rotation = 0);\n      }\n      createLabel(t, e, i) {\n        let s = this.axis,\n          o = s.chart,\n          r = n(e) && i.enabled ? o.renderer.text(e, t.x, t.y, i.useHTML).add(s.labelGroup) : null;\n        return r && (o.styledMode || r.css(c(i.style)), r.textPxLength = r.getBBox().width), r;\n      }\n      destroy() {\n        a(this, this.axis);\n      }\n      getPosition(t, e, i, s) {\n        let n = this.axis,\n          a = n.chart,\n          h = s && a.oldChartHeight || a.chartHeight,\n          d = {\n            x: t ? r(n.translate(e + i, void 0, void 0, s) + n.transB) : n.left + n.offset + (n.opposite ? (s && a.oldChartWidth || a.chartWidth) - n.right - n.left : 0),\n            y: t ? h - n.bottom + n.offset - (n.opposite ? n.height : 0) : r(h - n.translate(e + i, void 0, void 0, s) - n.transB)\n          };\n        return d.y = o(d.y, -1e5, 1e5), l(this, \"afterGetPosition\", {\n          pos: d\n        }), d;\n      }\n      getLabelPosition(t, e, i, o, r, a, h, d) {\n        let c, p;\n        let g = this.axis,\n          f = g.transA,\n          m = g.isLinked && g.linkedParent ? g.linkedParent.reversed : g.reversed,\n          x = g.staggerLines,\n          y = g.tickRotCorr || {\n            x: 0,\n            y: 0\n          },\n          b = o || g.reserveSpaceDefault ? 0 : -g.labelOffset * (\"center\" === g.labelAlign ? .5 : 1),\n          v = r.distance,\n          k = {};\n        return c = 0 === g.side ? i.rotation ? -v : -i.getBBox().height : 2 === g.side ? y.y + v : Math.cos(i.rotation * s) * (y.y - i.getBBox(!1, 0).height / 2), n(r.y) && (c = 0 === g.side && g.horiz ? r.y + c : r.y), t = t + u(r.x, [0, 1, 0, -1][g.side] * v) + b + y.x - (a && o ? a * f * (m ? -1 : 1) : 0), e = e + c - (a && !o ? a * f * (m ? 1 : -1) : 0), x && (p = h / (d || 1) % x, g.opposite && (p = x - p - 1), e += p * (g.labelOffset / x)), k.x = t, k.y = Math.round(e), l(this, \"afterGetLabelPosition\", {\n          pos: k,\n          tickmarkOffset: a,\n          index: h\n        }), k;\n      }\n      getLabelSize() {\n        return this.label ? this.label.getBBox()[this.axis.horiz ? \"height\" : \"width\"] : 0;\n      }\n      getMarkPath(t, e, i, s, o, r) {\n        return r.crispLine([[\"M\", t, e], [\"L\", t + (o ? 0 : -i), e + (o ? i : 0)]], s);\n      }\n      handleOverflow(t) {\n        let e = this.axis,\n          i = e.options.labels,\n          o = t.x,\n          r = e.chart.chartWidth,\n          n = e.chart.spacing,\n          a = u(e.labelLeft, Math.min(e.pos, n[3])),\n          h = u(e.labelRight, Math.max(e.isRadial ? 0 : e.pos + e.len, r - n[1])),\n          l = this.label,\n          d = this.rotation,\n          c = {\n            left: 0,\n            center: .5,\n            right: 1\n          }[e.labelAlign || l.attr(\"align\")],\n          p = l.getBBox().width,\n          g = e.getSlotWidth(this),\n          f = {},\n          m = g,\n          x = 1,\n          y;\n        d || \"justify\" !== i.overflow ? d < 0 && o - c * p < a ? y = Math.round(o / Math.cos(d * s) - a) : d > 0 && o + c * p > h && (y = Math.round((r - o) / Math.cos(d * s))) : (o - c * p < a ? m = t.x + m * (1 - c) - a : o + (1 - c) * p > h && (m = h - t.x + m * c, x = -1), (m = Math.min(g, m)) < g && \"center\" === e.labelAlign && (t.x += x * (g - m - c * (g - Math.min(p, m)))), (p > m || e.autoRotation && (l.styles || {}).width) && (y = m)), y && (this.shortenLabel ? this.shortenLabel() : (f.width = Math.floor(y) + \"px\", (i.style || {}).textOverflow || (f.textOverflow = \"ellipsis\"), l.css(f)));\n      }\n      moveLabel(t, e) {\n        let i = this,\n          s = i.label,\n          o = i.axis,\n          r = !1,\n          n;\n        s && s.textStr === t ? (i.movedLabel = s, r = !0, delete i.label) : p(o.ticks, function (e) {\n          r || e.isNew || e === i || !e.label || e.label.textStr !== t || (i.movedLabel = e.label, r = !0, e.labelPos = i.movedLabel.xy, delete e.label);\n        }), !r && (i.labelPos || s) && (n = i.labelPos || s.xy, i.movedLabel = i.createLabel(n, t, e), i.movedLabel && i.movedLabel.attr({\n          opacity: 0\n        }));\n      }\n      render(t, e, i) {\n        let s = this.axis,\n          o = s.horiz,\n          r = this.pos,\n          n = u(this.tickmarkOffset, s.tickmarkOffset),\n          a = this.getPosition(o, r, n, e),\n          h = a.x,\n          d = a.y,\n          c = o && h === s.pos + s.len || !o && d === s.pos ? -1 : 1,\n          p = u(i, this.label && this.label.newOpacity, 1);\n        i = u(i, 1), this.isActive = !0, this.renderGridLine(e, i, c), this.renderMark(a, i, c), this.renderLabel(a, e, p, t), this.isNew = !1, l(this, \"afterRender\");\n      }\n      renderGridLine(t, e, i) {\n        let s = this.axis,\n          o = s.options,\n          r = {},\n          n = this.pos,\n          a = this.type,\n          h = u(this.tickmarkOffset, s.tickmarkOffset),\n          l = s.chart.renderer,\n          d = this.gridLine,\n          c,\n          p = o.gridLineWidth,\n          g = o.gridLineColor,\n          f = o.gridLineDashStyle;\n        \"minor\" === this.type && (p = o.minorGridLineWidth, g = o.minorGridLineColor, f = o.minorGridLineDashStyle), d || (s.chart.styledMode || (r.stroke = g, r[\"stroke-width\"] = p || 0, r.dashstyle = f), a || (r.zIndex = 1), t && (e = 0), this.gridLine = d = l.path().attr(r).addClass(\"highcharts-\" + (a ? a + \"-\" : \"\") + \"grid-line\").add(s.gridGroup)), d && (c = s.getPlotLinePath({\n          value: n + h,\n          lineWidth: d.strokeWidth() * i,\n          force: \"pass\",\n          old: t,\n          acrossPanes: !1\n        })) && d[t || this.isNew ? \"attr\" : \"animate\"]({\n          d: c,\n          opacity: e\n        });\n      }\n      renderMark(t, e, i) {\n        let s = this.axis,\n          o = s.options,\n          r = s.chart.renderer,\n          n = this.type,\n          a = s.tickSize(n ? n + \"Tick\" : \"tick\"),\n          h = t.x,\n          l = t.y,\n          d = u(o[\"minor\" !== n ? \"tickWidth\" : \"minorTickWidth\"], !n && s.isXAxis ? 1 : 0),\n          c = o[\"minor\" !== n ? \"tickColor\" : \"minorTickColor\"],\n          p = this.mark,\n          g = !p;\n        a && (s.opposite && (a[0] = -a[0]), p || (this.mark = p = r.path().addClass(\"highcharts-\" + (n ? n + \"-\" : \"\") + \"tick\").add(s.axisGroup), s.chart.styledMode || p.attr({\n          stroke: c,\n          \"stroke-width\": d\n        })), p[g ? \"attr\" : \"animate\"]({\n          d: this.getMarkPath(h, l, a[0], p.strokeWidth() * i, s.horiz, r),\n          opacity: e\n        }));\n      }\n      renderLabel(t, e, i, s) {\n        let o = this.axis,\n          r = o.horiz,\n          n = o.options,\n          a = this.label,\n          h = n.labels,\n          l = h.step,\n          c = u(this.tickmarkOffset, o.tickmarkOffset),\n          p = t.x,\n          g = t.y,\n          f = !0;\n        a && d(p) && (a.xy = t = this.getLabelPosition(p, g, a, r, h, c, s, l), (!this.isFirst || this.isLast || n.showFirstLabel) && (!this.isLast || this.isFirst || n.showLastLabel) ? !r || h.step || h.rotation || e || 0 === i || this.handleOverflow(t) : f = !1, l && s % l && (f = !1), f && d(t.y) ? (t.opacity = i, a[this.isNewLabel ? \"attr\" : \"animate\"](t).show(!0), this.isNewLabel = !1) : (a.hide(), this.isNewLabel = !0));\n      }\n      replaceMovedLabel() {\n        let t = this.label,\n          e = this.axis;\n        t && !this.isNew && (t.animate({\n          opacity: 0\n        }, void 0, t.destroy), delete this.label), e.isDirty = !0, this.label = this.movedLabel, delete this.movedLabel;\n      }\n    };\n  }), i(e, \"Core/Axis/Axis.js\", [e[\"Core/Animation/AnimationUtilities.js\"], e[\"Core/Axis/AxisDefaults.js\"], e[\"Core/Color/Color.js\"], e[\"Core/Defaults.js\"], e[\"Core/Foundation.js\"], e[\"Core/Globals.js\"], e[\"Core/Axis/Tick.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s, o, r, n, a) {\n    let {\n        animObject: h\n      } = t,\n      {\n        defaultOptions: l\n      } = s,\n      {\n        registerEventOptions: d\n      } = o,\n      {\n        deg2rad: c\n      } = r,\n      {\n        arrayMax: p,\n        arrayMin: u,\n        clamp: g,\n        correctFloat: f,\n        defined: m,\n        destroyObjectProperties: x,\n        erase: y,\n        error: b,\n        extend: v,\n        fireEvent: k,\n        getClosestDistance: S,\n        insertItem: M,\n        isArray: C,\n        isNumber: w,\n        isString: T,\n        merge: A,\n        normalizeTickInterval: P,\n        objectEach: L,\n        pick: O,\n        relativeLength: D,\n        removeEvent: E,\n        splat: I,\n        syncTimeout: B\n      } = a,\n      j = (t, e) => P(e, void 0, void 0, O(t.options.allowDecimals, e < .5 || void 0 !== t.tickAmount), !!t.tickAmount);\n    class R {\n      constructor(t, e, i) {\n        this.alternateBands = void 0, this.bottom = void 0, this.chart = void 0, this.closestPointRange = void 0, this.coll = void 0, this.eventOptions = void 0, this.hasNames = void 0, this.hasVisibleSeries = void 0, this.height = void 0, this.index = void 0, this.isLinked = void 0, this.labelEdge = void 0, this.labelFormatter = void 0, this.left = void 0, this.len = void 0, this.max = void 0, this.maxLabelLength = void 0, this.min = void 0, this.minorTickInterval = void 0, this.minorTicks = void 0, this.minPixelPadding = void 0, this.names = void 0, this.offset = void 0, this.options = void 0, this.overlap = void 0, this.paddedTicks = void 0, this.plotLinesAndBands = void 0, this.plotLinesAndBandsGroups = void 0, this.pointRange = void 0, this.pointRangePadding = void 0, this.pos = void 0, this.positiveValuesOnly = void 0, this.right = void 0, this.series = void 0, this.side = void 0, this.tickAmount = void 0, this.tickInterval = void 0, this.tickmarkOffset = void 0, this.tickPositions = void 0, this.tickRotCorr = void 0, this.ticks = void 0, this.top = void 0, this.transA = void 0, this.transB = void 0, this.translationSlope = void 0, this.userOptions = void 0, this.visible = void 0, this.width = void 0, this.zoomEnabled = void 0, this.init(t, e, i);\n      }\n      init(t, e, i = this.coll) {\n        let s = \"xAxis\" === i;\n        this.chart = t, this.horiz = this.isZAxis || (t.inverted ? !s : s), this.isXAxis = s, this.coll = i, k(this, \"init\", {\n          userOptions: e\n        }), this.opposite = O(e.opposite, this.opposite), this.side = O(e.side, this.side, this.horiz ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3), this.setOptions(e);\n        let o = this.options,\n          r = o.labels,\n          n = o.type;\n        this.userOptions = e, this.minPixelPadding = 0, this.reversed = O(o.reversed, this.reversed), this.visible = o.visible, this.zoomEnabled = o.zoomEnabled, this.hasNames = \"category\" === n || !0 === o.categories, this.categories = o.categories || (this.hasNames ? [] : void 0), this.names || (this.names = [], this.names.keys = {}), this.plotLinesAndBandsGroups = {}, this.positiveValuesOnly = !!this.logarithmic, this.isLinked = m(o.linkedTo), this.ticks = {}, this.labelEdge = [], this.minorTicks = {}, this.plotLinesAndBands = [], this.alternateBands = {}, this.len = 0, this.minRange = this.userMinRange = o.minRange || o.maxZoom, this.range = o.range, this.offset = o.offset || 0, this.max = null, this.min = null;\n        let a = O(o.crosshair, I(t.options.tooltip.crosshairs)[s ? 0 : 1]);\n        this.crosshair = !0 === a ? {} : a, -1 === t.axes.indexOf(this) && (s ? t.axes.splice(t.xAxis.length, 0, this) : t.axes.push(this), M(this, t[this.coll])), t.orderItems(this.coll), this.series = this.series || [], t.inverted && !this.isZAxis && s && void 0 === this.reversed && (this.reversed = !0), this.labelRotation = w(r.rotation) ? r.rotation : void 0, d(this, o), k(this, \"afterInit\");\n      }\n      setOptions(t) {\n        this.options = A(e.defaultXAxisOptions, \"yAxis\" === this.coll && e.defaultYAxisOptions, [e.defaultTopAxisOptions, e.defaultRightAxisOptions, e.defaultBottomAxisOptions, e.defaultLeftAxisOptions][this.side], A(l[this.coll], t)), k(this, \"afterSetOptions\", {\n          userOptions: t\n        });\n      }\n      defaultLabelFormatter(t) {\n        let e = this.axis,\n          i = this.chart,\n          {\n            numberFormatter: s\n          } = i,\n          o = w(this.value) ? this.value : NaN,\n          r = e.chart.time,\n          n = e.categories,\n          a = this.dateTimeLabelFormat,\n          h = l.lang,\n          d = h.numericSymbols,\n          c = h.numericSymbolMagnitude || 1e3,\n          p = e.logarithmic ? Math.abs(o) : e.tickInterval,\n          u = d && d.length,\n          g,\n          f;\n        if (n) f = `${this.value}`;else if (a) f = r.dateFormat(a, o);else if (u && p >= 1e3) for (; u-- && void 0 === f;) p >= (g = Math.pow(c, u + 1)) && 10 * o % g == 0 && null !== d[u] && 0 !== o && (f = s(o / g, -1) + d[u]);\n        return void 0 === f && (f = Math.abs(o) >= 1e4 ? s(o, -1) : s(o, -1, void 0, \"\")), f;\n      }\n      getSeriesExtremes() {\n        let t;\n        let e = this;\n        e.chart, k(this, \"getSeriesExtremes\", null, function () {\n          e.hasVisibleSeries = !1, e.dataMin = e.dataMax = e.threshold = null, e.softThreshold = !e.isXAxis, e.series.forEach(function (i) {\n            if (i.reserveSpace()) {\n              let s = i.options,\n                o,\n                r = s.threshold,\n                n,\n                a;\n              if (e.hasVisibleSeries = !0, e.positiveValuesOnly && r <= 0 && (r = null), e.isXAxis) (o = i.xData) && o.length && (o = e.logarithmic ? o.filter(t => t > 0) : o, n = (t = i.getXExtremes(o)).min, a = t.max, w(n) || n instanceof Date || (o = o.filter(w), n = (t = i.getXExtremes(o)).min, a = t.max), o.length && (e.dataMin = Math.min(O(e.dataMin, n), n), e.dataMax = Math.max(O(e.dataMax, a), a)));else {\n                let t = i.applyExtremes();\n                w(t.dataMin) && (n = t.dataMin, e.dataMin = Math.min(O(e.dataMin, n), n)), w(t.dataMax) && (a = t.dataMax, e.dataMax = Math.max(O(e.dataMax, a), a)), m(r) && (e.threshold = r), (!s.softThreshold || e.positiveValuesOnly) && (e.softThreshold = !1);\n              }\n            }\n          });\n        }), k(this, \"afterGetSeriesExtremes\");\n      }\n      translate(t, e, i, s, o, r) {\n        let n = this.linkedParent || this,\n          a = s && n.old ? n.old.min : n.min;\n        if (!w(a)) return NaN;\n        let h = n.minPixelPadding,\n          l = (n.isOrdinal || n.brokenAxis && n.brokenAxis.hasBreaks || n.logarithmic && o) && n.lin2val,\n          d = 1,\n          c = 0,\n          p = s && n.old ? n.old.transA : n.transA,\n          u = 0;\n        if (p || (p = n.transA), i && (d *= -1, c = n.len), n.reversed && (d *= -1, c -= d * (n.sector || n.len)), e) u = (t = t * d + c - h) / p + a, l && (u = n.lin2val(u));else {\n          l && (t = n.val2lin(t));\n          let e = d * (t - a) * p;\n          u = (n.isRadial ? e : f(e)) + c + d * h + (w(r) ? p * r : 0);\n        }\n        return u;\n      }\n      toPixels(t, e) {\n        return this.translate(t, !1, !this.horiz, void 0, !0) + (e ? 0 : this.pos);\n      }\n      toValue(t, e) {\n        return this.translate(t - (e ? 0 : this.pos), !0, !this.horiz, void 0, !0);\n      }\n      getPlotLinePath(t) {\n        let e = this,\n          i = e.chart,\n          s = e.left,\n          o = e.top,\n          r = t.old,\n          n = t.value,\n          a = t.lineWidth,\n          h = r && i.oldChartHeight || i.chartHeight,\n          l = r && i.oldChartWidth || i.chartWidth,\n          d = e.transB,\n          c = t.translatedValue,\n          p = t.force,\n          u,\n          f,\n          m,\n          x,\n          y;\n        function b(t, e, i) {\n          return \"pass\" !== p && (t < e || t > i) && (p ? t = g(t, e, i) : y = !0), t;\n        }\n        let v = {\n          value: n,\n          lineWidth: a,\n          old: r,\n          force: p,\n          acrossPanes: t.acrossPanes,\n          translatedValue: c\n        };\n        return k(this, \"getPlotLinePath\", v, function (t) {\n          u = m = Math.round((c = g(c = O(c, e.translate(n, void 0, void 0, r)), -1e5, 1e5)) + d), f = x = Math.round(h - c - d), w(c) ? e.horiz ? (f = o, x = h - e.bottom, u = m = b(u, s, s + e.width)) : (u = s, m = l - e.right, f = x = b(f, o, o + e.height)) : (y = !0, p = !1), t.path = y && !p ? void 0 : i.renderer.crispLine([[\"M\", u, f], [\"L\", m, x]], a || 1);\n        }), v.path || null;\n      }\n      getLinearTickPositions(t, e, i) {\n        let s, o, r;\n        let n = f(Math.floor(e / t) * t),\n          a = f(Math.ceil(i / t) * t),\n          h = [];\n        if (f(n + t) === n && (r = 20), this.single) return [e];\n        for (s = n; s <= a && (h.push(s), (s = f(s + t, r)) !== o);) o = s;\n        return h;\n      }\n      getMinorTickInterval() {\n        let t = this.options;\n        return !0 === t.minorTicks ? O(t.minorTickInterval, \"auto\") : !1 === t.minorTicks ? null : t.minorTickInterval;\n      }\n      getMinorTickPositions() {\n        let t = this.options,\n          e = this.tickPositions,\n          i = this.minorTickInterval,\n          s = this.pointRangePadding || 0,\n          o = this.min - s,\n          r = this.max + s,\n          n = r - o,\n          a = [],\n          h;\n        if (n && n / i < this.len / 3) {\n          let s = this.logarithmic;\n          if (s) this.paddedTicks.forEach(function (t, e, o) {\n            e && a.push.apply(a, s.getLogTickPositions(i, o[e - 1], o[e], !0));\n          });else if (this.dateTime && \"auto\" === this.getMinorTickInterval()) a = a.concat(this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(i), o, r, t.startOfWeek));else for (h = o + (e[0] - o) % i; h <= r && h !== a[0]; h += i) a.push(h);\n        }\n        return 0 !== a.length && this.trimTicks(a), a;\n      }\n      adjustForMinRange() {\n        let t = this.options,\n          e = this.logarithmic,\n          i = this.min,\n          s = this.max,\n          o,\n          r,\n          n,\n          a,\n          h,\n          l;\n        this.isXAxis && void 0 === this.minRange && !e && (m(t.min) || m(t.max) || m(t.floor) || m(t.ceiling) ? this.minRange = null : (n = S(this.series.map(t => (t.xIncrement ? t.xData?.slice(0, 2) : t.xData) || [])) || 0, this.minRange = Math.min(5 * n, this.dataMax - this.dataMin))), s - i < this.minRange && (r = this.dataMax - this.dataMin >= this.minRange, o = ((l = this.minRange) - s + i) / 2, a = [i - o, O(t.min, i - o)], r && (a[2] = e ? e.log2lin(this.dataMin) : this.dataMin), h = [(i = p(a)) + l, O(t.max, i + l)], r && (h[2] = e ? e.log2lin(this.dataMax) : this.dataMax), (s = u(h)) - i < l && (a[0] = s - l, a[1] = O(t.min, s - l), i = p(a))), this.min = i, this.max = s;\n      }\n      getClosest() {\n        let t, e;\n        if (this.categories) e = 1;else {\n          let i = [];\n          this.series.forEach(function (t) {\n            let s = t.closestPointRange;\n            t.xData?.length === 1 ? i.push(t.xData[0]) : !t.noSharedTooltip && m(s) && t.reserveSpace() && (e = m(e) ? Math.min(e, s) : s);\n          }), i.length && (i.sort((t, e) => t - e), t = S([i]));\n        }\n        return t && e ? Math.min(t, e) : t || e;\n      }\n      nameToX(t) {\n        let e = C(this.options.categories),\n          i = e ? this.categories : this.names,\n          s = t.options.x,\n          o;\n        return t.series.requireSorting = !1, m(s) || (s = this.options.uniqueNames && i ? e ? i.indexOf(t.name) : O(i.keys[t.name], -1) : t.series.autoIncrement()), -1 === s ? !e && i && (o = i.length) : o = s, void 0 !== o ? (this.names[o] = t.name, this.names.keys[t.name] = o) : t.x && (o = t.x), o;\n      }\n      updateNames() {\n        let t = this,\n          e = this.names,\n          i = e.length;\n        i > 0 && (Object.keys(e.keys).forEach(function (t) {\n          delete e.keys[t];\n        }), e.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach(function (e) {\n          e.xIncrement = null, (!e.points || e.isDirtyData) && (t.max = Math.max(t.max, e.xData.length - 1), e.processData(), e.generatePoints()), e.data.forEach(function (i, s) {\n            let o;\n            i && i.options && void 0 !== i.name && void 0 !== (o = t.nameToX(i)) && o !== i.x && (i.x = o, e.xData[s] = o);\n          });\n        }));\n      }\n      setAxisTranslation() {\n        let t = this,\n          e = t.max - t.min,\n          i = t.linkedParent,\n          s = !!t.categories,\n          o = t.isXAxis,\n          r = t.axisPointRange || 0,\n          n,\n          a = 0,\n          h = 0,\n          l,\n          d = t.transA;\n        (o || s || r) && (n = t.getClosest(), i ? (a = i.minPointOffset, h = i.pointRangePadding) : t.series.forEach(function (e) {\n          let i = s ? 1 : o ? O(e.options.pointRange, n, 0) : t.axisPointRange || 0,\n            l = e.options.pointPlacement;\n          if (r = Math.max(r, i), !t.single || s) {\n            let t = e.is(\"xrange\") ? !o : o;\n            a = Math.max(a, t && T(l) ? 0 : i / 2), h = Math.max(h, t && \"on\" === l ? 0 : i);\n          }\n        }), l = t.ordinal && t.ordinal.slope && n ? t.ordinal.slope / n : 1, t.minPointOffset = a *= l, t.pointRangePadding = h *= l, t.pointRange = Math.min(r, t.single && s ? 1 : e), o && n && (t.closestPointRange = n)), t.translationSlope = t.transA = d = t.staticScale || t.len / (e + h || 1), t.transB = t.horiz ? t.left : t.bottom, t.minPixelPadding = d * a, k(this, \"afterSetAxisTranslation\");\n      }\n      minFromRange() {\n        return this.max - this.range;\n      }\n      setTickInterval(t) {\n        let e = this.chart,\n          i = this.logarithmic,\n          s = this.options,\n          o = this.isXAxis,\n          r = this.isLinked,\n          n = s.tickPixelInterval,\n          a = this.categories,\n          h = this.softThreshold,\n          l = s.maxPadding,\n          d = s.minPadding,\n          c,\n          p,\n          u = w(s.tickInterval) && s.tickInterval >= 0 ? s.tickInterval : void 0,\n          g = w(this.threshold) ? this.threshold : null,\n          x,\n          y,\n          v,\n          S;\n        if (this.dateTime || a || r || this.getTickAmount(), v = O(this.userMin, s.min), S = O(this.userMax, s.max), r ? (this.linkedParent = e[this.coll][s.linkedTo], p = this.linkedParent.getExtremes(), this.min = O(p.min, p.dataMin), this.max = O(p.max, p.dataMax), s.type !== this.linkedParent.options.type && b(11, 1, e)) : (h && m(g) && (this.dataMin >= g ? (x = g, d = 0) : this.dataMax <= g && (y = g, l = 0)), this.min = O(v, x, this.dataMin), this.max = O(S, y, this.dataMax)), i && (this.positiveValuesOnly && !t && 0 >= Math.min(this.min, O(this.dataMin, this.min)) && b(10, 1, e), this.min = f(i.log2lin(this.min), 16), this.max = f(i.log2lin(this.max), 16)), this.range && m(this.max) && (this.userMin = this.min = v = Math.max(this.dataMin, this.minFromRange()), this.userMax = S = this.max, this.range = null), k(this, \"foundExtremes\"), this.beforePadding && this.beforePadding(), this.adjustForMinRange(), !w(this.userMin) && w(s.softMin) && s.softMin < this.min && (this.min = v = s.softMin), !w(this.userMax) && w(s.softMax) && s.softMax > this.max && (this.max = S = s.softMax), !a && !this.axisPointRange && !(this.stacking && this.stacking.usePercentage) && !r && m(this.min) && m(this.max) && (c = this.max - this.min) && (!m(v) && d && (this.min -= c * d), !m(S) && l && (this.max += c * l)), !w(this.userMin) && w(s.floor) && (this.min = Math.max(this.min, s.floor)), !w(this.userMax) && w(s.ceiling) && (this.max = Math.min(this.max, s.ceiling)), h && m(this.dataMin) && (g = g || 0, !m(v) && this.min < g && this.dataMin >= g ? this.min = this.options.minRange ? Math.min(g, this.max - this.minRange) : g : !m(S) && this.max > g && this.dataMax <= g && (this.max = this.options.minRange ? Math.max(g, this.min + this.minRange) : g)), w(this.min) && w(this.max) && !this.chart.polar && this.min > this.max && (m(this.options.min) ? this.max = this.min : m(this.options.max) && (this.min = this.max)), this.min === this.max || void 0 === this.min || void 0 === this.max ? this.tickInterval = 1 : r && this.linkedParent && !u && n === this.linkedParent.options.tickPixelInterval ? this.tickInterval = u = this.linkedParent.tickInterval : this.tickInterval = O(u, this.tickAmount ? (this.max - this.min) / Math.max(this.tickAmount - 1, 1) : void 0, a ? 1 : (this.max - this.min) * n / Math.max(this.len, n)), o && !t) {\n          let t = this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max);\n          this.series.forEach(function (e) {\n            e.forceCrop = e.forceCropping && e.forceCropping(), e.processData(t);\n          }), k(this, \"postProcessData\", {\n            hasExtremesChanged: t\n          });\n        }\n        this.setAxisTranslation(), k(this, \"initialAxisTranslation\"), this.pointRange && !u && (this.tickInterval = Math.max(this.pointRange, this.tickInterval));\n        let M = O(s.minTickInterval, this.dateTime && !this.series.some(t => t.noSharedTooltip) ? this.closestPointRange : 0);\n        !u && this.tickInterval < M && (this.tickInterval = M), this.dateTime || this.logarithmic || u || (this.tickInterval = j(this, this.tickInterval)), this.tickAmount || (this.tickInterval = this.unsquish()), this.setTickPositions();\n      }\n      setTickPositions() {\n        let t = this.options,\n          e = t.tickPositions,\n          i = t.tickPositioner,\n          s = this.getMinorTickInterval(),\n          o = this.hasVerticalPanning(),\n          r = \"colorAxis\" === this.coll,\n          n = (r || !o) && t.startOnTick,\n          a = (r || !o) && t.endOnTick,\n          h = [],\n          l;\n        if (this.tickmarkOffset = this.categories && \"between\" === t.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0, this.minorTickInterval = \"auto\" === s && this.tickInterval ? this.tickInterval / t.minorTicksPerMajor : s, this.single = this.min === this.max && m(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || !1 !== t.allowDecimals), e) h = e.slice();else if (w(this.min) && w(this.max)) {\n          if ((!this.ordinal || !this.ordinal.positions) && (this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200)) h = [this.min, this.max], b(19, !1, this.chart);else if (this.dateTime) h = this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(this.tickInterval, t.units), this.min, this.max, t.startOfWeek, this.ordinal && this.ordinal.positions, this.closestPointRange, !0);else if (this.logarithmic) h = this.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max);else {\n            let t = this.tickInterval,\n              e = t;\n            for (; e <= 2 * t;) if (h = this.getLinearTickPositions(this.tickInterval, this.min, this.max), this.tickAmount && h.length > this.tickAmount) this.tickInterval = j(this, e *= 1.1);else break;\n          }\n          h.length > this.len && (h = [h[0], h[h.length - 1]])[0] === h[1] && (h.length = 1), i && (this.tickPositions = h, (l = i.apply(this, [this.min, this.max])) && (h = l));\n        }\n        this.tickPositions = h, this.paddedTicks = h.slice(0), this.trimTicks(h, n, a), !this.isLinked && w(this.min) && w(this.max) && (this.single && h.length < 2 && !this.categories && !this.series.some(t => t.is(\"heatmap\") && \"between\" === t.options.pointPlacement) && (this.min -= .5, this.max += .5), e || l || this.adjustTickAmount()), k(this, \"afterSetTickPositions\");\n      }\n      trimTicks(t, e, i) {\n        let s = t[0],\n          o = t[t.length - 1],\n          r = !this.isOrdinal && this.minPointOffset || 0;\n        if (k(this, \"trimTicks\"), !this.isLinked) {\n          if (e && s !== -1 / 0) this.min = s;else for (; this.min - r > t[0];) t.shift();\n          if (i) this.max = o;else for (; this.max + r < t[t.length - 1];) t.pop();\n          0 === t.length && m(s) && !this.options.tickPositions && t.push((o + s) / 2);\n        }\n      }\n      alignToOthers() {\n        let t;\n        let e = this,\n          i = [this],\n          s = e.options,\n          o = \"yAxis\" === this.coll && this.chart.options.chart.alignThresholds,\n          r = [];\n        if (e.thresholdAlignment = void 0, (!1 !== this.chart.options.chart.alignTicks && s.alignTicks || o) && !1 !== s.startOnTick && !1 !== s.endOnTick && !e.logarithmic) {\n          let s = t => {\n              let {\n                horiz: e,\n                options: i\n              } = t;\n              return [e ? i.left : i.top, i.width, i.height, i.pane].join(\",\");\n            },\n            o = s(this);\n          this.chart[this.coll].forEach(function (r) {\n            let {\n              series: n\n            } = r;\n            n.length && n.some(t => t.visible) && r !== e && s(r) === o && (t = !0, i.push(r));\n          });\n        }\n        if (t && o) {\n          i.forEach(t => {\n            let i = t.getThresholdAlignment(e);\n            w(i) && r.push(i);\n          });\n          let t = r.length > 1 ? r.reduce((t, e) => t += e, 0) / r.length : void 0;\n          i.forEach(e => {\n            e.thresholdAlignment = t;\n          });\n        }\n        return t;\n      }\n      getThresholdAlignment(t) {\n        if ((!w(this.dataMin) || this !== t && this.series.some(t => t.isDirty || t.isDirtyData)) && this.getSeriesExtremes(), w(this.threshold)) {\n          let t = g((this.threshold - (this.dataMin || 0)) / ((this.dataMax || 0) - (this.dataMin || 0)), 0, 1);\n          return this.options.reversed && (t = 1 - t), t;\n        }\n      }\n      getTickAmount() {\n        let t = this.options,\n          e = t.tickPixelInterval,\n          i = t.tickAmount;\n        m(t.tickInterval) || i || !(this.len < e) || this.isRadial || this.logarithmic || !t.startOnTick || !t.endOnTick || (i = 2), !i && this.alignToOthers() && (i = Math.ceil(this.len / e) + 1), i < 4 && (this.finalTickAmt = i, i = 5), this.tickAmount = i;\n      }\n      adjustTickAmount() {\n        let t = this,\n          {\n            finalTickAmt: e,\n            max: i,\n            min: s,\n            options: o,\n            tickPositions: r,\n            tickAmount: n,\n            thresholdAlignment: a\n          } = t,\n          h = r && r.length,\n          l = O(t.threshold, t.softThreshold ? 0 : null),\n          d,\n          c,\n          p = t.tickInterval,\n          u,\n          g = () => r.push(f(r[r.length - 1] + p)),\n          x = () => r.unshift(f(r[0] - p));\n        if (w(a) && (u = a < .5 ? Math.ceil(a * (n - 1)) : Math.floor(a * (n - 1)), o.reversed && (u = n - 1 - u)), t.hasData() && w(s) && w(i)) {\n          let a = () => {\n            t.transA *= (h - 1) / (n - 1), t.min = o.startOnTick ? r[0] : Math.min(s, r[0]), t.max = o.endOnTick ? r[r.length - 1] : Math.max(i, r[r.length - 1]);\n          };\n          if (w(u) && w(t.threshold)) {\n            for (; r[u] !== l || r.length !== n || r[0] > s || r[r.length - 1] < i;) {\n              for (r.length = 0, r.push(t.threshold); r.length < n;) void 0 === r[u] || r[u] > t.threshold ? x() : g();\n              if (p > 8 * t.tickInterval) break;\n              p *= 2;\n            }\n            a();\n          } else if (h < n) {\n            for (; r.length < n;) r.length % 2 || s === l ? g() : x();\n            a();\n          }\n          if (m(e)) {\n            for (c = d = r.length; c--;) (3 === e && c % 2 == 1 || e <= 2 && c > 0 && c < d - 1) && r.splice(c, 1);\n            t.finalTickAmt = void 0;\n          }\n        }\n      }\n      setScale() {\n        let {\n            coll: t,\n            stacking: e\n          } = this,\n          i = !1,\n          s = !1;\n        this.series.forEach(t => {\n          i = i || t.isDirtyData || t.isDirty, s = s || t.xAxis && t.xAxis.isDirty || !1;\n        }), this.setAxisSize();\n        let o = this.len !== (this.old && this.old.len);\n        o || i || s || this.isLinked || this.forceRedraw || this.userMin !== (this.old && this.old.userMin) || this.userMax !== (this.old && this.old.userMax) || this.alignToOthers() ? (e && \"yAxis\" === t && e.buildStacks(), this.forceRedraw = !1, this.userMinRange || (this.minRange = void 0), this.getSeriesExtremes(), this.setTickInterval(), e && \"xAxis\" === t && e.buildStacks(), this.isDirty || (this.isDirty = o || this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max))) : e && e.cleanStacks(), i && this.panningState && (this.panningState.isDirty = !0), k(this, \"afterSetScale\");\n      }\n      setExtremes(t, e, i, s, o) {\n        let r = this,\n          n = r.chart;\n        i = O(i, !0), r.series.forEach(function (t) {\n          delete t.kdTree;\n        }), k(r, \"setExtremes\", o = v(o, {\n          min: t,\n          max: e\n        }), function () {\n          r.userMin = t, r.userMax = e, r.eventArgs = o, i && n.redraw(s);\n        });\n      }\n      zoom(t, e) {\n        let i = this,\n          s = this.dataMin,\n          o = this.dataMax,\n          r = this.options,\n          n = Math.min(s, O(r.min, s)),\n          a = Math.max(o, O(r.max, o)),\n          h = {\n            newMin: t,\n            newMax: e\n          };\n        return k(this, \"zoom\", h, function (t) {\n          let e = t.newMin,\n            r = t.newMax;\n          (e !== i.min || r !== i.max) && (!i.allowZoomOutside && (m(s) && (e < n && (e = n), e > a && (e = a)), m(o) && (r < n && (r = n), r > a && (r = a))), i.displayBtn = void 0 !== e || void 0 !== r, i.setExtremes(e, r, !1, void 0, {\n            trigger: \"zoom\"\n          })), t.zoomed = !0;\n        }), h.zoomed;\n      }\n      setAxisSize() {\n        let t = this.chart,\n          e = this.options,\n          i = e.offsets || [0, 0, 0, 0],\n          s = this.horiz,\n          o = this.width = Math.round(D(O(e.width, t.plotWidth - i[3] + i[1]), t.plotWidth)),\n          r = this.height = Math.round(D(O(e.height, t.plotHeight - i[0] + i[2]), t.plotHeight)),\n          n = this.top = Math.round(D(O(e.top, t.plotTop + i[0]), t.plotHeight, t.plotTop)),\n          a = this.left = Math.round(D(O(e.left, t.plotLeft + i[3]), t.plotWidth, t.plotLeft));\n        this.bottom = t.chartHeight - r - n, this.right = t.chartWidth - o - a, this.len = Math.max(s ? o : r, 0), this.pos = s ? a : n;\n      }\n      getExtremes() {\n        let t = this.logarithmic;\n        return {\n          min: t ? f(t.lin2log(this.min)) : this.min,\n          max: t ? f(t.lin2log(this.max)) : this.max,\n          dataMin: this.dataMin,\n          dataMax: this.dataMax,\n          userMin: this.userMin,\n          userMax: this.userMax\n        };\n      }\n      getThreshold(t) {\n        let e = this.logarithmic,\n          i = e ? e.lin2log(this.min) : this.min,\n          s = e ? e.lin2log(this.max) : this.max;\n        return null === t || t === -1 / 0 ? t = i : t === 1 / 0 ? t = s : i > t ? t = i : s < t && (t = s), this.translate(t, 0, 1, 0, 1);\n      }\n      autoLabelAlign(t) {\n        let e = (O(t, 0) - 90 * this.side + 720) % 360,\n          i = {\n            align: \"center\"\n          };\n        return k(this, \"autoLabelAlign\", i, function (t) {\n          e > 15 && e < 165 ? t.align = \"right\" : e > 195 && e < 345 && (t.align = \"left\");\n        }), i.align;\n      }\n      tickSize(t) {\n        let e = this.options,\n          i = O(e[\"tick\" === t ? \"tickWidth\" : \"minorTickWidth\"], \"tick\" === t && this.isXAxis && !this.categories ? 1 : 0),\n          s = e[\"tick\" === t ? \"tickLength\" : \"minorTickLength\"],\n          o;\n        i && s && (\"inside\" === e[t + \"Position\"] && (s = -s), o = [s, i]);\n        let r = {\n          tickSize: o\n        };\n        return k(this, \"afterTickSize\", r), r.tickSize;\n      }\n      labelMetrics() {\n        let t = this.chart.renderer,\n          e = this.ticks,\n          i = e[Object.keys(e)[0]] || {};\n        return this.chart.renderer.fontMetrics(i.label || i.movedLabel || t.box);\n      }\n      unsquish() {\n        let t = this.options.labels,\n          e = this.horiz,\n          i = this.tickInterval,\n          s = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / i),\n          o = t.rotation,\n          r = .75 * this.labelMetrics().h,\n          n = Math.max(this.max - this.min, 0),\n          a = function (t) {\n            let e = t / (s || 1);\n            return (e = e > 1 ? Math.ceil(e) : 1) * i > n && t !== 1 / 0 && s !== 1 / 0 && n && (e = Math.ceil(n / i)), f(e * i);\n          },\n          h = i,\n          l,\n          d = Number.MAX_VALUE,\n          p;\n        if (e) {\n          if (!t.staggerLines && (w(o) ? p = [o] : s < t.autoRotationLimit && (p = t.autoRotation)), p) {\n            let t, e;\n            for (let i of p) (i === o || i && i >= -90 && i <= 90) && (e = (t = a(Math.abs(r / Math.sin(c * i)))) + Math.abs(i / 360)) < d && (d = e, l = i, h = t);\n          }\n        } else h = a(r);\n        return this.autoRotation = p, this.labelRotation = O(l, w(o) ? o : 0), t.step ? i : h;\n      }\n      getSlotWidth(t) {\n        let e = this.chart,\n          i = this.horiz,\n          s = this.options.labels,\n          o = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),\n          r = e.margin[3];\n        if (t && w(t.slotWidth)) return t.slotWidth;\n        if (i && s.step < 2) return s.rotation ? 0 : (this.staggerLines || 1) * this.len / o;\n        if (!i) {\n          let t = s.style.width;\n          if (void 0 !== t) return parseInt(String(t), 10);\n          if (r) return r - e.spacing[3];\n        }\n        return .33 * e.chartWidth;\n      }\n      renderUnsquish() {\n        let t = this.chart,\n          e = t.renderer,\n          i = this.tickPositions,\n          s = this.ticks,\n          o = this.options.labels,\n          r = o.style,\n          n = this.horiz,\n          a = this.getSlotWidth(),\n          h = Math.max(1, Math.round(a - 2 * o.padding)),\n          l = {},\n          d = this.labelMetrics(),\n          c = r.textOverflow,\n          p,\n          u,\n          g = 0,\n          f,\n          m;\n        if (T(o.rotation) || (l.rotation = o.rotation || 0), i.forEach(function (t) {\n          let e = s[t];\n          e.movedLabel && e.replaceMovedLabel(), e && e.label && e.label.textPxLength > g && (g = e.label.textPxLength);\n        }), this.maxLabelLength = g, this.autoRotation) g > h && g > d.h ? l.rotation = this.labelRotation : this.labelRotation = 0;else if (a && (p = h, !c)) for (u = \"clip\", m = i.length; !n && m--;) (f = s[i[m]].label) && (f.styles && \"ellipsis\" === f.styles.textOverflow ? f.css({\n          textOverflow: \"clip\"\n        }) : f.textPxLength > a && f.css({\n          width: a + \"px\"\n        }), f.getBBox().height > this.len / i.length - (d.h - d.f) && (f.specificTextOverflow = \"ellipsis\"));\n        l.rotation && (p = g > .5 * t.chartHeight ? .33 * t.chartHeight : g, c || (u = \"ellipsis\")), this.labelAlign = o.align || this.autoLabelAlign(this.labelRotation), this.labelAlign && (l.align = this.labelAlign), i.forEach(function (t) {\n          let e = s[t],\n            i = e && e.label,\n            o = r.width,\n            n = {};\n          i && (i.attr(l), e.shortenLabel ? e.shortenLabel() : p && !o && \"nowrap\" !== r.whiteSpace && (p < i.textPxLength || \"SPAN\" === i.element.tagName) ? (n.width = p + \"px\", c || (n.textOverflow = i.specificTextOverflow || u), i.css(n)) : i.styles && i.styles.width && !n.width && !o && i.css({\n            width: null\n          }), delete i.specificTextOverflow, e.rotation = l.rotation);\n        }, this), this.tickRotCorr = e.rotCorr(d.b, this.labelRotation || 0, 0 !== this.side);\n      }\n      hasData() {\n        return this.series.some(function (t) {\n          return t.hasData();\n        }) || this.options.showEmpty && m(this.min) && m(this.max);\n      }\n      addTitle(t) {\n        let e;\n        let i = this.chart.renderer,\n          s = this.horiz,\n          o = this.opposite,\n          r = this.options,\n          n = r.title,\n          a = this.chart.styledMode;\n        this.axisTitle || ((e = n.textAlign) || (e = (s ? {\n          low: \"left\",\n          middle: \"center\",\n          high: \"right\"\n        } : {\n          low: o ? \"right\" : \"left\",\n          middle: \"center\",\n          high: o ? \"left\" : \"right\"\n        })[n.align]), this.axisTitle = i.text(n.text || \"\", 0, 0, n.useHTML).attr({\n          zIndex: 7,\n          rotation: n.rotation,\n          align: e\n        }).addClass(\"highcharts-axis-title\"), a || this.axisTitle.css(A(n.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = !0), a || n.style.width || this.isRadial || this.axisTitle.css({\n          width: this.len + \"px\"\n        }), this.axisTitle[t ? \"show\" : \"hide\"](t);\n      }\n      generateTick(t) {\n        let e = this.ticks;\n        e[t] ? e[t].addLabel() : e[t] = new n(this, t);\n      }\n      getOffset() {\n        let t = this,\n          {\n            chart: e,\n            horiz: i,\n            options: s,\n            side: o,\n            ticks: r,\n            tickPositions: n,\n            coll: a,\n            axisParent: h\n          } = t,\n          l = e.renderer,\n          d = e.inverted && !t.isZAxis ? [1, 0, 3, 2][o] : o,\n          c = t.hasData(),\n          p = s.title,\n          u = s.labels,\n          g = w(s.crossing),\n          f = e.axisOffset,\n          x = e.clipOffset,\n          y = [-1, 1, 1, -1][o],\n          b = s.className,\n          v,\n          S = 0,\n          M,\n          C = 0,\n          T = 0,\n          A,\n          P;\n        if (t.showAxis = v = c || s.showEmpty, t.staggerLines = t.horiz && u.staggerLines || void 0, !t.axisGroup) {\n          let e = (t, e, i) => l.g(t).attr({\n            zIndex: i\n          }).addClass(`highcharts-${a.toLowerCase()}${e} ` + (this.isRadial ? `highcharts-radial-axis${e} ` : \"\") + (b || \"\")).add(h);\n          t.gridGroup = e(\"grid\", \"-grid\", s.gridZIndex), t.axisGroup = e(\"axis\", \"\", s.zIndex), t.labelGroup = e(\"axis-labels\", \"-labels\", u.zIndex);\n        }\n        if (c || t.isLinked ? (n.forEach(function (e) {\n          t.generateTick(e);\n        }), t.renderUnsquish(), t.reserveSpaceDefault = 0 === o || 2 === o || {\n          1: \"left\",\n          3: \"right\"\n        }[o] === t.labelAlign, O(u.reserveSpace, !g && null, \"center\" === t.labelAlign || null, t.reserveSpaceDefault) && n.forEach(function (t) {\n          T = Math.max(r[t].getLabelSize(), T);\n        }), t.staggerLines && (T *= t.staggerLines), t.labelOffset = T * (t.opposite ? -1 : 1)) : L(r, function (t, e) {\n          t.destroy(), delete r[e];\n        }), p && p.text && !1 !== p.enabled && (t.addTitle(v), v && !g && !1 !== p.reserveSpace && (t.titleOffset = S = t.axisTitle.getBBox()[i ? \"height\" : \"width\"], C = m(M = p.offset) ? 0 : O(p.margin, i ? 5 : 10))), t.renderLine(), t.offset = y * O(s.offset, f[o] ? f[o] + (s.margin || 0) : 0), t.tickRotCorr = t.tickRotCorr || {\n          x: 0,\n          y: 0\n        }, P = 0 === o ? -t.labelMetrics().h : 2 === o ? t.tickRotCorr.y : 0, A = Math.abs(T) + C, T && (A -= P, A += y * (i ? O(u.y, t.tickRotCorr.y + y * u.distance) : O(u.x, y * u.distance))), t.axisTitleMargin = O(M, A), t.getMaxLabelDimensions && (t.maxLabelDimensions = t.getMaxLabelDimensions(r, n)), \"colorAxis\" !== a) {\n          let e = this.tickSize(\"tick\");\n          f[o] = Math.max(f[o], (t.axisTitleMargin || 0) + S + y * t.offset, A, n && n.length && e ? e[0] + y * t.offset : 0);\n          let i = !t.axisLine || s.offset ? 0 : 2 * Math.floor(t.axisLine.strokeWidth() / 2);\n          x[d] = Math.max(x[d], i);\n        }\n        k(this, \"afterGetOffset\");\n      }\n      getLinePath(t) {\n        let e = this.chart,\n          i = this.opposite,\n          s = this.offset,\n          o = this.horiz,\n          r = this.left + (i ? this.width : 0) + s,\n          n = e.chartHeight - this.bottom - (i ? this.height : 0) + s;\n        return i && (t *= -1), e.renderer.crispLine([[\"M\", o ? this.left : r, o ? n : this.top], [\"L\", o ? e.chartWidth - this.right : r, o ? n : e.chartHeight - this.bottom]], t);\n      }\n      renderLine() {\n        this.axisLine || (this.axisLine = this.chart.renderer.path().addClass(\"highcharts-axis-line\").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({\n          stroke: this.options.lineColor,\n          \"stroke-width\": this.options.lineWidth,\n          zIndex: 7\n        }));\n      }\n      getTitlePosition(t) {\n        let e = this.horiz,\n          i = this.left,\n          s = this.top,\n          o = this.len,\n          r = this.options.title,\n          n = e ? i : s,\n          a = this.opposite,\n          h = this.offset,\n          l = r.x,\n          d = r.y,\n          c = this.chart.renderer.fontMetrics(t),\n          p = t ? Math.max(t.getBBox(!1, 0).height - c.h - 1, 0) : 0,\n          u = {\n            low: n + (e ? 0 : o),\n            middle: n + o / 2,\n            high: n + (e ? o : 0)\n          }[r.align],\n          g = (e ? s + this.height : i) + (e ? 1 : -1) * (a ? -1 : 1) * (this.axisTitleMargin || 0) + [-p, p, c.f, -p][this.side],\n          f = {\n            x: e ? u + l : g + (a ? this.width : 0) + h + l,\n            y: e ? g + d - (a ? this.height : 0) + h : u + d\n          };\n        return k(this, \"afterGetTitlePosition\", {\n          titlePosition: f\n        }), f;\n      }\n      renderMinorTick(t, e) {\n        let i = this.minorTicks;\n        i[t] || (i[t] = new n(this, t, \"minor\")), e && i[t].isNew && i[t].render(null, !0), i[t].render(null, !1, 1);\n      }\n      renderTick(t, e, i) {\n        let s = this.isLinked,\n          o = this.ticks;\n        (!s || t >= this.min && t <= this.max || this.grid && this.grid.isColumn) && (o[t] || (o[t] = new n(this, t)), i && o[t].isNew && o[t].render(e, !0, -1), o[t].render(e));\n      }\n      render() {\n        let t, e;\n        let i = this,\n          s = i.chart,\n          o = i.logarithmic,\n          a = s.renderer,\n          l = i.options,\n          d = i.isLinked,\n          c = i.tickPositions,\n          p = i.axisTitle,\n          u = i.ticks,\n          g = i.minorTicks,\n          f = i.alternateBands,\n          m = l.stackLabels,\n          x = l.alternateGridColor,\n          y = l.crossing,\n          b = i.tickmarkOffset,\n          v = i.axisLine,\n          S = i.showAxis,\n          M = h(a.globalAnimation);\n        if (i.labelEdge.length = 0, i.overlap = !1, [u, g, f].forEach(function (t) {\n          L(t, function (t) {\n            t.isActive = !1;\n          });\n        }), w(y)) {\n          let t = this.isXAxis ? s.yAxis[0] : s.xAxis[0],\n            e = [1, -1, -1, 1][this.side];\n          if (t) {\n            let s = t.toPixels(y, !0);\n            i.horiz && (s = t.len - s), i.offset = e * s;\n          }\n        }\n        if (i.hasData() || d) {\n          let a = i.chart.hasRendered && i.old && w(i.old.min);\n          i.minorTickInterval && !i.categories && i.getMinorTickPositions().forEach(function (t) {\n            i.renderMinorTick(t, a);\n          }), c.length && (c.forEach(function (t, e) {\n            i.renderTick(t, e, a);\n          }), b && (0 === i.min || i.single) && (u[-1] || (u[-1] = new n(i, -1, null, !0)), u[-1].render(-1))), x && c.forEach(function (n, a) {\n            e = void 0 !== c[a + 1] ? c[a + 1] + b : i.max - b, a % 2 == 0 && n < i.max && e <= i.max + (s.polar ? -b : b) && (f[n] || (f[n] = new r.PlotLineOrBand(i)), t = n + b, f[n].options = {\n              from: o ? o.lin2log(t) : t,\n              to: o ? o.lin2log(e) : e,\n              color: x,\n              className: \"highcharts-alternate-grid\"\n            }, f[n].render(), f[n].isActive = !0);\n          }), i._addedPlotLB || (i._addedPlotLB = !0, (l.plotLines || []).concat(l.plotBands || []).forEach(function (t) {\n            i.addPlotBandOrLine(t);\n          }));\n        }\n        [u, g, f].forEach(function (t) {\n          let e = [],\n            i = M.duration;\n          L(t, function (t, i) {\n            t.isActive || (t.render(i, !1, 0), t.isActive = !1, e.push(i));\n          }), B(function () {\n            let i = e.length;\n            for (; i--;) t[e[i]] && !t[e[i]].isActive && (t[e[i]].destroy(), delete t[e[i]]);\n          }, t !== f && s.hasRendered && i ? i : 0);\n        }), v && (v[v.isPlaced ? \"animate\" : \"attr\"]({\n          d: this.getLinePath(v.strokeWidth())\n        }), v.isPlaced = !0, v[S ? \"show\" : \"hide\"](S)), p && S && (p[p.isNew ? \"attr\" : \"animate\"](i.getTitlePosition(p)), p.isNew = !1), m && m.enabled && i.stacking && i.stacking.renderStackTotals(), i.old = {\n          len: i.len,\n          max: i.max,\n          min: i.min,\n          transA: i.transA,\n          userMax: i.userMax,\n          userMin: i.userMin\n        }, i.isDirty = !1, k(this, \"afterRender\");\n      }\n      redraw() {\n        this.visible && (this.render(), this.plotLinesAndBands.forEach(function (t) {\n          t.render();\n        })), this.series.forEach(function (t) {\n          t.isDirty = !0;\n        });\n      }\n      getKeepProps() {\n        return this.keepProps || R.keepProps;\n      }\n      destroy(t) {\n        let e = this,\n          i = e.plotLinesAndBands,\n          s = this.eventOptions;\n        if (k(this, \"destroy\", {\n          keepEvents: t\n        }), t || E(e), [e.ticks, e.minorTicks, e.alternateBands].forEach(function (t) {\n          x(t);\n        }), i) {\n          let t = i.length;\n          for (; t--;) i[t].destroy();\n        }\n        for (let t in [\"axisLine\", \"axisTitle\", \"axisGroup\", \"gridGroup\", \"labelGroup\", \"cross\", \"scrollbar\"].forEach(function (t) {\n          e[t] && (e[t] = e[t].destroy());\n        }), e.plotLinesAndBandsGroups) e.plotLinesAndBandsGroups[t] = e.plotLinesAndBandsGroups[t].destroy();\n        L(e, function (t, i) {\n          -1 === e.getKeepProps().indexOf(i) && delete e[i];\n        }), this.eventOptions = s;\n      }\n      drawCrosshair(t, e) {\n        let s = this.crosshair,\n          o = O(s && s.snap, !0),\n          r = this.chart,\n          n,\n          a,\n          h,\n          l = this.cross,\n          d;\n        if (k(this, \"drawCrosshair\", {\n          e: t,\n          point: e\n        }), t || (t = this.cross && this.cross.e), s && !1 !== (m(e) || !o)) {\n          if (o ? m(e) && (a = O(\"colorAxis\" !== this.coll ? e.crosshairPos : null, this.isXAxis ? e.plotX : this.len - e.plotY)) : a = t && (this.horiz ? t.chartX - this.pos : this.len - t.chartY + this.pos), m(a) && (d = {\n            value: e && (this.isXAxis ? e.x : O(e.stackY, e.y)),\n            translatedValue: a\n          }, r.polar && v(d, {\n            isCrosshair: !0,\n            chartX: t && t.chartX,\n            chartY: t && t.chartY,\n            point: e\n          }), n = this.getPlotLinePath(d) || null), !m(n)) {\n            this.hideCrosshair();\n            return;\n          }\n          h = this.categories && !this.isRadial, l || (this.cross = l = r.renderer.path().addClass(\"highcharts-crosshair highcharts-crosshair-\" + (h ? \"category \" : \"thin \") + (s.className || \"\")).attr({\n            zIndex: O(s.zIndex, 2)\n          }).add(), !r.styledMode && (l.attr({\n            stroke: s.color || (h ? i.parse(\"#ccd3ff\").setOpacity(.25).get() : \"#cccccc\"),\n            \"stroke-width\": O(s.width, 1)\n          }).css({\n            \"pointer-events\": \"none\"\n          }), s.dashStyle && l.attr({\n            dashstyle: s.dashStyle\n          }))), l.show().attr({\n            d: n\n          }), h && !s.width && l.attr({\n            \"stroke-width\": this.transA\n          }), this.cross.e = t;\n        } else this.hideCrosshair();\n        k(this, \"afterDrawCrosshair\", {\n          e: t,\n          point: e\n        });\n      }\n      hideCrosshair() {\n        this.cross && this.cross.hide(), k(this, \"afterHideCrosshair\");\n      }\n      hasVerticalPanning() {\n        let t = this.chart.options.chart.panning;\n        return !!(t && t.enabled && /y/.test(t.type));\n      }\n      update(t, e) {\n        let i = this.chart;\n        t = A(this.userOptions, t), this.destroy(!0), this.init(i, t), i.isDirtyBox = !0, O(e, !0) && i.redraw();\n      }\n      remove(t) {\n        let e = this.chart,\n          i = this.coll,\n          s = this.series,\n          o = s.length;\n        for (; o--;) s[o] && s[o].remove(!1);\n        y(e.axes, this), y(e[i] || [], this), e.orderItems(i), this.destroy(), e.isDirtyBox = !0, O(t, !0) && e.redraw();\n      }\n      setTitle(t, e) {\n        this.update({\n          title: t\n        }, e);\n      }\n      setCategories(t, e) {\n        this.update({\n          categories: t\n        }, e);\n      }\n    }\n    return R.defaultOptions = e.defaultXAxisOptions, R.keepProps = [\"coll\", \"extKey\", \"hcEvents\", \"names\", \"series\", \"userMax\", \"userMin\"], R;\n  }), i(e, \"Core/Axis/DateTimeAxis.js\", [e[\"Core/Utilities.js\"]], function (t) {\n    var e;\n    let {\n      addEvent: i,\n      getMagnitude: s,\n      normalizeTickInterval: o,\n      timeUnits: r\n    } = t;\n    return function (e) {\n      let n = [];\n      function a() {\n        return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);\n      }\n      function h(t) {\n        let e = t.userOptions;\n        if (\"datetime\" !== e.type) {\n          this.dateTime = void 0;\n          return;\n        }\n        this.dateTime || (this.dateTime = new l(this));\n      }\n      e.compose = function (e) {\n        if (t.pushUnique(n, e)) {\n          e.keepProps.push(\"dateTime\");\n          let t = e.prototype;\n          t.getTimeTicks = a, i(e, \"init\", h);\n        }\n        return e;\n      };\n      class l {\n        constructor(t) {\n          this.axis = t;\n        }\n        normalizeTimeTickInterval(t, e) {\n          let i = e || [[\"millisecond\", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], [\"second\", [1, 2, 5, 10, 15, 30]], [\"minute\", [1, 2, 5, 10, 15, 30]], [\"hour\", [1, 2, 3, 4, 6, 8, 12]], [\"day\", [1, 2]], [\"week\", [1, 2]], [\"month\", [1, 2, 3, 4, 6]], [\"year\", null]],\n            n = i[i.length - 1],\n            a = r[n[0]],\n            h = n[1],\n            l;\n          for (l = 0; l < i.length; l++) if (a = r[(n = i[l])[0]], h = n[1], i[l + 1]) {\n            let e = (a * h[h.length - 1] + r[i[l + 1][0]]) / 2;\n            if (t <= e) break;\n          }\n          a === r.year && t < 5 * a && (h = [1, 2, 5]);\n          let d = o(t / a, h, \"year\" === n[0] ? Math.max(s(t / a), 1) : 1);\n          return {\n            unitRange: a,\n            count: d,\n            unitName: n[0]\n          };\n        }\n        getXDateFormat(t, e) {\n          let {\n              axis: i\n            } = this,\n            s = i.chart.time;\n          return i.closestPointRange ? s.getDateFormat(i.closestPointRange, t, i.options.startOfWeek, e) || s.resolveDTLFormat(e.year).main : s.resolveDTLFormat(e.day).main;\n        }\n      }\n      e.Additions = l;\n    }(e || (e = {})), e;\n  }), i(e, \"Core/Axis/LogarithmicAxis.js\", [e[\"Core/Utilities.js\"]], function (t) {\n    var e;\n    let {\n      addEvent: i,\n      normalizeTickInterval: s,\n      pick: o\n    } = t;\n    return function (e) {\n      let r = [];\n      function n(t) {\n        let e = t.userOptions,\n          i = this.logarithmic;\n        \"logarithmic\" !== e.type ? this.logarithmic = void 0 : i || (i = this.logarithmic = new h(this));\n      }\n      function a() {\n        let t = this.logarithmic;\n        t && (this.lin2val = function (e) {\n          return t.lin2log(e);\n        }, this.val2lin = function (e) {\n          return t.log2lin(e);\n        });\n      }\n      e.compose = function (e) {\n        return t.pushUnique(r, e) && (e.keepProps.push(\"logarithmic\"), i(e, \"init\", n), i(e, \"afterInit\", a)), e;\n      };\n      class h {\n        constructor(t) {\n          this.axis = t;\n        }\n        getLogTickPositions(t, e, i, r) {\n          let n = this.axis,\n            a = n.len,\n            h = n.options,\n            l = [];\n          if (r || (this.minorAutoInterval = void 0), t >= .5) t = Math.round(t), l = n.getLinearTickPositions(t, e, i);else if (t >= .08) {\n            let s, o, n, a, h, d, c;\n            let p = Math.floor(e);\n            for (s = t > .3 ? [1, 2, 4] : t > .15 ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9], o = p; o < i + 1 && !c; o++) for (n = 0, a = s.length; n < a && !c; n++) (h = this.log2lin(this.lin2log(o) * s[n])) > e && (!r || d <= i) && void 0 !== d && l.push(d), d > i && (c = !0), d = h;\n          } else {\n            let d = this.lin2log(e),\n              c = this.lin2log(i),\n              p = r ? n.getMinorTickInterval() : h.tickInterval,\n              u = \"auto\" === p ? null : p,\n              g = h.tickPixelInterval / (r ? 5 : 1),\n              f = r ? a / n.tickPositions.length : a;\n            t = s(t = o(u, this.minorAutoInterval, (c - d) * g / (f || 1))), l = n.getLinearTickPositions(t, d, c).map(this.log2lin), r || (this.minorAutoInterval = t / 5);\n          }\n          return r || (n.tickInterval = t), l;\n        }\n        lin2log(t) {\n          return Math.pow(10, t);\n        }\n        log2lin(t) {\n          return Math.log(t) / Math.LN10;\n        }\n      }\n      e.Additions = h;\n    }(e || (e = {})), e;\n  }), i(e, \"Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js\", [e[\"Core/Utilities.js\"]], function (t) {\n    var e;\n    let {\n      erase: i,\n      extend: s,\n      isNumber: o\n    } = t;\n    return function (e) {\n      let r;\n      let n = [];\n      function a(t) {\n        return this.addPlotBandOrLine(t, \"plotBands\");\n      }\n      function h(t, e) {\n        let i = this.userOptions,\n          s = new r(this, t);\n        if (this.visible && (s = s.render()), s) {\n          if (this._addedPlotLB || (this._addedPlotLB = !0, (i.plotLines || []).concat(i.plotBands || []).forEach(t => {\n            this.addPlotBandOrLine(t);\n          })), e) {\n            let s = i[e] || [];\n            s.push(t), i[e] = s;\n          }\n          this.plotLinesAndBands.push(s);\n        }\n        return s;\n      }\n      function l(t) {\n        return this.addPlotBandOrLine(t, \"plotLines\");\n      }\n      function d(t, e, i) {\n        i = i || this.options;\n        let s = this.getPlotLinePath({\n            value: e,\n            force: !0,\n            acrossPanes: i.acrossPanes\n          }),\n          r = [],\n          n = this.horiz,\n          a = !o(this.min) || !o(this.max) || t < this.min && e < this.min || t > this.max && e > this.max,\n          h = this.getPlotLinePath({\n            value: t,\n            force: !0,\n            acrossPanes: i.acrossPanes\n          }),\n          l,\n          d = 1,\n          c;\n        if (h && s) for (a && (c = h.toString() === s.toString(), d = 0), l = 0; l < h.length; l += 2) {\n          let t = h[l],\n            e = h[l + 1],\n            i = s[l],\n            o = s[l + 1];\n          (\"M\" === t[0] || \"L\" === t[0]) && (\"M\" === e[0] || \"L\" === e[0]) && (\"M\" === i[0] || \"L\" === i[0]) && (\"M\" === o[0] || \"L\" === o[0]) && (n && i[1] === t[1] ? (i[1] += d, o[1] += d) : n || i[2] !== t[2] || (i[2] += d, o[2] += d), r.push([\"M\", t[1], t[2]], [\"L\", e[1], e[2]], [\"L\", o[1], o[2]], [\"L\", i[1], i[2]], [\"Z\"])), r.isFlat = c;\n        } else h = null;\n        return r;\n      }\n      function c(t) {\n        this.removePlotBandOrLine(t);\n      }\n      function p(t) {\n        let e = this.plotLinesAndBands,\n          s = this.options,\n          o = this.userOptions;\n        if (e) {\n          let r = e.length;\n          for (; r--;) e[r].id === t && e[r].destroy();\n          [s.plotLines || [], o.plotLines || [], s.plotBands || [], o.plotBands || []].forEach(function (e) {\n            for (r = e.length; r--;) (e[r] || {}).id === t && i(e, e[r]);\n          });\n        }\n      }\n      function u(t) {\n        this.removePlotBandOrLine(t);\n      }\n      e.compose = function (e, i) {\n        return r || (r = e), t.pushUnique(n, i) && s(i.prototype, {\n          addPlotBand: a,\n          addPlotLine: l,\n          addPlotBandOrLine: h,\n          getPlotBandPath: d,\n          removePlotBand: c,\n          removePlotLine: u,\n          removePlotBandOrLine: p\n        }), i;\n      };\n    }(e || (e = {})), e;\n  }), i(e, \"Core/Axis/PlotLineOrBand/PlotLineOrBand.js\", [e[\"Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js\"], e[\"Core/Utilities.js\"]], function (t, e) {\n    let {\n      arrayMax: i,\n      arrayMin: s,\n      defined: o,\n      destroyObjectProperties: r,\n      erase: n,\n      fireEvent: a,\n      merge: h,\n      objectEach: l,\n      pick: d\n    } = e;\n    class c {\n      static compose(e) {\n        return t.compose(c, e);\n      }\n      constructor(t, e) {\n        this.id = void 0, this.axis = t, e && (this.options = e, this.id = e.id);\n      }\n      render() {\n        a(this, \"render\");\n        let t = this,\n          e = t.axis,\n          i = e.horiz,\n          s = e.logarithmic,\n          r = t.options,\n          n = r.color,\n          c = d(r.zIndex, 0),\n          p = r.events,\n          u = {},\n          g = e.chart.renderer,\n          f = r.label,\n          m = t.label,\n          x = r.to,\n          y = r.from,\n          b = r.value,\n          v = t.svgElem,\n          k = [],\n          S,\n          M = o(y) && o(x),\n          C = o(b),\n          w = !v,\n          T = {\n            class: \"highcharts-plot-\" + (M ? \"band \" : \"line \") + (r.className || \"\")\n          },\n          A = M ? \"bands\" : \"lines\";\n        if (s && (y = s.log2lin(y), x = s.log2lin(x), b = s.log2lin(b)), !e.chart.styledMode && (C ? (T.stroke = n || \"#999999\", T[\"stroke-width\"] = d(r.width, 1), r.dashStyle && (T.dashstyle = r.dashStyle)) : M && (T.fill = n || \"#e6e9ff\", r.borderWidth && (T.stroke = r.borderColor, T[\"stroke-width\"] = r.borderWidth))), u.zIndex = c, A += \"-\" + c, (S = e.plotLinesAndBandsGroups[A]) || (e.plotLinesAndBandsGroups[A] = S = g.g(\"plot-\" + A).attr(u).add()), w && (t.svgElem = v = g.path().attr(T).add(S)), C) k = e.getPlotLinePath({\n          value: b,\n          lineWidth: v.strokeWidth(),\n          acrossPanes: r.acrossPanes\n        });else {\n          if (!M) return;\n          k = e.getPlotBandPath(y, x, r);\n        }\n        return !t.eventsAdded && p && (l(p, function (e, i) {\n          v.on(i, function (e) {\n            p[i].apply(t, [e]);\n          });\n        }), t.eventsAdded = !0), (w || !v.d) && k && k.length ? v.attr({\n          d: k\n        }) : v && (k ? (v.show(), v.animate({\n          d: k\n        })) : v.d && (v.hide(), m && (t.label = m = m.destroy()))), f && (o(f.text) || o(f.formatter)) && k && k.length && e.width > 0 && e.height > 0 && !k.isFlat ? (f = h({\n          align: i && M && \"center\",\n          x: i ? !M && 4 : 10,\n          verticalAlign: !i && M && \"middle\",\n          y: i ? M ? 16 : 10 : M ? 6 : -4,\n          rotation: i && !M && 90\n        }, f), this.renderLabel(f, k, M, c)) : m && m.hide(), t;\n      }\n      renderLabel(t, e, o, r) {\n        let n = this.axis,\n          a = n.chart.renderer,\n          l = this.label;\n        l || (this.label = l = a.text(this.getLabelText(t), 0, 0, t.useHTML).attr({\n          align: t.textAlign || t.align,\n          rotation: t.rotation,\n          class: \"highcharts-plot-\" + (o ? \"band\" : \"line\") + \"-label \" + (t.className || \"\"),\n          zIndex: r\n        }), n.chart.styledMode || l.css(h({\n          fontSize: \"0.8em\",\n          textOverflow: \"ellipsis\"\n        }, t.style)), l.add());\n        let d = e.xBounds || [e[0][1], e[1][1], o ? e[2][1] : e[0][1]],\n          c = e.yBounds || [e[0][2], e[1][2], o ? e[2][2] : e[0][2]],\n          p = s(d),\n          u = s(c);\n        if (l.align(t, !1, {\n          x: p,\n          y: u,\n          width: i(d) - p,\n          height: i(c) - u\n        }), !l.alignValue || \"left\" === l.alignValue) {\n          let e = t.clip ? n.width : n.chart.chartWidth;\n          l.css({\n            width: (90 === l.rotation ? n.height - (l.alignAttr.y - n.top) : e - (l.alignAttr.x - n.left)) + \"px\"\n          });\n        }\n        l.show(!0);\n      }\n      getLabelText(t) {\n        return o(t.formatter) ? t.formatter.call(this) : t.text;\n      }\n      destroy() {\n        n(this.axis.plotLinesAndBands, this), delete this.axis, r(this);\n      }\n    }\n    return c;\n  }), i(e, \"Core/Tooltip.js\", [e[\"Core/Templating.js\"], e[\"Core/Globals.js\"], e[\"Core/Renderer/RendererUtilities.js\"], e[\"Core/Renderer/RendererRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s, o) {\n    let {\n        format: r\n      } = t,\n      {\n        doc: n,\n        isSafari: a\n      } = e,\n      {\n        distribute: h\n      } = i,\n      {\n        addEvent: l,\n        clamp: d,\n        css: c,\n        discardElement: p,\n        extend: u,\n        fireEvent: g,\n        isArray: f,\n        isNumber: m,\n        isString: x,\n        merge: y,\n        pick: b,\n        splat: v,\n        syncTimeout: k\n      } = o;\n    class S {\n      constructor(t, e) {\n        this.allowShared = !0, this.crosshairs = [], this.distance = 0, this.isHidden = !0, this.isSticky = !1, this.now = {}, this.options = {}, this.outside = !1, this.chart = t, this.init(t, e);\n      }\n      bodyFormatter(t) {\n        return t.map(function (t) {\n          let e = t.series.tooltipOptions;\n          return (e[(t.point.formatPrefix || \"point\") + \"Formatter\"] || t.point.tooltipFormatter).call(t.point, e[(t.point.formatPrefix || \"point\") + \"Format\"] || \"\");\n        });\n      }\n      cleanSplit(t) {\n        this.chart.series.forEach(function (e) {\n          let i = e && e.tt;\n          i && (!i.isActive || t ? e.tt = i.destroy() : i.isActive = !1);\n        });\n      }\n      defaultFormatter(t) {\n        let e;\n        let i = this.points || v(this);\n        return (e = (e = [t.tooltipFooterHeaderFormatter(i[0])]).concat(t.bodyFormatter(i))).push(t.tooltipFooterHeaderFormatter(i[0], !0)), e;\n      }\n      destroy() {\n        this.label && (this.label = this.label.destroy()), this.split && (this.cleanSplit(!0), this.tt && (this.tt = this.tt.destroy())), this.renderer && (this.renderer = this.renderer.destroy(), p(this.container)), o.clearTimeout(this.hideTimer), o.clearTimeout(this.tooltipTimeout);\n      }\n      getAnchor(t, e) {\n        let i;\n        let s = this.chart,\n          o = s.pointer,\n          r = s.inverted,\n          n = s.plotTop,\n          a = s.plotLeft;\n        if ((t = v(t))[0].series && t[0].series.yAxis && !t[0].series.yAxis.options.reversedStacks && (t = t.slice().reverse()), this.followPointer && e) void 0 === e.chartX && (e = o.normalize(e)), i = [e.chartX - a, e.chartY - n];else if (t[0].tooltipPos) i = t[0].tooltipPos;else {\n          let s = 0,\n            o = 0;\n          t.forEach(function (t) {\n            let e = t.pos(!0);\n            e && (s += e[0], o += e[1]);\n          }), s /= t.length, o /= t.length, this.shared && t.length > 1 && e && (r ? s = e.chartX : o = e.chartY), i = [s - a, o - n];\n        }\n        return i.map(Math.round);\n      }\n      getClassName(t, e, i) {\n        let s = this.options,\n          o = t.series,\n          r = o.options;\n        return [s.className, \"highcharts-label\", i && \"highcharts-tooltip-header\", e ? \"highcharts-tooltip-box\" : \"highcharts-tooltip\", !i && \"highcharts-color-\" + b(t.colorIndex, o.colorIndex), r && r.className].filter(x).join(\" \");\n      }\n      getLabel() {\n        let t = this,\n          i = this.chart.styledMode,\n          o = this.options,\n          r = this.split && this.allowShared,\n          n = this.container,\n          a = this.chart.renderer;\n        if (this.label) {\n          let t = !this.label.hasClass(\"highcharts-label\");\n          (!r && t || r && !t) && this.destroy();\n        }\n        if (!this.label) {\n          if (this.outside) {\n            let t = this.chart.options.chart.style,\n              i = s.getRendererType();\n            this.container = n = e.doc.createElement(\"div\"), n.className = \"highcharts-tooltip-container\", c(n, {\n              position: \"absolute\",\n              top: \"1px\",\n              pointerEvents: \"none\",\n              zIndex: Math.max(this.options.style.zIndex || 0, (t && t.zIndex || 0) + 3)\n            }), this.renderer = a = new i(n, 0, 0, t, void 0, void 0, a.styledMode);\n          }\n          if (r ? this.label = a.g(\"tooltip\") : (this.label = a.label(\"\", 0, 0, o.shape, void 0, void 0, o.useHTML, void 0, \"tooltip\").attr({\n            padding: o.padding,\n            r: o.borderRadius\n          }), i || this.label.attr({\n            fill: o.backgroundColor,\n            \"stroke-width\": o.borderWidth || 0\n          }).css(o.style).css({\n            pointerEvents: o.style.pointerEvents || (this.shouldStickOnContact() ? \"auto\" : \"none\")\n          })), t.outside) {\n            let e = this.label,\n              {\n                xSetter: i,\n                ySetter: s\n              } = e;\n            e.xSetter = function (s) {\n              i.call(e, t.distance), n && (n.style.left = s + \"px\");\n            }, e.ySetter = function (i) {\n              s.call(e, t.distance), n && (n.style.top = i + \"px\");\n            };\n          }\n          this.label.attr({\n            zIndex: 8\n          }).shadow(o.shadow).add();\n        }\n        return n && !n.parentElement && e.doc.body.appendChild(n), this.label;\n      }\n      getPlayingField() {\n        let {\n            body: t,\n            documentElement: e\n          } = n,\n          {\n            chart: i,\n            distance: s,\n            outside: o\n          } = this;\n        return {\n          width: o ? Math.max(t.scrollWidth, e.scrollWidth, t.offsetWidth, e.offsetWidth, e.clientWidth) - 2 * s : i.chartWidth,\n          height: o ? Math.max(t.scrollHeight, e.scrollHeight, t.offsetHeight, e.offsetHeight, e.clientHeight) : i.chartHeight\n        };\n      }\n      getPosition(t, e, i) {\n        let s = this.chart,\n          o = this.distance,\n          r = {},\n          n = s.inverted && i.h || 0,\n          a = this.outside,\n          h = this.getPlayingField(),\n          l = h.width,\n          d = h.height,\n          c = s.pointer.getChartPosition(),\n          p = t => t * c.scaleX,\n          u = t => t * c.scaleY,\n          g = r => {\n            let n = \"x\" === r;\n            return [r, n ? l : d, n ? t : e].concat(a ? [n ? p(t) : u(e), n ? c.left - o + p(i.plotX + s.plotLeft) : c.top - o + u(i.plotY + s.plotTop), 0, n ? l : d] : [n ? t : e, n ? i.plotX + s.plotLeft : i.plotY + s.plotTop, n ? s.plotLeft : s.plotTop, n ? s.plotLeft + s.plotWidth : s.plotTop + s.plotHeight]);\n          },\n          f = g(\"y\"),\n          m = g(\"x\"),\n          x,\n          y = !!i.negative;\n        !s.polar && s.hoverSeries && s.hoverSeries.yAxis && s.hoverSeries.yAxis.reversed && (y = !y);\n        let v = !this.followPointer && b(i.ttBelow, !s.inverted === y),\n          k = function (t, e, i, s, h, l, d) {\n            let c = a ? \"y\" === t ? u(o) : p(o) : o,\n              g = (i - s) / 2,\n              f = s < h - o,\n              m = h + o + s < e,\n              x = h - c - i + g,\n              y = h + c - g;\n            if (v && m) r[t] = y;else if (!v && f) r[t] = x;else if (f) r[t] = Math.min(d - s, x - n < 0 ? x : x - n);else {\n              if (!m) return !1;\n              r[t] = Math.max(l, y + n + i > e ? y : y + n);\n            }\n          },\n          S = function (t, e, i, s, n) {\n            let a;\n            return n < o || n > e - o ? a = !1 : n < i / 2 ? r[t] = 1 : n > e - s / 2 ? r[t] = e - s - 2 : r[t] = n - i / 2, a;\n          },\n          M = function (t) {\n            let e = f;\n            f = m, m = e, x = t;\n          },\n          C = function () {\n            !1 !== k.apply(0, f) ? !1 !== S.apply(0, m) || x || (M(!0), C()) : x ? r.x = r.y = 0 : (M(!0), C());\n          };\n        return (s.inverted || this.len > 1) && M(), C(), r;\n      }\n      hide(t) {\n        let e = this;\n        o.clearTimeout(this.hideTimer), t = b(t, this.options.hideDelay), this.isHidden || (this.hideTimer = k(function () {\n          let i = e.getLabel();\n          e.getLabel().animate({\n            opacity: 0\n          }, {\n            duration: t ? 150 : t,\n            complete: () => {\n              i.hide(), e.container && e.container.remove();\n            }\n          }), e.isHidden = !0;\n        }, t));\n      }\n      init(t, e) {\n        this.chart = t, this.options = e, this.crosshairs = [], this.now = {\n          x: 0,\n          y: 0\n        }, this.isHidden = !0, this.split = e.split && !t.inverted && !t.polar, this.shared = e.shared || this.split, this.outside = b(e.outside, !!(t.scrollablePixelsX || t.scrollablePixelsY));\n      }\n      shouldStickOnContact(t) {\n        return !!(!this.followPointer && this.options.stickOnContact && (!t || this.chart.pointer.inClass(t.target, \"highcharts-tooltip\")));\n      }\n      move(t, e, i, s) {\n        let r = this,\n          n = r.now,\n          a = !1 !== r.options.animation && !r.isHidden && (Math.abs(t - n.x) > 1 || Math.abs(e - n.y) > 1),\n          h = r.followPointer || r.len > 1;\n        u(n, {\n          x: a ? (2 * n.x + t) / 3 : t,\n          y: a ? (n.y + e) / 2 : e,\n          anchorX: h ? void 0 : a ? (2 * n.anchorX + i) / 3 : i,\n          anchorY: h ? void 0 : a ? (n.anchorY + s) / 2 : s\n        }), r.getLabel().attr(n), r.drawTracker(), a && (o.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function () {\n          r && r.move(t, e, i, s);\n        }, 32));\n      }\n      refresh(t, e) {\n        let i = this.chart,\n          s = this.options,\n          n = i.pointer,\n          a = v(t),\n          h = a[0],\n          l = [],\n          d = s.format,\n          c = s.formatter || this.defaultFormatter,\n          p = this.shared,\n          u = i.styledMode,\n          m = {};\n        if (!s.enabled || !h.series) return;\n        o.clearTimeout(this.hideTimer), this.allowShared = !(!f(t) && t.series && t.series.noSharedTooltip), this.followPointer = !this.split && h.series.tooltipOptions.followPointer;\n        let y = this.getAnchor(t, e),\n          k = y[0],\n          S = y[1];\n        p && this.allowShared ? (n.applyInactiveState(a), a.forEach(function (t) {\n          t.setState(\"hover\"), l.push(t.getLabelConfig());\n        }), (m = h.getLabelConfig()).points = l) : m = h.getLabelConfig(), this.len = l.length;\n        let M = x(d) ? r(d, m, i) : c.call(m, this),\n          C = h.series;\n        if (this.distance = b(C.tooltipOptions.distance, 16), !1 === M) this.hide();else {\n          if (this.split && this.allowShared) this.renderSplit(M, a);else {\n            let t = k,\n              o = S;\n            if (e && n.isDirectTouch && (t = e.chartX - i.plotLeft, o = e.chartY - i.plotTop), i.polar || !1 === C.options.clip || a.some(e => n.isDirectTouch || e.series.shouldShowTooltip(t, o))) {\n              let t = this.getLabel();\n              (!s.style.width || u) && t.css({\n                width: (this.outside ? this.getPlayingField() : i.spacingBox).width + \"px\"\n              }), t.attr({\n                text: M && M.join ? M.join(\"\") : M\n              }), t.addClass(this.getClassName(h), !0), u || t.attr({\n                stroke: s.borderColor || h.color || C.color || \"#666666\"\n              }), this.updatePosition({\n                plotX: k,\n                plotY: S,\n                negative: h.negative,\n                ttBelow: h.ttBelow,\n                h: y[2] || 0\n              });\n            } else {\n              this.hide();\n              return;\n            }\n          }\n          this.isHidden && this.label && this.label.attr({\n            opacity: 1\n          }).show(), this.isHidden = !1;\n        }\n        g(this, \"refresh\");\n      }\n      renderSplit(t, e) {\n        let i = this,\n          {\n            chart: s,\n            chart: {\n              chartWidth: o,\n              chartHeight: r,\n              plotHeight: l,\n              plotLeft: c,\n              plotTop: p,\n              pointer: g,\n              scrollablePixelsY: f = 0,\n              scrollablePixelsX: m,\n              scrollingContainer: {\n                scrollLeft: y,\n                scrollTop: v\n              } = {\n                scrollLeft: 0,\n                scrollTop: 0\n              },\n              styledMode: k\n            },\n            distance: S,\n            options: M,\n            options: {\n              positioner: C\n            }\n          } = i,\n          w = i.outside && \"number\" != typeof m ? n.documentElement.getBoundingClientRect() : {\n            left: y,\n            right: y + o,\n            top: v,\n            bottom: v + r\n          },\n          T = i.getLabel(),\n          A = this.renderer || s.renderer,\n          P = !!(s.xAxis[0] && s.xAxis[0].opposite),\n          {\n            left: L,\n            top: O\n          } = g.getChartPosition(),\n          D = p + v,\n          E = 0,\n          I = l - f;\n        function B(t, e, s, o, r = !0) {\n          let n, a;\n          return s ? (n = P ? 0 : I, a = d(t - o / 2, w.left, w.right - o - (i.outside ? L : 0))) : (n = e - D, a = d(a = r ? t - o - S : t + S, r ? a : w.left, w.right)), {\n            x: a,\n            y: n\n          };\n        }\n        x(t) && (t = [!1, t]);\n        let j = t.slice(0, e.length + 1).reduce(function (t, s, o) {\n          if (!1 !== s && \"\" !== s) {\n            let r = e[o - 1] || {\n                isHeader: !0,\n                plotX: e[0].plotX,\n                plotY: l,\n                series: {}\n              },\n              n = r.isHeader,\n              a = n ? i : r.series,\n              h = a.tt = function (t, e, s) {\n                let o = t,\n                  {\n                    isHeader: r,\n                    series: n\n                  } = e;\n                if (!o) {\n                  let t = {\n                    padding: M.padding,\n                    r: M.borderRadius\n                  };\n                  k || (t.fill = M.backgroundColor, t[\"stroke-width\"] = M.borderWidth ?? 1), o = A.label(\"\", 0, 0, M[r ? \"headerShape\" : \"shape\"], void 0, void 0, M.useHTML).addClass(i.getClassName(e, !0, r)).attr(t).add(T);\n                }\n                return o.isActive = !0, o.attr({\n                  text: s\n                }), k || o.css(M.style).attr({\n                  stroke: M.borderColor || e.color || n.color || \"#333333\"\n                }), o;\n              }(a.tt, r, s.toString()),\n              u = h.getBBox(),\n              g = u.width + h.strokeWidth();\n            n && (E = u.height, I += E, P && (D -= E));\n            let {\n              anchorX: f,\n              anchorY: m\n            } = function (t) {\n              let e, i;\n              let {\n                isHeader: s,\n                plotX: o = 0,\n                plotY: r = 0,\n                series: n\n              } = t;\n              if (s) e = Math.max(c + o, c), i = p + l / 2;else {\n                let {\n                  xAxis: t,\n                  yAxis: s\n                } = n;\n                e = t.pos + d(o, -S, t.len + S), n.shouldShowTooltip(0, s.pos - p + r, {\n                  ignoreX: !0\n                }) && (i = s.pos + r);\n              }\n              return {\n                anchorX: e = d(e, w.left - S, w.right + S),\n                anchorY: i\n              };\n            }(r);\n            if (\"number\" == typeof m) {\n              let e = u.height + 1,\n                s = C ? C.call(i, g, e, r) : B(f, m, n, g);\n              t.push({\n                align: C ? 0 : void 0,\n                anchorX: f,\n                anchorY: m,\n                boxWidth: g,\n                point: r,\n                rank: b(s.rank, n ? 1 : 0),\n                size: e,\n                target: s.y,\n                tt: h,\n                x: s.x\n              });\n            } else h.isActive = !1;\n          }\n          return t;\n        }, []);\n        !C && j.some(t => {\n          let {\n              outside: e\n            } = i,\n            s = (e ? L : 0) + t.anchorX;\n          return s < w.left && s + t.boxWidth < w.right || s < L - w.left + t.boxWidth && w.right - s > s;\n        }) && (j = j.map(t => {\n          let {\n            x: e,\n            y: i\n          } = B(t.anchorX, t.anchorY, t.point.isHeader, t.boxWidth, !1);\n          return u(t, {\n            target: i,\n            x: e\n          });\n        })), i.cleanSplit(), h(j, I);\n        let R = {\n          left: L,\n          right: L\n        };\n        j.forEach(function (t) {\n          let {\n            x: e,\n            boxWidth: s,\n            isHeader: o\n          } = t;\n          !o && (i.outside && L + e < R.left && (R.left = L + e), !o && i.outside && R.left + s > R.right && (R.right = L + e));\n        }), j.forEach(function (t) {\n          let {\n              x: e,\n              anchorX: s,\n              anchorY: o,\n              pos: r,\n              point: {\n                isHeader: n\n              }\n            } = t,\n            a = {\n              visibility: void 0 === r ? \"hidden\" : \"inherit\",\n              x: e,\n              y: (r || 0) + D,\n              anchorX: s,\n              anchorY: o\n            };\n          if (i.outside && e < s) {\n            let t = L - R.left;\n            t > 0 && (n || (a.x = e + t, a.anchorX = s + t), n && (a.x = (R.right - R.left) / 2, a.anchorX = s + t));\n          }\n          t.tt.attr(a);\n        });\n        let {\n          container: z,\n          outside: N,\n          renderer: W\n        } = i;\n        if (N && z && W) {\n          let {\n            width: t,\n            height: e,\n            x: i,\n            y: s\n          } = T.getBBox();\n          W.setSize(t + i, e + s, !1), z.style.left = R.left + \"px\", z.style.top = O + \"px\";\n        }\n        a && T.attr({\n          opacity: 1 === T.opacity ? .999 : 1\n        });\n      }\n      drawTracker() {\n        if (!this.shouldStickOnContact()) {\n          this.tracker && (this.tracker = this.tracker.destroy());\n          return;\n        }\n        let t = this.chart,\n          e = this.label,\n          i = this.shared ? t.hoverPoints : t.hoverPoint;\n        if (!e || !i) return;\n        let s = {\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n          },\n          o = this.getAnchor(i),\n          r = e.getBBox();\n        o[0] += t.plotLeft - (e.translateX || 0), o[1] += t.plotTop - (e.translateY || 0), s.x = Math.min(0, o[0]), s.y = Math.min(0, o[1]), s.width = o[0] < 0 ? Math.max(Math.abs(o[0]), r.width - o[0]) : Math.max(Math.abs(o[0]), r.width), s.height = o[1] < 0 ? Math.max(Math.abs(o[1]), r.height - Math.abs(o[1])) : Math.max(Math.abs(o[1]), r.height), this.tracker ? this.tracker.attr(s) : (this.tracker = e.renderer.rect(s).addClass(\"highcharts-tracker\").add(e), t.styledMode || this.tracker.attr({\n          fill: \"rgba(0,0,0,0)\"\n        }));\n      }\n      styledModeFormat(t) {\n        return t.replace('style=\"font-size: 0.8em\"', 'class=\"highcharts-header\"').replace(/style=\"color:{(point|series)\\.color}\"/g, 'class=\"highcharts-color-{$1.colorIndex} {series.options.className} {point.options.className}\"');\n      }\n      tooltipFooterHeaderFormatter(t, e) {\n        let i = t.series,\n          s = i.tooltipOptions,\n          o = i.xAxis,\n          n = o && o.dateTime,\n          a = {\n            isFooter: e,\n            labelConfig: t\n          },\n          h = s.xDateFormat,\n          l = s[e ? \"footerFormat\" : \"headerFormat\"];\n        return g(this, \"headerFormatter\", a, function (e) {\n          n && !h && m(t.key) && (h = n.getXDateFormat(t.key, s.dateTimeLabelFormats)), n && h && (t.point && t.point.tooltipDateKeys || [\"key\"]).forEach(function (t) {\n            l = l.replace(\"{point.\" + t + \"}\", \"{point.\" + t + \":\" + h + \"}\");\n          }), i.chart.styledMode && (l = this.styledModeFormat(l)), e.text = r(l, {\n            point: t,\n            series: i\n          }, this.chart);\n        }), a.text;\n      }\n      update(t) {\n        this.destroy(), this.init(this.chart, y(!0, this.options, t));\n      }\n      updatePosition(t) {\n        let {\n            chart: e,\n            container: i,\n            distance: s,\n            options: o,\n            renderer: r\n          } = this,\n          {\n            height: n = 0,\n            width: a = 0\n          } = this.getLabel(),\n          h = e.pointer,\n          {\n            left: l,\n            top: d,\n            scaleX: p,\n            scaleY: u\n          } = h.getChartPosition(),\n          g = (o.positioner || this.getPosition).call(this, a, n, t),\n          f = (t.plotX || 0) + e.plotLeft,\n          m = (t.plotY || 0) + e.plotTop,\n          x;\n        r && i && (o.positioner && (g.x += l - s, g.y += d - s), x = (o.borderWidth || 0) + 2 * s + 2, r.setSize(a + x, n + x, !1), (1 !== p || 1 !== u) && (c(i, {\n          transform: `scale(${p}, ${u})`\n        }), f *= p, m *= u), f += l - g.x, m += d - g.y), this.move(Math.round(g.x), Math.round(g.y || 0), f, m);\n      }\n    }\n    return function (t) {\n      let e = [];\n      t.compose = function (i) {\n        o.pushUnique(e, i) && l(i, \"afterInit\", function () {\n          let e = this.chart;\n          e.options.tooltip && (e.tooltip = new t(e, e.options.tooltip));\n        });\n      };\n    }(S || (S = {})), S;\n  }), i(e, \"Core/Series/Point.js\", [e[\"Core/Renderer/HTML/AST.js\"], e[\"Core/Animation/AnimationUtilities.js\"], e[\"Core/Defaults.js\"], e[\"Core/Templating.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s, o) {\n    let {\n        animObject: r\n      } = e,\n      {\n        defaultOptions: n\n      } = i,\n      {\n        format: a\n      } = s,\n      {\n        addEvent: h,\n        defined: l,\n        erase: d,\n        extend: c,\n        fireEvent: p,\n        getNestedProperty: u,\n        isArray: g,\n        isFunction: f,\n        isNumber: m,\n        isObject: x,\n        merge: y,\n        objectEach: b,\n        pick: v,\n        syncTimeout: k,\n        removeEvent: S,\n        uniqueKey: M\n      } = o;\n    class C {\n      constructor() {\n        this.category = void 0, this.destroyed = !1, this.formatPrefix = \"point\", this.id = void 0, this.isNull = !1, this.name = void 0, this.options = void 0, this.percentage = void 0, this.selected = !1, this.series = void 0, this.shapeArgs = void 0, this.total = void 0, this.visible = !0, this.x = void 0;\n      }\n      animateBeforeDestroy() {\n        let t = this,\n          e = {\n            x: t.startXPos,\n            opacity: 0\n          },\n          i = t.getGraphicalProps();\n        i.singular.forEach(function (i) {\n          t[i] = t[i].animate(\"dataLabel\" === i ? {\n            x: t[i].startXPos,\n            y: t[i].startYPos,\n            opacity: 0\n          } : e);\n        }), i.plural.forEach(function (e) {\n          t[e].forEach(function (e) {\n            e.element && e.animate(c({\n              x: t.startXPos\n            }, e.startYPos ? {\n              x: e.startXPos,\n              y: e.startYPos\n            } : {}));\n          });\n        });\n      }\n      applyOptions(t, e) {\n        let i = this.series,\n          s = i.options.pointValKey || i.pointValKey;\n        return c(this, t = C.prototype.optionsToObject.call(this, t)), this.options = this.options ? c(this.options, t) : t, t.group && delete this.group, t.dataLabels && delete this.dataLabels, s && (this.y = C.prototype.getNestedProperty.call(this, s)), this.selected && (this.state = \"select\"), \"name\" in this && void 0 === e && i.xAxis && i.xAxis.hasNames && (this.x = i.xAxis.nameToX(this)), void 0 === this.x && i ? void 0 === e ? this.x = i.autoIncrement() : this.x = e : m(t.x) && i.options.relativeXValue && (this.x = i.autoIncrement(t.x)), this.isNull = this.isValid && !this.isValid(), this.formatPrefix = this.isNull ? \"null\" : \"point\", this;\n      }\n      destroy() {\n        if (!this.destroyed) {\n          let t = this,\n            e = t.series,\n            i = e.chart,\n            s = e.options.dataSorting,\n            o = i.hoverPoints,\n            n = t.series.chart.renderer.globalAnimation,\n            a = r(n),\n            h = () => {\n              for (let e in (t.graphic || t.graphics || t.dataLabel || t.dataLabels) && (S(t), t.destroyElements()), t) delete t[e];\n            };\n          t.legendItem && i.legend.destroyItem(t), o && (t.setState(), d(o, t), o.length || (i.hoverPoints = null)), t === i.hoverPoint && t.onMouseOut(), s && s.enabled ? (this.animateBeforeDestroy(), k(h, a.duration)) : h(), i.pointCount--;\n        }\n        this.destroyed = !0;\n      }\n      destroyElements(t) {\n        let e = this,\n          i = e.getGraphicalProps(t);\n        i.singular.forEach(function (t) {\n          e[t] = e[t].destroy();\n        }), i.plural.forEach(function (t) {\n          e[t].forEach(function (t) {\n            t && t.element && t.destroy();\n          }), delete e[t];\n        });\n      }\n      firePointEvent(t, e, i) {\n        let s = this,\n          o = this.series,\n          r = o.options;\n        (r.point.events[t] || s.options && s.options.events && s.options.events[t]) && s.importEvents(), \"click\" === t && r.allowPointSelect && (i = function (t) {\n          !s.destroyed && s.select && s.select(null, t.ctrlKey || t.metaKey || t.shiftKey);\n        }), p(s, t, e, i);\n      }\n      getClassName() {\n        return \"highcharts-point\" + (this.selected ? \" highcharts-point-select\" : \"\") + (this.negative ? \" highcharts-negative\" : \"\") + (this.isNull ? \" highcharts-null-point\" : \"\") + (void 0 !== this.colorIndex ? \" highcharts-color-\" + this.colorIndex : \"\") + (this.options.className ? \" \" + this.options.className : \"\") + (this.zone && this.zone.className ? \" \" + this.zone.className.replace(\"highcharts-negative\", \"\") : \"\");\n      }\n      getGraphicalProps(t) {\n        let e, i;\n        let s = this,\n          o = [],\n          r = {\n            singular: [],\n            plural: []\n          };\n        for ((t = t || {\n          graphic: 1,\n          dataLabel: 1\n        }).graphic && o.push(\"graphic\", \"connector\"), t.dataLabel && o.push(\"dataLabel\", \"dataLabelPath\", \"dataLabelUpper\"), i = o.length; i--;) s[e = o[i]] && r.singular.push(e);\n        return [\"graphic\", \"dataLabel\"].forEach(function (e) {\n          let i = e + \"s\";\n          t[e] && s[i] && r.plural.push(i);\n        }), r;\n      }\n      getLabelConfig() {\n        return {\n          x: this.category,\n          y: this.y,\n          color: this.color,\n          colorIndex: this.colorIndex,\n          key: this.name || this.category,\n          series: this.series,\n          point: this,\n          percentage: this.percentage,\n          total: this.total || this.stackTotal\n        };\n      }\n      getNestedProperty(t) {\n        return t ? 0 === t.indexOf(\"custom.\") ? u(t, this.options) : this[t] : void 0;\n      }\n      getZone() {\n        let t = this.series,\n          e = t.zones,\n          i = t.zoneAxis || \"y\",\n          s,\n          o = 0;\n        for (s = e[0]; this[i] >= s.value;) s = e[++o];\n        return this.nonZonedColor || (this.nonZonedColor = this.color), s && s.color && !this.options.color ? this.color = s.color : this.color = this.nonZonedColor, s;\n      }\n      hasNewShapeType() {\n        let t = this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName);\n        return t !== this.shapeType;\n      }\n      init(t, e, i) {\n        return this.series = t, this.applyOptions(e, i), this.id = l(this.id) ? this.id : M(), this.resolveColor(), t.chart.pointCount++, p(this, \"afterInit\"), this;\n      }\n      isValid() {\n        return (m(this.x) || this.x instanceof Date) && m(this.y);\n      }\n      optionsToObject(t) {\n        let e = this.series,\n          i = e.options.keys,\n          s = i || e.pointArrayMap || [\"y\"],\n          o = s.length,\n          r = {},\n          n,\n          a = 0,\n          h = 0;\n        if (m(t) || null === t) r[s[0]] = t;else if (g(t)) for (!i && t.length > o && (\"string\" == (n = typeof t[0]) ? r.name = t[0] : \"number\" === n && (r.x = t[0]), a++); h < o;) i && void 0 === t[a] || (s[h].indexOf(\".\") > 0 ? C.prototype.setNestedProperty(r, t[a], s[h]) : r[s[h]] = t[a]), a++, h++;else \"object\" == typeof t && (r = t, t.dataLabels && (e.hasDataLabels = () => !0), t.marker && (e._hasPointMarkers = !0));\n        return r;\n      }\n      pos(t, e = this.plotY) {\n        if (!this.destroyed) {\n          let {\n              plotX: i,\n              series: s\n            } = this,\n            {\n              chart: o,\n              xAxis: r,\n              yAxis: n\n            } = s,\n            a = 0,\n            h = 0;\n          if (m(i) && m(e)) return t && (a = r ? r.pos : o.plotLeft, h = n ? n.pos : o.plotTop), o.inverted && r && n ? [n.len - e + h, r.len - i + a] : [i + a, e + h];\n        }\n      }\n      resolveColor() {\n        let t = this.series,\n          e = t.chart.options.chart,\n          i = t.chart.styledMode,\n          s,\n          o,\n          r = e.colorCount,\n          n;\n        delete this.nonZonedColor, t.options.colorByPoint ? (i || (s = (o = t.options.colors || t.chart.options.colors)[t.colorCounter], r = o.length), n = t.colorCounter, t.colorCounter++, t.colorCounter === r && (t.colorCounter = 0)) : (i || (s = t.color), n = t.colorIndex), this.colorIndex = v(this.options.colorIndex, n), this.color = v(this.options.color, s);\n      }\n      setNestedProperty(t, e, i) {\n        let s = i.split(\".\");\n        return s.reduce(function (t, i, s, o) {\n          let r = o.length - 1 === s;\n          return t[i] = r ? e : x(t[i], !0) ? t[i] : {}, t[i];\n        }, t), t;\n      }\n      shouldDraw() {\n        return !this.isNull;\n      }\n      tooltipFormatter(t) {\n        let e = this.series,\n          i = e.tooltipOptions,\n          s = v(i.valueDecimals, \"\"),\n          o = i.valuePrefix || \"\",\n          r = i.valueSuffix || \"\";\n        return e.chart.styledMode && (t = e.chart.tooltip.styledModeFormat(t)), (e.pointArrayMap || [\"y\"]).forEach(function (e) {\n          e = \"{point.\" + e, (o || r) && (t = t.replace(RegExp(e + \"}\", \"g\"), o + e + \"}\" + r)), t = t.replace(RegExp(e + \"}\", \"g\"), e + \":,.\" + s + \"f}\");\n        }), a(t, {\n          point: this,\n          series: this.series\n        }, e.chart);\n      }\n      update(t, e, i, s) {\n        let o;\n        let r = this,\n          n = r.series,\n          a = r.graphic,\n          h = n.chart,\n          l = n.options;\n        function d() {\n          r.applyOptions(t);\n          let s = a && r.hasMockGraphic,\n            d = null === r.y ? !s : s;\n          a && d && (r.graphic = a.destroy(), delete r.hasMockGraphic), x(t, !0) && (a && a.element && t && t.marker && void 0 !== t.marker.symbol && (r.graphic = a.destroy()), t?.dataLabels && r.dataLabel && (r.dataLabel = r.dataLabel.destroy())), o = r.index, n.updateParallelArrays(r, o), l.data[o] = x(l.data[o], !0) || x(t, !0) ? r.options : v(t, l.data[o]), n.isDirty = n.isDirtyData = !0, !n.fixedBox && n.hasCartesianSeries && (h.isDirtyBox = !0), \"point\" === l.legendType && (h.isDirtyLegend = !0), e && h.redraw(i);\n        }\n        e = v(e, !0), !1 === s ? d() : r.firePointEvent(\"update\", {\n          options: t\n        }, d);\n      }\n      remove(t, e) {\n        this.series.removePoint(this.series.data.indexOf(this), t, e);\n      }\n      select(t, e) {\n        let i = this,\n          s = i.series,\n          o = s.chart;\n        t = v(t, !i.selected), this.selectedStaging = t, i.firePointEvent(t ? \"select\" : \"unselect\", {\n          accumulate: e\n        }, function () {\n          i.selected = i.options.selected = t, s.options.data[s.data.indexOf(i)] = i.options, i.setState(t && \"select\"), e || o.getSelectedPoints().forEach(function (t) {\n            let e = t.series;\n            t.selected && t !== i && (t.selected = t.options.selected = !1, e.options.data[e.data.indexOf(t)] = t.options, t.setState(o.hoverPoints && e.options.inactiveOtherPoints ? \"inactive\" : \"\"), t.firePointEvent(\"unselect\"));\n          });\n        }), delete this.selectedStaging;\n      }\n      onMouseOver(t) {\n        let e = this.series,\n          i = e.chart,\n          s = i.pointer;\n        t = t ? s.normalize(t) : s.getChartCoordinatesFromPoint(this, i.inverted), s.runPointActions(t, this);\n      }\n      onMouseOut() {\n        let t = this.series.chart;\n        this.firePointEvent(\"mouseOut\"), this.series.options.inactiveOtherPoints || (t.hoverPoints || []).forEach(function (t) {\n          t.setState();\n        }), t.hoverPoints = t.hoverPoint = null;\n      }\n      importEvents() {\n        if (!this.hasImportedEvents) {\n          let t = this,\n            e = y(t.series.options.point, t.options),\n            i = e.events;\n          t.events = i, b(i, function (e, i) {\n            f(e) && h(t, i, e);\n          }), this.hasImportedEvents = !0;\n        }\n      }\n      setState(e, i) {\n        let s = this.series,\n          o = this.state,\n          r = s.options.states[e || \"normal\"] || {},\n          a = n.plotOptions[s.type].marker && s.options.marker,\n          h = a && !1 === a.enabled,\n          l = a && a.states && a.states[e || \"normal\"] || {},\n          d = !1 === l.enabled,\n          u = this.marker || {},\n          g = s.chart,\n          f = a && s.markerAttribs,\n          x = s.halo,\n          y,\n          b,\n          k,\n          S = s.stateMarkerGraphic,\n          M;\n        if ((e = e || \"\") === this.state && !i || this.selected && \"select\" !== e || !1 === r.enabled || e && (d || h && !1 === l.enabled) || e && u.states && u.states[e] && !1 === u.states[e].enabled) return;\n        if (this.state = e, f && (y = s.markerAttribs(this, e)), this.graphic && !this.hasMockGraphic) {\n          if (o && this.graphic.removeClass(\"highcharts-point-\" + o), e && this.graphic.addClass(\"highcharts-point-\" + e), !g.styledMode) {\n            b = s.pointAttribs(this, e), k = v(g.options.chart.animation, r.animation);\n            let t = b.opacity;\n            s.options.inactiveOtherPoints && m(t) && (this.dataLabels || []).forEach(function (e) {\n              e && !e.hasClass(\"highcharts-data-label-hidden\") && (e.animate({\n                opacity: t\n              }, k), e.connector && e.connector.animate({\n                opacity: t\n              }, k));\n            }), this.graphic.animate(b, k);\n          }\n          y && this.graphic.animate(y, v(g.options.chart.animation, l.animation, a.animation)), S && S.hide();\n        } else e && l && (M = u.symbol || s.symbol, S && S.currentSymbol !== M && (S = S.destroy()), y && (S ? S[i ? \"animate\" : \"attr\"]({\n          x: y.x,\n          y: y.y\n        }) : M && (s.stateMarkerGraphic = S = g.renderer.symbol(M, y.x, y.y, y.width, y.height).add(s.markerGroup), S.currentSymbol = M)), !g.styledMode && S && \"inactive\" !== this.state && S.attr(s.pointAttribs(this, e))), S && (S[e && this.isInside ? \"show\" : \"hide\"](), S.element.point = this, S.addClass(this.getClassName(), !0));\n        let C = r.halo,\n          w = this.graphic || S,\n          T = w && w.visibility || \"inherit\";\n        C && C.size && w && \"hidden\" !== T && !this.isCluster ? (x || (s.halo = x = g.renderer.path().add(w.parentGroup)), x.show()[i ? \"animate\" : \"attr\"]({\n          d: this.haloPath(C.size)\n        }), x.attr({\n          class: \"highcharts-halo highcharts-color-\" + v(this.colorIndex, s.colorIndex) + (this.className ? \" \" + this.className : \"\"),\n          visibility: T,\n          zIndex: -1\n        }), x.point = this, g.styledMode || x.attr(c({\n          fill: this.color || s.color,\n          \"fill-opacity\": C.opacity\n        }, t.filterUserAttributes(C.attributes || {})))) : x && x.point && x.point.haloPath && x.animate({\n          d: x.point.haloPath(0)\n        }, null, x.hide), p(this, \"afterSetState\", {\n          state: e\n        });\n      }\n      haloPath(t) {\n        let e = this.pos();\n        return e ? this.series.chart.renderer.symbols.circle(Math.floor(e[0]) - t, e[1] - t, 2 * t, 2 * t) : [];\n      }\n    }\n    return C;\n  }), i(e, \"Core/Pointer.js\", [e[\"Core/Color/Color.js\"], e[\"Core/Globals.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    let {\n        parse: s\n      } = t,\n      {\n        charts: o,\n        noop: r\n      } = e,\n      {\n        addEvent: n,\n        attr: a,\n        css: h,\n        defined: l,\n        extend: d,\n        find: c,\n        fireEvent: p,\n        isNumber: u,\n        isObject: g,\n        objectEach: f,\n        offset: m,\n        pick: x,\n        splat: y\n      } = i;\n    class b {\n      constructor(t, e) {\n        this.lastValidTouch = {}, this.pinchDown = [], this.runChartClick = !1, this.eventsToUnbind = [], this.chart = t, this.hasDragged = !1, this.options = e, this.init(t, e);\n      }\n      applyInactiveState(t) {\n        let e = [],\n          i;\n        (t || []).forEach(function (t) {\n          i = t.series, e.push(i), i.linkedParent && e.push(i.linkedParent), i.linkedSeries && (e = e.concat(i.linkedSeries)), i.navigatorSeries && e.push(i.navigatorSeries);\n        }), this.chart.series.forEach(function (t) {\n          -1 === e.indexOf(t) ? t.setState(\"inactive\", !0) : t.options.inactiveOtherPoints && t.setAllPointsToState(\"inactive\");\n        });\n      }\n      destroy() {\n        let t = this;\n        this.eventsToUnbind.forEach(t => t()), this.eventsToUnbind = [], !e.chartCount && (b.unbindDocumentMouseUp && (b.unbindDocumentMouseUp = b.unbindDocumentMouseUp()), b.unbindDocumentTouchEnd && (b.unbindDocumentTouchEnd = b.unbindDocumentTouchEnd())), clearInterval(t.tooltipTimeout), f(t, function (e, i) {\n          t[i] = void 0;\n        });\n      }\n      getSelectionMarkerAttrs(t, e) {\n        let i = {\n          args: {\n            chartX: t,\n            chartY: e\n          },\n          attrs: {},\n          shapeType: \"rect\"\n        };\n        return p(this, \"getSelectionMarkerAttrs\", i, i => {\n          let s;\n          let {\n              chart: o,\n              mouseDownX: r = 0,\n              mouseDownY: n = 0,\n              zoomHor: a,\n              zoomVert: h\n            } = this,\n            l = i.attrs;\n          l.x = o.plotLeft, l.y = o.plotTop, l.width = a ? 1 : o.plotWidth, l.height = h ? 1 : o.plotHeight, a && (s = t - r, l.width = Math.abs(s), l.x = (s > 0 ? 0 : s) + r), h && (s = e - n, l.height = Math.abs(s), l.y = (s > 0 ? 0 : s) + n);\n        }), i;\n      }\n      drag(t) {\n        let e = this.chart,\n          i = e.options.chart,\n          o = e.plotLeft,\n          r = e.plotTop,\n          n = e.plotWidth,\n          a = e.plotHeight,\n          h = this.mouseDownX || 0,\n          l = this.mouseDownY || 0,\n          d = g(i.panning) ? i.panning && i.panning.enabled : i.panning,\n          c = i.panKey && t[i.panKey + \"Key\"],\n          p = t.chartX,\n          u = t.chartY,\n          f,\n          m = this.selectionMarker;\n        if ((!m || !m.touch) && (p < o ? p = o : p > o + n && (p = o + n), u < r ? u = r : u > r + a && (u = r + a), this.hasDragged = Math.sqrt(Math.pow(h - p, 2) + Math.pow(l - u, 2)), this.hasDragged > 10)) {\n          f = e.isInsidePlot(h - o, l - r, {\n            visiblePlotOnly: !0\n          });\n          let {\n            shapeType: n,\n            attrs: a\n          } = this.getSelectionMarkerAttrs(p, u);\n          (e.hasCartesianSeries || e.mapView) && (this.zoomX || this.zoomY) && f && !c && !m && (this.selectionMarker = m = e.renderer[n](), m.attr({\n            class: \"highcharts-selection-marker\",\n            zIndex: 7\n          }).add(), e.styledMode || m.attr({\n            fill: i.selectionMarkerFill || s(\"#334eff\").setOpacity(.25).get()\n          })), m && m.attr(a), f && !m && d && e.pan(t, i.panning);\n        }\n      }\n      dragStart(t) {\n        let e = this.chart;\n        e.mouseIsDown = t.type, e.cancelClick = !1, e.mouseDownX = this.mouseDownX = t.chartX, e.mouseDownY = this.mouseDownY = t.chartY;\n      }\n      getSelectionBox(t) {\n        let e = {\n          args: {\n            marker: t\n          },\n          result: {}\n        };\n        return p(this, \"getSelectionBox\", e, e => {\n          e.result = {\n            x: t.attr ? +t.attr(\"x\") : t.x,\n            y: t.attr ? +t.attr(\"y\") : t.y,\n            width: t.attr ? t.attr(\"width\") : t.width,\n            height: t.attr ? t.attr(\"height\") : t.height\n          };\n        }), e.result;\n      }\n      drop(t) {\n        let e = this,\n          i = this.chart,\n          s = this.hasPinched;\n        if (this.selectionMarker) {\n          let {\n              x: o,\n              y: r,\n              width: n,\n              height: a\n            } = this.getSelectionBox(this.selectionMarker),\n            h = {\n              originalEvent: t,\n              xAxis: [],\n              yAxis: [],\n              x: o,\n              y: r,\n              width: n,\n              height: a\n            },\n            c = !!i.mapView;\n          (this.hasDragged || s) && (i.axes.forEach(function (i) {\n            if (i.zoomEnabled && l(i.min) && (s || e[{\n              xAxis: \"zoomX\",\n              yAxis: \"zoomY\"\n            }[i.coll]]) && u(o) && u(r) && u(n) && u(a)) {\n              let e = i.horiz,\n                s = \"touchend\" === t.type ? i.minPixelPadding : 0,\n                l = i.toValue((e ? o : r) + s),\n                d = i.toValue((e ? o + n : r + a) - s);\n              h[i.coll].push({\n                axis: i,\n                min: Math.min(l, d),\n                max: Math.max(l, d)\n              }), c = !0;\n            }\n          }), c && p(i, \"selection\", h, function (t) {\n            i.zoom(d(t, s ? {\n              animation: !1\n            } : null));\n          })), u(i.index) && (this.selectionMarker = this.selectionMarker.destroy()), s && this.scaleGroups();\n        }\n        i && u(i.index) && (h(i.container, {\n          cursor: i._cursor\n        }), i.cancelClick = +this.hasDragged > 10, i.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = []);\n      }\n      findNearestKDPoint(t, e, i) {\n        let s;\n        return t.forEach(function (t) {\n          let o = t.noSharedTooltip && e,\n            r = !o && 0 > t.options.findNearestPointBy.indexOf(\"y\"),\n            n = t.searchPoint(i, r);\n          g(n, !0) && n.series && (!g(s, !0) || function (t, i) {\n            let s = t.distX - i.distX,\n              o = t.dist - i.dist,\n              r = (i.series.group && i.series.group.zIndex) - (t.series.group && t.series.group.zIndex);\n            return 0 !== s && e ? s : 0 !== o ? o : 0 !== r ? r : t.series.index > i.series.index ? -1 : 1;\n          }(s, n) > 0) && (s = n);\n        }), s;\n      }\n      getChartCoordinatesFromPoint(t, e) {\n        let i = t.series,\n          s = i.xAxis,\n          o = i.yAxis,\n          r = t.shapeArgs;\n        if (s && o) {\n          let i = x(t.clientX, t.plotX),\n            n = t.plotY || 0;\n          return t.isNode && r && u(r.x) && u(r.y) && (i = r.x, n = r.y), e ? {\n            chartX: o.len + o.pos - n,\n            chartY: s.len + s.pos - i\n          } : {\n            chartX: i + s.pos,\n            chartY: n + o.pos\n          };\n        }\n        if (r && r.x && r.y) return {\n          chartX: r.x,\n          chartY: r.y\n        };\n      }\n      getChartPosition() {\n        if (this.chartPosition) return this.chartPosition;\n        let {\n            container: t\n          } = this.chart,\n          e = m(t);\n        this.chartPosition = {\n          left: e.left,\n          top: e.top,\n          scaleX: 1,\n          scaleY: 1\n        };\n        let i = t.offsetWidth,\n          s = t.offsetHeight;\n        return i > 2 && s > 2 && (this.chartPosition.scaleX = e.width / i, this.chartPosition.scaleY = e.height / s), this.chartPosition;\n      }\n      getCoordinates(t) {\n        let e = {\n          xAxis: [],\n          yAxis: []\n        };\n        return this.chart.axes.forEach(function (i) {\n          e[i.isXAxis ? \"xAxis\" : \"yAxis\"].push({\n            axis: i,\n            value: i.toValue(t[i.horiz ? \"chartX\" : \"chartY\"])\n          });\n        }), e;\n      }\n      getHoverData(t, e, i, s, o, r) {\n        let n = [],\n          a = function (t) {\n            return t.visible && !(!o && t.directTouch) && x(t.options.enableMouseTracking, !0);\n          },\n          h = e,\n          l,\n          d = {\n            chartX: r ? r.chartX : void 0,\n            chartY: r ? r.chartY : void 0,\n            shared: o\n          };\n        p(this, \"beforeGetHoverData\", d);\n        let u = h && !h.stickyTracking;\n        l = u ? [h] : i.filter(t => t.stickyTracking && (d.filter || a)(t));\n        let f = s && t || !r ? t : this.findNearestKDPoint(l, o, r);\n        return h = f && f.series, f && (o && !h.noSharedTooltip ? (l = i.filter(function (t) {\n          return d.filter ? d.filter(t) : a(t) && !t.noSharedTooltip;\n        })).forEach(function (t) {\n          let e = c(t.points, function (t) {\n            return t.x === f.x && !t.isNull;\n          });\n          g(e) && (t.boosted && t.boost && (e = t.boost.getPoint(e)), n.push(e));\n        }) : n.push(f)), p(this, \"afterGetHoverData\", d = {\n          hoverPoint: f\n        }), {\n          hoverPoint: d.hoverPoint,\n          hoverSeries: h,\n          hoverPoints: n\n        };\n      }\n      getPointFromEvent(t) {\n        let e = t.target,\n          i;\n        for (; e && !i;) i = e.point, e = e.parentNode;\n        return i;\n      }\n      onTrackerMouseOut(t) {\n        let e = this.chart,\n          i = t.relatedTarget,\n          s = e.hoverSeries;\n        this.isDirectTouch = !1, !s || !i || s.stickyTracking || this.inClass(i, \"highcharts-tooltip\") || this.inClass(i, \"highcharts-series-\" + s.index) && this.inClass(i, \"highcharts-tracker\") || s.onMouseOut();\n      }\n      inClass(t, e) {\n        let i = t,\n          s;\n        for (; i;) {\n          if (s = a(i, \"class\")) {\n            if (-1 !== s.indexOf(e)) return !0;\n            if (-1 !== s.indexOf(\"highcharts-container\")) return !1;\n          }\n          i = i.parentElement;\n        }\n      }\n      init(t, e) {\n        this.options = e, this.chart = t, this.runChartClick = !!(e.chart.events && e.chart.events.click), this.pinchDown = [], this.lastValidTouch = {}, this.setDOMEvents(), p(this, \"afterInit\");\n      }\n      normalize(t, e) {\n        let i = t.touches,\n          s = i ? i.length ? i.item(0) : x(i.changedTouches, t.changedTouches)[0] : t;\n        e || (e = this.getChartPosition());\n        let o = s.pageX - e.left,\n          r = s.pageY - e.top;\n        return d(t, {\n          chartX: Math.round(o /= e.scaleX),\n          chartY: Math.round(r /= e.scaleY)\n        });\n      }\n      onContainerClick(t) {\n        let e = this.chart,\n          i = e.hoverPoint,\n          s = this.normalize(t),\n          o = e.plotLeft,\n          r = e.plotTop;\n        !e.cancelClick && (i && this.inClass(s.target, \"highcharts-tracker\") ? (p(i.series, \"click\", d(s, {\n          point: i\n        })), e.hoverPoint && i.firePointEvent(\"click\", s)) : (d(s, this.getCoordinates(s)), e.isInsidePlot(s.chartX - o, s.chartY - r, {\n          visiblePlotOnly: !0\n        }) && p(e, \"click\", s)));\n      }\n      onContainerMouseDown(t) {\n        let i = (1 & (t.buttons || t.button)) == 1;\n        t = this.normalize(t), e.isFirefox && 0 !== t.button && this.onContainerMouseMove(t), (void 0 === t.button || i) && (this.zoomOption(t), i && t.preventDefault && t.preventDefault(), this.dragStart(t));\n      }\n      onContainerMouseLeave(t) {\n        let e = o[x(b.hoverChartIndex, -1)];\n        t = this.normalize(t), this.onContainerMouseMove(t), e && t.relatedTarget && !this.inClass(t.relatedTarget, \"highcharts-tooltip\") && (e.pointer.reset(), e.pointer.chartPosition = void 0);\n      }\n      onContainerMouseEnter(t) {\n        delete this.chartPosition;\n      }\n      onContainerMouseMove(t) {\n        let e = this.chart,\n          i = e.tooltip,\n          s = this.normalize(t);\n        this.setHoverChartIndex(t), (\"mousedown\" === e.mouseIsDown || this.touchSelect(s)) && this.drag(s), !e.openMenu && (this.inClass(s.target, \"highcharts-tracker\") || e.isInsidePlot(s.chartX - e.plotLeft, s.chartY - e.plotTop, {\n          visiblePlotOnly: !0\n        })) && !(i && i.shouldStickOnContact(s)) && (this.inClass(s.target, \"highcharts-no-tooltip\") ? this.reset(!1, 0) : this.runPointActions(s));\n      }\n      onDocumentTouchEnd(t) {\n        let e = o[x(b.hoverChartIndex, -1)];\n        e && e.pointer.drop(t);\n      }\n      onContainerTouchMove(t) {\n        this.touchSelect(t) ? this.onContainerMouseMove(t) : this.touch(t);\n      }\n      onContainerTouchStart(t) {\n        this.touchSelect(t) ? this.onContainerMouseDown(t) : (this.zoomOption(t), this.touch(t, !0));\n      }\n      onDocumentMouseMove(t) {\n        let e = this.chart,\n          i = e.tooltip,\n          s = this.chartPosition,\n          o = this.normalize(t, s);\n        !s || e.isInsidePlot(o.chartX - e.plotLeft, o.chartY - e.plotTop, {\n          visiblePlotOnly: !0\n        }) || i && i.shouldStickOnContact(o) || this.inClass(o.target, \"highcharts-tracker\") || this.reset();\n      }\n      onDocumentMouseUp(t) {\n        let e = o[x(b.hoverChartIndex, -1)];\n        e && e.pointer.drop(t);\n      }\n      pinch(t) {\n        let e = this,\n          i = e.chart,\n          s = e.pinchDown,\n          o = t.touches || [],\n          n = o.length,\n          a = e.lastValidTouch,\n          h = e.hasZoom,\n          l = {},\n          c = 1 === n && (e.inClass(t.target, \"highcharts-tracker\") && i.runTrackerClick || e.runChartClick),\n          u = {},\n          g = e.chart.tooltip,\n          f = 1 === n && x(g && g.options.followTouchMove, !0),\n          m = e.selectionMarker;\n        n > 1 ? e.initiated = !0 : f && (e.initiated = !1), h && e.initiated && !c && !1 !== t.cancelable && t.preventDefault(), [].map.call(o, function (t) {\n          return e.normalize(t);\n        }), \"touchstart\" === t.type ? ([].forEach.call(o, function (t, e) {\n          s[e] = {\n            chartX: t.chartX,\n            chartY: t.chartY\n          };\n        }), a.x = [s[0].chartX, s[1] && s[1].chartX], a.y = [s[0].chartY, s[1] && s[1].chartY], i.axes.forEach(function (t) {\n          if (t.zoomEnabled) {\n            let e = i.bounds[t.horiz ? \"h\" : \"v\"],\n              s = t.minPixelPadding,\n              o = t.toPixels(Math.min(x(t.options.min, t.dataMin), t.dataMin)),\n              r = t.toPixels(Math.max(x(t.options.max, t.dataMax), t.dataMax)),\n              n = Math.min(o, r),\n              a = Math.max(o, r);\n            e.min = Math.min(t.pos, n - s), e.max = Math.max(t.pos + t.len, a + s);\n          }\n        }), e.res = !0) : f ? this.runPointActions(e.normalize(t)) : s.length && (p(i, \"touchpan\", {\n          originalEvent: t\n        }, () => {\n          m || (e.selectionMarker = m = d({\n            destroy: r,\n            touch: !0\n          }, i.plotBox)), e.pinchTranslate(s, o, l, m, u, a), e.hasPinched = h, e.scaleGroups(l, u);\n        }), e.res && (e.res = !1, this.reset(!1, 0)));\n      }\n      pinchTranslate(t, e, i, s, o, r) {\n        this.zoomHor && this.pinchTranslateDirection(!0, t, e, i, s, o, r), this.zoomVert && this.pinchTranslateDirection(!1, t, e, i, s, o, r);\n      }\n      pinchTranslateDirection(t, e, i, s, o, r, n, a) {\n        let h = this.chart,\n          l = t ? \"x\" : \"y\",\n          d = t ? \"X\" : \"Y\",\n          c = \"chart\" + d,\n          p = t ? \"width\" : \"height\",\n          u = h[\"plot\" + (t ? \"Left\" : \"Top\")],\n          g = h.inverted,\n          f = h.bounds[t ? \"h\" : \"v\"],\n          m = 1 === e.length,\n          x = e[0][c],\n          y = !m && e[1][c],\n          b = function () {\n            \"number\" == typeof w && Math.abs(x - y) > 20 && (M = a || Math.abs(C - w) / Math.abs(x - y)), S = (u - C) / M + x, v = h[\"plot\" + (t ? \"Width\" : \"Height\")] / M;\n          },\n          v,\n          k,\n          S,\n          M = a || 1,\n          C = i[0][c],\n          w = !m && i[1][c],\n          T;\n        b(), (k = S) < f.min ? (k = f.min, T = !0) : k + v > f.max && (k = f.max - v, T = !0), T ? (C -= .8 * (C - n[l][0]), \"number\" == typeof w && (w -= .8 * (w - n[l][1])), b()) : n[l] = [C, w], g || (r[l] = S - u, r[p] = v);\n        let A = g ? t ? \"scaleY\" : \"scaleX\" : \"scale\" + d,\n          P = g ? 1 / M : M;\n        o[p] = v, o[l] = k, s[A] = M * (g && !t ? -1 : 1), s[\"translate\" + d] = P * u + (C - P * x);\n      }\n      reset(t, e) {\n        let i = this.chart,\n          s = i.hoverSeries,\n          o = i.hoverPoint,\n          r = i.hoverPoints,\n          n = i.tooltip,\n          a = n && n.shared ? r : o;\n        t && a && y(a).forEach(function (e) {\n          e.series.isCartesian && void 0 === e.plotX && (t = !1);\n        }), t ? n && a && y(a).length && (n.refresh(a), n.shared && r ? r.forEach(function (t) {\n          t.setState(t.state, !0), t.series.isCartesian && (t.series.xAxis.crosshair && t.series.xAxis.drawCrosshair(null, t), t.series.yAxis.crosshair && t.series.yAxis.drawCrosshair(null, t));\n        }) : o && (o.setState(o.state, !0), i.axes.forEach(function (t) {\n          t.crosshair && o.series[t.coll] === t && t.drawCrosshair(null, o);\n        }))) : (o && o.onMouseOut(), r && r.forEach(function (t) {\n          t.setState();\n        }), s && s.onMouseOut(), n && n.hide(e), this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove()), i.axes.forEach(function (t) {\n          t.hideCrosshair();\n        }), this.hoverX = i.hoverPoints = i.hoverPoint = null);\n      }\n      runPointActions(t, e, i) {\n        let s = this.chart,\n          r = s.series,\n          a = s.tooltip && s.tooltip.options.enabled ? s.tooltip : void 0,\n          h = !!a && a.shared,\n          l = e || s.hoverPoint,\n          d = l && l.series || s.hoverSeries,\n          p = (!t || \"touchmove\" !== t.type) && (!!e || d && d.directTouch && this.isDirectTouch),\n          u = this.getHoverData(l, d, r, p, h, t);\n        l = u.hoverPoint, d = u.hoverSeries;\n        let g = u.hoverPoints,\n          f = d && d.tooltipOptions.followPointer && !d.tooltipOptions.split,\n          m = h && d && !d.noSharedTooltip;\n        if (l && (i || l !== s.hoverPoint || a && a.isHidden)) {\n          if ((s.hoverPoints || []).forEach(function (t) {\n            -1 === g.indexOf(t) && t.setState();\n          }), s.hoverSeries !== d && d.onMouseOver(), this.applyInactiveState(g), (g || []).forEach(function (t) {\n            t.setState(\"hover\");\n          }), s.hoverPoint && s.hoverPoint.firePointEvent(\"mouseOut\"), !l.series) return;\n          s.hoverPoints = g, s.hoverPoint = l, l.firePointEvent(\"mouseOver\", void 0, () => {\n            a && l && a.refresh(m ? g : l, t);\n          });\n        } else if (f && a && !a.isHidden) {\n          let e = a.getAnchor([{}], t);\n          s.isInsidePlot(e[0], e[1], {\n            visiblePlotOnly: !0\n          }) && a.updatePosition({\n            plotX: e[0],\n            plotY: e[1]\n          });\n        }\n        this.unDocMouseMove || (this.unDocMouseMove = n(s.container.ownerDocument, \"mousemove\", function (t) {\n          let e = o[b.hoverChartIndex];\n          e && e.pointer.onDocumentMouseMove(t);\n        }), this.eventsToUnbind.push(this.unDocMouseMove)), s.axes.forEach(function (e) {\n          let i;\n          let o = x((e.crosshair || {}).snap, !0);\n          !o || (i = s.hoverPoint) && i.series[e.coll] === e || (i = c(g, t => t.series && t.series[e.coll] === e)), i || !o ? e.drawCrosshair(t, i) : e.hideCrosshair();\n        });\n      }\n      scaleGroups(t, e) {\n        let i = this.chart;\n        i.series.forEach(function (s) {\n          let o = t || s.getPlotBox(\"series\");\n          s.group && (s.xAxis && s.xAxis.zoomEnabled || i.mapView) && (s.group.attr(o), s.markerGroup && (s.markerGroup.attr(t || s.getPlotBox(\"marker\")), s.markerGroup.clip(e ? i.clipRect : null)), s.dataLabelsGroup && s.dataLabelsGroup.attr(o));\n        }), i.clipRect.attr(e || i.clipBox);\n      }\n      setDOMEvents() {\n        let t = this.chart.container,\n          i = t.ownerDocument;\n        t.onmousedown = this.onContainerMouseDown.bind(this), t.onmousemove = this.onContainerMouseMove.bind(this), t.onclick = this.onContainerClick.bind(this), this.eventsToUnbind.push(n(t, \"mouseenter\", this.onContainerMouseEnter.bind(this))), this.eventsToUnbind.push(n(t, \"mouseleave\", this.onContainerMouseLeave.bind(this))), b.unbindDocumentMouseUp || (b.unbindDocumentMouseUp = n(i, \"mouseup\", this.onDocumentMouseUp.bind(this)));\n        let s = this.chart.renderTo.parentElement;\n        for (; s && \"BODY\" !== s.tagName;) this.eventsToUnbind.push(n(s, \"scroll\", () => {\n          delete this.chartPosition;\n        })), s = s.parentElement;\n        e.hasTouch && (this.eventsToUnbind.push(n(t, \"touchstart\", this.onContainerTouchStart.bind(this), {\n          passive: !1\n        })), this.eventsToUnbind.push(n(t, \"touchmove\", this.onContainerTouchMove.bind(this), {\n          passive: !1\n        })), b.unbindDocumentTouchEnd || (b.unbindDocumentTouchEnd = n(i, \"touchend\", this.onDocumentTouchEnd.bind(this), {\n          passive: !1\n        })));\n      }\n      setHoverChartIndex(t) {\n        let i = this.chart,\n          s = e.charts[x(b.hoverChartIndex, -1)];\n        s && s !== i && s.pointer.onContainerMouseLeave(t || {\n          relatedTarget: i.container\n        }), s && s.mouseIsDown || (b.hoverChartIndex = i.index);\n      }\n      touch(t, e) {\n        let i, s;\n        let o = this.chart;\n        this.setHoverChartIndex(), 1 === t.touches.length ? (t = this.normalize(t), o.isInsidePlot(t.chartX - o.plotLeft, t.chartY - o.plotTop, {\n          visiblePlotOnly: !0\n        }) && !o.openMenu ? (e && this.runPointActions(t), \"touchmove\" === t.type && (i = !!(s = this.pinchDown)[0] && Math.sqrt(Math.pow(s[0].chartX - t.chartX, 2) + Math.pow(s[0].chartY - t.chartY, 2)) >= 4), x(i, !0) && this.pinch(t)) : e && this.reset()) : 2 === t.touches.length && this.pinch(t);\n      }\n      touchSelect(t) {\n        return !!(this.chart.zooming.singleTouch && t.touches && 1 === t.touches.length);\n      }\n      zoomOption(t) {\n        let e = this.chart,\n          i = (e.options.chart, e.inverted),\n          s = e.zooming.type || \"\",\n          o,\n          r;\n        /touch/.test(t.type) && (s = x(e.zooming.pinchType, s)), this.zoomX = o = /x/.test(s), this.zoomY = r = /y/.test(s), this.zoomHor = o && !i || r && i, this.zoomVert = r && !i || o && i, this.hasZoom = o || r;\n      }\n    }\n    return function (t) {\n      let e = [],\n        s = [];\n      t.compose = function (e) {\n        i.pushUnique(s, e) && n(e, \"beforeRender\", function () {\n          this.pointer = new t(this, this.options);\n        });\n      }, t.dissolve = function () {\n        for (let t = 0, i = e.length; t < i; ++t) e[t]();\n        e.length = 0;\n      };\n    }(b || (b = {})), b;\n  }), i(e, \"Core/Legend/Legend.js\", [e[\"Core/Animation/AnimationUtilities.js\"], e[\"Core/Templating.js\"], e[\"Core/Globals.js\"], e[\"Core/Series/Point.js\"], e[\"Core/Renderer/RendererUtilities.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s, o, r) {\n    let {\n        animObject: n,\n        setAnimation: a\n      } = t,\n      {\n        format: h\n      } = e,\n      {\n        marginNames: l\n      } = i,\n      {\n        distribute: d\n      } = o,\n      {\n        addEvent: c,\n        createElement: p,\n        css: u,\n        defined: g,\n        discardElement: f,\n        find: m,\n        fireEvent: x,\n        isNumber: y,\n        merge: b,\n        pick: v,\n        relativeLength: k,\n        stableSort: S,\n        syncTimeout: M\n      } = r;\n    class C {\n      constructor(t, e) {\n        this.allItems = [], this.box = void 0, this.contentGroup = void 0, this.display = !1, this.group = void 0, this.initialItemY = 0, this.itemHeight = 0, this.itemMarginBottom = 0, this.itemMarginTop = 0, this.itemX = 0, this.itemY = 0, this.lastItemY = 0, this.lastLineHeight = 0, this.legendHeight = 0, this.legendWidth = 0, this.maxItemWidth = 0, this.maxLegendWidth = 0, this.offsetWidth = 0, this.options = void 0, this.padding = 0, this.pages = [], this.proximate = !1, this.scrollGroup = void 0, this.symbolHeight = 0, this.symbolWidth = 0, this.titleHeight = 0, this.totalItemWidth = 0, this.widthOption = 0, this.chart = t, this.init(t, e);\n      }\n      init(t, e) {\n        this.chart = t, this.setOptions(e), e.enabled && (this.render(), c(this.chart, \"endResize\", function () {\n          this.legend.positionCheckboxes();\n        })), c(this.chart, \"render\", () => {\n          this.options.enabled && this.proximate && (this.proximatePositions(), this.positionItems());\n        });\n      }\n      setOptions(t) {\n        let e = v(t.padding, 8);\n        this.options = t, this.chart.styledMode || (this.itemStyle = t.itemStyle, this.itemHiddenStyle = b(this.itemStyle, t.itemHiddenStyle)), this.itemMarginTop = t.itemMarginTop, this.itemMarginBottom = t.itemMarginBottom, this.padding = e, this.initialItemY = e - 5, this.symbolWidth = v(t.symbolWidth, 16), this.pages = [], this.proximate = \"proximate\" === t.layout && !this.chart.inverted, this.baseline = void 0;\n      }\n      update(t, e) {\n        let i = this.chart;\n        this.setOptions(b(!0, this.options, t)), this.destroy(), i.isDirtyLegend = i.isDirtyBox = !0, v(e, !0) && i.redraw(), x(this, \"afterUpdate\", {\n          redraw: e\n        });\n      }\n      colorizeItem(t, e) {\n        let {\n          group: i,\n          label: s,\n          line: o,\n          symbol: r\n        } = t.legendItem || {};\n        if (i && i[e ? \"removeClass\" : \"addClass\"](\"highcharts-legend-item-hidden\"), !this.chart.styledMode) {\n          let {\n              itemHiddenStyle: i\n            } = this,\n            n = i.color,\n            a = e && t.color || n,\n            h = t.options && t.options.marker,\n            l = {\n              fill: a\n            };\n          s?.css(b(e ? this.itemStyle : i)), o?.attr({\n            stroke: a\n          }), r && (h && r.isMarker && (l = t.pointAttribs(), e || (l.stroke = l.fill = n)), r.attr(l));\n        }\n        x(this, \"afterColorizeItem\", {\n          item: t,\n          visible: e\n        });\n      }\n      positionItems() {\n        this.allItems.forEach(this.positionItem, this), this.chart.isResizing || this.positionCheckboxes();\n      }\n      positionItem(t) {\n        let {\n            group: e,\n            x: i = 0,\n            y: s = 0\n          } = t.legendItem || {},\n          o = this.options,\n          r = o.symbolPadding,\n          n = !o.rtl,\n          a = t.checkbox;\n        if (e && e.element) {\n          let o = {\n            translateX: n ? i : this.legendWidth - i - 2 * r - 4,\n            translateY: s\n          };\n          e[g(e.translateY) ? \"animate\" : \"attr\"](o, void 0, () => {\n            x(this, \"afterPositionItem\", {\n              item: t\n            });\n          });\n        }\n        a && (a.x = i, a.y = s);\n      }\n      destroyItem(t) {\n        let e = t.checkbox,\n          i = t.legendItem || {};\n        for (let t of [\"group\", \"label\", \"line\", \"symbol\"]) i[t] && (i[t] = i[t].destroy());\n        e && f(e), t.legendItem = void 0;\n      }\n      destroy() {\n        for (let t of this.getAllItems()) this.destroyItem(t);\n        for (let t of [\"clipRect\", \"up\", \"down\", \"pager\", \"nav\", \"box\", \"title\", \"group\"]) this[t] && (this[t] = this[t].destroy());\n        this.display = null;\n      }\n      positionCheckboxes() {\n        let t;\n        let e = this.group && this.group.alignAttr,\n          i = this.clipHeight || this.legendHeight,\n          s = this.titleHeight;\n        e && (t = e.translateY, this.allItems.forEach(function (o) {\n          let r;\n          let n = o.checkbox;\n          n && (r = t + s + n.y + (this.scrollOffset || 0) + 3, u(n, {\n            left: e.translateX + o.checkboxOffset + n.x - 20 + \"px\",\n            top: r + \"px\",\n            display: this.proximate || r > t - 6 && r < t + i - 6 ? \"\" : \"none\"\n          }));\n        }, this));\n      }\n      renderTitle() {\n        let t = this.options,\n          e = this.padding,\n          i = t.title,\n          s,\n          o = 0;\n        i.text && (this.title || (this.title = this.chart.renderer.label(i.text, e - 3, e - 4, void 0, void 0, void 0, t.useHTML, void 0, \"legend-title\").attr({\n          zIndex: 1\n        }), this.chart.styledMode || this.title.css(i.style), this.title.add(this.group)), i.width || this.title.css({\n          width: this.maxLegendWidth + \"px\"\n        }), o = (s = this.title.getBBox()).height, this.offsetWidth = s.width, this.contentGroup.attr({\n          translateY: o\n        })), this.titleHeight = o;\n      }\n      setText(t) {\n        let e = this.options;\n        t.legendItem.label.attr({\n          text: e.labelFormat ? h(e.labelFormat, t, this.chart) : e.labelFormatter.call(t)\n        });\n      }\n      renderItem(t) {\n        let e = t.legendItem = t.legendItem || {},\n          i = this.chart,\n          s = i.renderer,\n          o = this.options,\n          r = \"horizontal\" === o.layout,\n          n = this.symbolWidth,\n          a = o.symbolPadding || 0,\n          h = this.itemStyle,\n          l = this.itemHiddenStyle,\n          d = r ? v(o.itemDistance, 20) : 0,\n          c = !o.rtl,\n          p = !t.series,\n          u = !p && t.series.drawLegendSymbol ? t.series : t,\n          g = u.options,\n          f = !!this.createCheckboxForItem && g && g.showCheckbox,\n          m = o.useHTML,\n          x = t.options.className,\n          y = e.label,\n          k = n + a + d + (f ? 20 : 0);\n        !y && (e.group = s.g(\"legend-item\").addClass(\"highcharts-\" + u.type + \"-series highcharts-color-\" + t.colorIndex + (x ? \" \" + x : \"\") + (p ? \" highcharts-series-\" + t.index : \"\")).attr({\n          zIndex: 1\n        }).add(this.scrollGroup), e.label = y = s.text(\"\", c ? n + a : -a, this.baseline || 0, m), i.styledMode || y.css(b(t.visible ? h : l)), y.attr({\n          align: c ? \"left\" : \"right\",\n          zIndex: 2\n        }).add(e.group), !this.baseline && (this.fontMetrics = s.fontMetrics(y), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, y.attr(\"y\", this.baseline), this.symbolHeight = v(o.symbolHeight, this.fontMetrics.f), o.squareSymbol && (this.symbolWidth = v(o.symbolWidth, Math.max(this.symbolHeight, 16)), k = this.symbolWidth + a + d + (f ? 20 : 0), c && y.attr(\"x\", this.symbolWidth + a))), u.drawLegendSymbol(this, t), this.setItemEvents && this.setItemEvents(t, y, m)), f && !t.checkbox && this.createCheckboxForItem && this.createCheckboxForItem(t), this.colorizeItem(t, t.visible), (i.styledMode || !h.width) && y.css({\n          width: (o.itemWidth || this.widthOption || i.spacingBox.width) - k + \"px\"\n        }), this.setText(t);\n        let S = y.getBBox(),\n          M = this.fontMetrics && this.fontMetrics.h || 0;\n        t.itemWidth = t.checkboxOffset = o.itemWidth || e.labelWidth || S.width + k, this.maxItemWidth = Math.max(this.maxItemWidth, t.itemWidth), this.totalItemWidth += t.itemWidth, this.itemHeight = t.itemHeight = Math.round(e.labelHeight || (S.height > 1.5 * M ? S.height : M));\n      }\n      layoutItem(t) {\n        let e = this.options,\n          i = this.padding,\n          s = \"horizontal\" === e.layout,\n          o = t.itemHeight,\n          r = this.itemMarginBottom,\n          n = this.itemMarginTop,\n          a = s ? v(e.itemDistance, 20) : 0,\n          h = this.maxLegendWidth,\n          l = e.alignColumns && this.totalItemWidth > h ? this.maxItemWidth : t.itemWidth,\n          d = t.legendItem || {};\n        s && this.itemX - i + l > h && (this.itemX = i, this.lastLineHeight && (this.itemY += n + this.lastLineHeight + r), this.lastLineHeight = 0), this.lastItemY = n + this.itemY + r, this.lastLineHeight = Math.max(o, this.lastLineHeight), d.x = this.itemX, d.y = this.itemY, s ? this.itemX += l : (this.itemY += n + o + r, this.lastLineHeight = o), this.offsetWidth = this.widthOption || Math.max((s ? this.itemX - i - (t.checkbox ? 0 : a) : l) + i, this.offsetWidth);\n      }\n      getAllItems() {\n        let t = [];\n        return this.chart.series.forEach(function (e) {\n          let i = e && e.options;\n          e && v(i.showInLegend, !g(i.linkedTo) && void 0, !0) && (t = t.concat((e.legendItem || {}).labels || (\"point\" === i.legendType ? e.data : e)));\n        }), x(this, \"afterGetAllItems\", {\n          allItems: t\n        }), t;\n      }\n      getAlignment() {\n        let t = this.options;\n        return this.proximate ? t.align.charAt(0) + \"tv\" : t.floating ? \"\" : t.align.charAt(0) + t.verticalAlign.charAt(0) + t.layout.charAt(0);\n      }\n      adjustMargins(t, e) {\n        let i = this.chart,\n          s = this.options,\n          o = this.getAlignment();\n        o && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function (r, n) {\n          r.test(o) && !g(t[n]) && (i[l[n]] = Math.max(i[l[n]], i.legend[(n + 1) % 2 ? \"legendHeight\" : \"legendWidth\"] + [1, -1, -1, 1][n] * s[n % 2 ? \"x\" : \"y\"] + v(s.margin, 12) + e[n] + (i.titleOffset[n] || 0)));\n        });\n      }\n      proximatePositions() {\n        let t;\n        let e = this.chart,\n          i = [],\n          s = \"left\" === this.options.align;\n        for (let o of (this.allItems.forEach(function (t) {\n          let o,\n            r,\n            n = s,\n            a,\n            h;\n          t.yAxis && (t.xAxis.options.reversed && (n = !n), t.points && (o = m(n ? t.points : t.points.slice(0).reverse(), function (t) {\n            return y(t.plotY);\n          })), r = this.itemMarginTop + t.legendItem.label.getBBox().height + this.itemMarginBottom, h = t.yAxis.top - e.plotTop, a = t.visible ? (o ? o.plotY : t.yAxis.height) + (h - .3 * r) : h + t.yAxis.height, i.push({\n            target: a,\n            size: r,\n            item: t\n          }));\n        }, this), d(i, e.plotHeight))) t = o.item.legendItem || {}, y(o.pos) && (t.y = e.plotTop - e.spacing[0] + o.pos);\n      }\n      render() {\n        let t = this.chart,\n          e = t.renderer,\n          i = this.options,\n          s = this.padding,\n          o = this.getAllItems(),\n          r,\n          n,\n          a,\n          h = this.group,\n          l,\n          d = this.box;\n        this.itemX = s, this.itemY = this.initialItemY, this.offsetWidth = 0, this.lastItemY = 0, this.widthOption = k(i.width, t.spacingBox.width - s), l = t.spacingBox.width - 2 * s - i.x, [\"rm\", \"lm\"].indexOf(this.getAlignment().substring(0, 2)) > -1 && (l /= 2), this.maxLegendWidth = this.widthOption || l, h || (this.group = h = e.g(\"legend\").addClass(i.className || \"\").attr({\n          zIndex: 7\n        }).add(), this.contentGroup = e.g().attr({\n          zIndex: 1\n        }).add(h), this.scrollGroup = e.g().add(this.contentGroup)), this.renderTitle(), S(o, (t, e) => (t.options && t.options.legendIndex || 0) - (e.options && e.options.legendIndex || 0)), i.reversed && o.reverse(), this.allItems = o, this.display = r = !!o.length, this.lastLineHeight = 0, this.maxItemWidth = 0, this.totalItemWidth = 0, this.itemHeight = 0, o.forEach(this.renderItem, this), o.forEach(this.layoutItem, this), n = (this.widthOption || this.offsetWidth) + s, a = this.lastItemY + this.lastLineHeight + this.titleHeight, a = this.handleOverflow(a) + s, d || (this.box = d = e.rect().addClass(\"highcharts-legend-box\").attr({\n          r: i.borderRadius\n        }).add(h)), t.styledMode || d.attr({\n          stroke: i.borderColor,\n          \"stroke-width\": i.borderWidth || 0,\n          fill: i.backgroundColor || \"none\"\n        }).shadow(i.shadow), n > 0 && a > 0 && d[d.placed ? \"animate\" : \"attr\"](d.crisp.call({}, {\n          x: 0,\n          y: 0,\n          width: n,\n          height: a\n        }, d.strokeWidth())), h[r ? \"show\" : \"hide\"](), t.styledMode && \"none\" === h.getStyle(\"display\") && (n = a = 0), this.legendWidth = n, this.legendHeight = a, r && this.align(), this.proximate || this.positionItems(), x(this, \"afterRender\");\n      }\n      align(t = this.chart.spacingBox) {\n        let e = this.chart,\n          i = this.options,\n          s = t.y;\n        /(lth|ct|rth)/.test(this.getAlignment()) && e.titleOffset[0] > 0 ? s += e.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && e.titleOffset[2] > 0 && (s -= e.titleOffset[2]), s !== t.y && (t = b(t, {\n          y: s\n        })), e.hasRendered || (this.group.placed = !1), this.group.align(b(i, {\n          width: this.legendWidth,\n          height: this.legendHeight,\n          verticalAlign: this.proximate ? \"top\" : i.verticalAlign\n        }), !0, t);\n      }\n      handleOverflow(t) {\n        let e = this,\n          i = this.chart,\n          s = i.renderer,\n          o = this.options,\n          r = o.y,\n          n = \"top\" === o.verticalAlign,\n          a = this.padding,\n          h = o.maxHeight,\n          l = o.navigation,\n          d = v(l.animation, !0),\n          c = l.arrowSize || 12,\n          p = this.pages,\n          u = this.allItems,\n          g = function (t) {\n            \"number\" == typeof t ? S.attr({\n              height: t\n            }) : S && (e.clipRect = S.destroy(), e.contentGroup.clip()), e.contentGroup.div && (e.contentGroup.div.style.clip = t ? \"rect(\" + a + \"px,9999px,\" + (a + t) + \"px,0)\" : \"auto\");\n          },\n          f = function (t) {\n            return e[t] = s.circle(0, 0, 1.3 * c).translate(c / 2, c / 2).add(k), i.styledMode || e[t].attr(\"fill\", \"rgba(0,0,0,0.0001)\"), e[t];\n          },\n          m,\n          x,\n          y,\n          b = i.spacingBox.height + (n ? -r : r) - a,\n          k = this.nav,\n          S = this.clipRect;\n        return \"horizontal\" !== o.layout || \"middle\" === o.verticalAlign || o.floating || (b /= 2), h && (b = Math.min(b, h)), p.length = 0, t && b > 0 && t > b && !1 !== l.enabled ? (this.clipHeight = m = Math.max(b - 20 - this.titleHeight - a, 0), this.currentPage = v(this.currentPage, 1), this.fullHeight = t, u.forEach((t, e) => {\n          y = t.legendItem || {};\n          let i = y.y || 0,\n            s = Math.round(y.label.getBBox().height),\n            o = p.length;\n          (!o || i - p[o - 1] > m && (x || i) !== p[o - 1]) && (p.push(x || i), o++), y.pageIx = o - 1, x && ((u[e - 1].legendItem || {}).pageIx = o - 1), e === u.length - 1 && i + s - p[o - 1] > m && i > p[o - 1] && (p.push(i), y.pageIx = o), i !== x && (x = i);\n        }), S || (S = e.clipRect = s.clipRect(0, a - 2, 9999, 0), e.contentGroup.clip(S)), g(m), k || (this.nav = k = s.g().attr({\n          zIndex: 1\n        }).add(this.group), this.up = s.symbol(\"triangle\", 0, 0, c, c).add(k), f(\"upTracker\").on(\"click\", function () {\n          e.scroll(-1, d);\n        }), this.pager = s.text(\"\", 15, 10).addClass(\"highcharts-legend-navigation\"), !i.styledMode && l.style && this.pager.css(l.style), this.pager.add(k), this.down = s.symbol(\"triangle-down\", 0, 0, c, c).add(k), f(\"downTracker\").on(\"click\", function () {\n          e.scroll(1, d);\n        })), e.scroll(0), t = b) : k && (g(), this.nav = k.destroy(), this.scrollGroup.attr({\n          translateY: 1\n        }), this.clipHeight = 0), t;\n      }\n      scroll(t, e) {\n        let i = this.chart,\n          s = this.pages,\n          o = s.length,\n          r = this.clipHeight,\n          h = this.options.navigation,\n          l = this.pager,\n          d = this.padding,\n          c = this.currentPage + t;\n        if (c > o && (c = o), c > 0) {\n          void 0 !== e && a(e, i), this.nav.attr({\n            translateX: d,\n            translateY: r + this.padding + 7 + this.titleHeight,\n            visibility: \"inherit\"\n          }), [this.up, this.upTracker].forEach(function (t) {\n            t.attr({\n              class: 1 === c ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\"\n            });\n          }), l.attr({\n            text: c + \"/\" + o\n          }), [this.down, this.downTracker].forEach(function (t) {\n            t.attr({\n              x: 18 + this.pager.getBBox().width,\n              class: c === o ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\"\n            });\n          }, this), i.styledMode || (this.up.attr({\n            fill: 1 === c ? h.inactiveColor : h.activeColor\n          }), this.upTracker.css({\n            cursor: 1 === c ? \"default\" : \"pointer\"\n          }), this.down.attr({\n            fill: c === o ? h.inactiveColor : h.activeColor\n          }), this.downTracker.css({\n            cursor: c === o ? \"default\" : \"pointer\"\n          })), this.scrollOffset = -s[c - 1] + this.initialItemY, this.scrollGroup.animate({\n            translateY: this.scrollOffset\n          }), this.currentPage = c, this.positionCheckboxes();\n          let t = n(v(e, i.renderer.globalAnimation, !0));\n          M(() => {\n            x(this, \"afterScroll\", {\n              currentPage: c\n            });\n          }, t.duration);\n        }\n      }\n      setItemEvents(t, e, i) {\n        let o = this,\n          r = t.legendItem || {},\n          n = o.chart.renderer.boxWrapper,\n          a = t instanceof s,\n          h = \"highcharts-legend-\" + (a ? \"point\" : \"series\") + \"-active\",\n          l = o.chart.styledMode,\n          d = i ? [e, r.symbol] : [r.group],\n          c = e => {\n            o.allItems.forEach(i => {\n              t !== i && [i].concat(i.linkedSeries || []).forEach(t => {\n                t.setState(e, !a);\n              });\n            });\n          };\n        for (let i of d) i && i.on(\"mouseover\", function () {\n          t.visible && c(\"inactive\"), t.setState(\"hover\"), t.visible && n.addClass(h), l || e.css(o.options.itemHoverStyle);\n        }).on(\"mouseout\", function () {\n          o.chart.styledMode || e.css(b(t.visible ? o.itemStyle : o.itemHiddenStyle)), c(\"\"), n.removeClass(h), t.setState();\n        }).on(\"click\", function (e) {\n          let i = \"legendItemClick\",\n            s = function () {\n              t.setVisible && t.setVisible(), c(t.visible ? \"inactive\" : \"\");\n            };\n          n.removeClass(h), e = {\n            browserEvent: e\n          }, t.firePointEvent ? t.firePointEvent(i, e, s) : x(t, i, e, s);\n        });\n      }\n      createCheckboxForItem(t) {\n        t.checkbox = p(\"input\", {\n          type: \"checkbox\",\n          className: \"highcharts-legend-checkbox\",\n          checked: t.selected,\n          defaultChecked: t.selected\n        }, this.options.itemCheckboxStyle, this.chart.container), c(t.checkbox, \"click\", function (e) {\n          let i = e.target;\n          x(t.series || t, \"checkboxClick\", {\n            checked: i.checked,\n            item: t\n          }, function () {\n            t.select();\n          });\n        });\n      }\n    }\n    return function (t) {\n      let e = [];\n      t.compose = function (i) {\n        r.pushUnique(e, i) && c(i, \"beforeMargins\", function () {\n          this.legend = new t(this, this.options.legend);\n        });\n      };\n    }(C || (C = {})), C;\n  }), i(e, \"Core/Legend/LegendSymbol.js\", [e[\"Core/Utilities.js\"]], function (t) {\n    var e, i;\n    let {\n      extend: s,\n      merge: o,\n      pick: r\n    } = t;\n    return (i = e || (e = {})).lineMarker = function (t, e) {\n      let i = this.legendItem = this.legendItem || {},\n        n = this.options,\n        a = t.symbolWidth,\n        h = t.symbolHeight,\n        l = this.symbol || \"circle\",\n        d = h / 2,\n        c = this.chart.renderer,\n        p = i.group,\n        u = t.baseline - Math.round(.3 * t.fontMetrics.b),\n        g = {},\n        f,\n        m = n.marker,\n        x = 0;\n      if (this.chart.styledMode || (g = {\n        \"stroke-width\": Math.min(n.lineWidth || 0, 24)\n      }, n.dashStyle ? g.dashstyle = n.dashStyle : \"square\" === n.linecap || (g[\"stroke-linecap\"] = \"round\")), i.line = c.path().addClass(\"highcharts-graph\").attr(g).add(p), g[\"stroke-linecap\"] && (x = Math.min(i.line.strokeWidth(), a) / 2), a && i.line.attr({\n        d: [[\"M\", x, u], [\"L\", a - x, u]]\n      }), m && !1 !== m.enabled && a) {\n        let t = Math.min(r(m.radius, d), d);\n        0 === l.indexOf(\"url\") && (m = o(m, {\n          width: h,\n          height: h\n        }), t = 0), i.symbol = f = c.symbol(l, a / 2 - t, u - t, 2 * t, 2 * t, s({\n          context: \"legend\"\n        }, m)).addClass(\"highcharts-point\").add(p), f.isMarker = !0;\n      }\n    }, i.rectangle = function (t, e) {\n      let i = e.legendItem || {},\n        s = t.options,\n        o = t.symbolHeight,\n        n = s.squareSymbol,\n        a = n ? o : t.symbolWidth;\n      i.symbol = this.chart.renderer.rect(n ? (t.symbolWidth - o) / 2 : 0, t.baseline - o + 1, a, o, r(t.options.symbolRadius, o / 2)).addClass(\"highcharts-point\").attr({\n        zIndex: 3\n      }).add(i.group);\n    }, e;\n  }), i(e, \"Core/Series/SeriesDefaults.js\", [], function () {\n    return {\n      lineWidth: 2,\n      allowPointSelect: !1,\n      crisp: !0,\n      showCheckbox: !1,\n      animation: {\n        duration: 1e3\n      },\n      enableMouseTracking: !0,\n      events: {},\n      marker: {\n        enabledThreshold: 2,\n        lineColor: \"#ffffff\",\n        lineWidth: 0,\n        radius: 4,\n        states: {\n          normal: {\n            animation: !0\n          },\n          hover: {\n            animation: {\n              duration: 150\n            },\n            enabled: !0,\n            radiusPlus: 2,\n            lineWidthPlus: 1\n          },\n          select: {\n            fillColor: \"#cccccc\",\n            lineColor: \"#000000\",\n            lineWidth: 2\n          }\n        }\n      },\n      point: {\n        events: {}\n      },\n      dataLabels: {\n        animation: {},\n        align: \"center\",\n        borderWidth: 0,\n        defer: !0,\n        formatter: function () {\n          let {\n            numberFormatter: t\n          } = this.series.chart;\n          return \"number\" != typeof this.y ? \"\" : t(this.y, -1);\n        },\n        padding: 5,\n        style: {\n          fontSize: \"0.7em\",\n          fontWeight: \"bold\",\n          color: \"contrast\",\n          textOutline: \"1px contrast\"\n        },\n        verticalAlign: \"bottom\",\n        x: 0,\n        y: 0\n      },\n      cropThreshold: 300,\n      opacity: 1,\n      pointRange: 0,\n      softThreshold: !0,\n      states: {\n        normal: {\n          animation: !0\n        },\n        hover: {\n          animation: {\n            duration: 150\n          },\n          lineWidthPlus: 1,\n          marker: {},\n          halo: {\n            size: 10,\n            opacity: .25\n          }\n        },\n        select: {\n          animation: {\n            duration: 0\n          }\n        },\n        inactive: {\n          animation: {\n            duration: 150\n          },\n          opacity: .2\n        }\n      },\n      stickyTracking: !0,\n      turboThreshold: 1e3,\n      findNearestPointBy: \"x\"\n    };\n  }), i(e, \"Core/Series/SeriesRegistry.js\", [e[\"Core/Globals.js\"], e[\"Core/Defaults.js\"], e[\"Core/Series/Point.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s) {\n    var o;\n    let {\n        defaultOptions: r\n      } = e,\n      {\n        extendClass: n,\n        merge: a\n      } = s;\n    return function (e) {\n      function s(t, s) {\n        let o = r.plotOptions || {},\n          n = s.defaultOptions,\n          a = s.prototype;\n        a.type = t, a.pointClass || (a.pointClass = i), n && (o[t] = n), e.seriesTypes[t] = s;\n      }\n      e.seriesTypes = t.seriesTypes, e.registerSeriesType = s, e.seriesType = function (t, o, h, l, d) {\n        let c = r.plotOptions || {};\n        return o = o || \"\", c[t] = a(c[o], h), s(t, n(e.seriesTypes[o] || function () {}, l)), e.seriesTypes[t].prototype.type = t, d && (e.seriesTypes[t].prototype.pointClass = n(i, d)), e.seriesTypes[t];\n      };\n    }(o || (o = {})), o;\n  }), i(e, \"Core/Series/Series.js\", [e[\"Core/Animation/AnimationUtilities.js\"], e[\"Core/Defaults.js\"], e[\"Core/Foundation.js\"], e[\"Core/Globals.js\"], e[\"Core/Legend/LegendSymbol.js\"], e[\"Core/Series/Point.js\"], e[\"Core/Series/SeriesDefaults.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Renderer/SVG/SVGElement.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s, o, r, n, a, h, l) {\n    let {\n        animObject: d,\n        setAnimation: c\n      } = t,\n      {\n        defaultOptions: p\n      } = e,\n      {\n        registerEventOptions: u\n      } = i,\n      {\n        hasTouch: g,\n        svg: f,\n        win: m\n      } = s,\n      {\n        seriesTypes: x\n      } = a,\n      {\n        addEvent: y,\n        arrayMax: b,\n        arrayMin: v,\n        clamp: k,\n        correctFloat: S,\n        defined: M,\n        diffObjects: C,\n        erase: w,\n        error: T,\n        extend: A,\n        find: P,\n        fireEvent: L,\n        getClosestDistance: O,\n        getNestedProperty: D,\n        insertItem: E,\n        isArray: I,\n        isNumber: B,\n        isString: j,\n        merge: R,\n        objectEach: z,\n        pick: N,\n        removeEvent: W,\n        splat: H,\n        syncTimeout: G\n      } = l;\n    class X {\n      constructor() {\n        this._i = void 0, this.chart = void 0, this.data = void 0, this.eventOptions = void 0, this.eventsToUnbind = void 0, this.index = void 0, this.linkedSeries = void 0, this.options = void 0, this.points = void 0, this.processedXData = void 0, this.processedYData = void 0, this.tooltipOptions = void 0, this.userOptions = void 0, this.xAxis = void 0, this.yAxis = void 0, this.zones = void 0;\n      }\n      init(t, e) {\n        let i;\n        L(this, \"init\", {\n          options: e\n        });\n        let s = this,\n          o = t.series;\n        this.eventsToUnbind = [], s.chart = t, s.options = s.setOptions(e);\n        let r = s.options,\n          n = !1 !== r.visible;\n        s.linkedSeries = [], s.bindAxes(), A(s, {\n          name: r.name,\n          state: \"\",\n          visible: n,\n          selected: !0 === r.selected\n        }), u(this, r);\n        let a = r.events;\n        (a && a.click || r.point && r.point.events && r.point.events.click || r.allowPointSelect) && (t.runTrackerClick = !0), s.getColor(), s.getSymbol(), s.parallelArrays.forEach(function (t) {\n          s[t + \"Data\"] || (s[t + \"Data\"] = []);\n        }), s.isCartesian && (t.hasCartesianSeries = !0), o.length && (i = o[o.length - 1]), s._i = N(i && i._i, -1) + 1, s.opacity = s.options.opacity, t.orderItems(\"series\", E(this, o)), r.dataSorting && r.dataSorting.enabled ? s.setDataSortingOptions() : s.points || s.data || s.setData(r.data, !1), L(this, \"afterInit\");\n      }\n      is(t) {\n        return x[t] && this instanceof x[t];\n      }\n      bindAxes() {\n        let t;\n        let e = this,\n          i = e.options,\n          s = e.chart;\n        L(this, \"bindAxes\", null, function () {\n          (e.axisTypes || []).forEach(function (o) {\n            s[o].forEach(function (s) {\n              t = s.options, (N(i[o], 0) === s.index || void 0 !== i[o] && i[o] === t.id) && (E(e, s.series), e[o] = s, s.isDirty = !0);\n            }), e[o] || e.optionalAxis === o || T(18, !0, s);\n          });\n        }), L(this, \"afterBindAxes\");\n      }\n      updateParallelArrays(t, e, i) {\n        let s = t.series,\n          o = B(e) ? function (i) {\n            let o = \"y\" === i && s.toYData ? s.toYData(t) : t[i];\n            s[i + \"Data\"][e] = o;\n          } : function (t) {\n            Array.prototype[e].apply(s[t + \"Data\"], i);\n          };\n        s.parallelArrays.forEach(o);\n      }\n      hasData() {\n        return this.visible && void 0 !== this.dataMax && void 0 !== this.dataMin || this.visible && this.yData && this.yData.length > 0;\n      }\n      hasMarkerChanged(t, e) {\n        let i = t.marker,\n          s = e.marker || {};\n        return i && (s.enabled && !i.enabled || s.symbol !== i.symbol || s.height !== i.height || s.width !== i.width);\n      }\n      autoIncrement(t) {\n        let e = this.options,\n          i = e.pointIntervalUnit,\n          s = e.relativeXValue,\n          o = this.chart.time,\n          r = this.xIncrement,\n          n,\n          a;\n        return (r = N(r, e.pointStart, 0), this.pointInterval = a = N(this.pointInterval, e.pointInterval, 1), s && B(t) && (a *= t), i && (n = new o.Date(r), \"day\" === i ? o.set(\"Date\", n, o.get(\"Date\", n) + a) : \"month\" === i ? o.set(\"Month\", n, o.get(\"Month\", n) + a) : \"year\" === i && o.set(\"FullYear\", n, o.get(\"FullYear\", n) + a), a = n.getTime() - r), s && B(t)) ? r + a : (this.xIncrement = r + a, r);\n      }\n      setDataSortingOptions() {\n        let t = this.options;\n        A(this, {\n          requireSorting: !1,\n          sorted: !1,\n          enabledDataSorting: !0,\n          allowDG: !1\n        }), M(t.pointRange) || (t.pointRange = 1);\n      }\n      setOptions(t) {\n        let e;\n        let i = this.chart,\n          s = i.options,\n          o = s.plotOptions,\n          r = i.userOptions || {},\n          n = R(t),\n          a = i.styledMode,\n          h = {\n            plotOptions: o,\n            userOptions: n\n          };\n        L(this, \"setOptions\", h);\n        let l = h.plotOptions[this.type],\n          d = r.plotOptions || {},\n          c = d.series || {},\n          u = p.plotOptions[this.type] || {},\n          g = d[this.type] || {};\n        this.userOptions = h.userOptions;\n        let f = R(l, o.series, g, n);\n        this.tooltipOptions = R(p.tooltip, p.plotOptions.series?.tooltip, u?.tooltip, i.userOptions.tooltip, d.series?.tooltip, g.tooltip, n.tooltip), this.stickyTracking = N(n.stickyTracking, g.stickyTracking, c.stickyTracking, !!this.tooltipOptions.shared && !this.noSharedTooltip || f.stickyTracking), null === l.marker && delete f.marker, this.zoneAxis = f.zoneAxis;\n        let m = this.zones = (f.zones || []).slice();\n        return (f.negativeColor || f.negativeFillColor) && !f.zones && (e = {\n          value: f[this.zoneAxis + \"Threshold\"] || f.threshold || 0,\n          className: \"highcharts-negative\"\n        }, a || (e.color = f.negativeColor, e.fillColor = f.negativeFillColor), m.push(e)), m.length && M(m[m.length - 1].value) && m.push(a ? {} : {\n          color: this.color,\n          fillColor: this.fillColor\n        }), L(this, \"afterSetOptions\", {\n          options: f\n        }), f;\n      }\n      getName() {\n        return N(this.options.name, \"Series \" + (this.index + 1));\n      }\n      getCyclic(t, e, i) {\n        let s, o;\n        let r = this.chart,\n          n = `${t}Index`,\n          a = `${t}Counter`,\n          h = i?.length || r.options.chart.colorCount;\n        !e && (M(o = N(\"color\" === t ? this.options.colorIndex : void 0, this[n])) ? s = o : (r.series.length || (r[a] = 0), s = r[a] % h, r[a] += 1), i && (e = i[s])), void 0 !== s && (this[n] = s), this[t] = e;\n      }\n      getColor() {\n        this.chart.styledMode ? this.getCyclic(\"color\") : this.options.colorByPoint ? this.color = \"#cccccc\" : this.getCyclic(\"color\", this.options.color || p.plotOptions[this.type].color, this.chart.options.colors);\n      }\n      getPointsCollection() {\n        return (this.hasGroupedData ? this.points : this.data) || [];\n      }\n      getSymbol() {\n        let t = this.options.marker;\n        this.getCyclic(\"symbol\", t.symbol, this.chart.options.symbols);\n      }\n      findPointIndex(t, e) {\n        let i, s, o;\n        let n = t.id,\n          a = t.x,\n          h = this.points,\n          l = this.options.dataSorting;\n        if (n) {\n          let t = this.chart.get(n);\n          t instanceof r && (i = t);\n        } else if (this.linkedParent || this.enabledDataSorting || this.options.relativeXValue) {\n          let e = e => !e.touched && e.index === t.index;\n          if (l && l.matchByName ? e = e => !e.touched && e.name === t.name : this.options.relativeXValue && (e = e => !e.touched && e.options.x === t.x), !(i = P(h, e))) return;\n        }\n        return i && void 0 !== (o = i && i.index) && (s = !0), void 0 === o && B(a) && (o = this.xData.indexOf(a, e)), -1 !== o && void 0 !== o && this.cropped && (o = o >= this.cropStart ? o - this.cropStart : o), !s && B(o) && h[o] && h[o].touched && (o = void 0), o;\n      }\n      updateData(t, e) {\n        let i = this.options,\n          s = i.dataSorting,\n          o = this.points,\n          r = [],\n          n = this.requireSorting,\n          a = t.length === o.length,\n          h,\n          l,\n          d,\n          c,\n          p = !0;\n        if (this.xIncrement = null, t.forEach(function (t, e) {\n          let l;\n          let d = M(t) && this.pointClass.prototype.optionsToObject.call({\n              series: this\n            }, t) || {},\n            p = d.x,\n            u = d.id;\n          u || B(p) ? (-1 === (l = this.findPointIndex(d, c)) || void 0 === l ? r.push(t) : o[l] && t !== i.data[l] ? (o[l].update(t, !1, null, !1), o[l].touched = !0, n && (c = l + 1)) : o[l] && (o[l].touched = !0), (!a || e !== l || s && s.enabled || this.hasDerivedData) && (h = !0)) : r.push(t);\n        }, this), h) for (l = o.length; l--;) (d = o[l]) && !d.touched && d.remove && d.remove(!1, e);else !a || s && s.enabled ? p = !1 : (t.forEach(function (t, e) {\n          t === o[e].y || o[e].destroyed || o[e].update(t, !1, null, !1);\n        }), r.length = 0);\n        return o.forEach(function (t) {\n          t && (t.touched = !1);\n        }), !!p && (r.forEach(function (t) {\n          this.addPoint(t, !1, null, null, !1);\n        }, this), null === this.xIncrement && this.xData && this.xData.length && (this.xIncrement = b(this.xData), this.autoIncrement()), !0);\n      }\n      setData(t, e = !0, i, s) {\n        let o = this,\n          r = o.points,\n          n = r && r.length || 0,\n          a = o.options,\n          h = o.chart,\n          l = a.dataSorting,\n          d = o.xAxis,\n          c = a.turboThreshold,\n          p = this.xData,\n          u = this.yData,\n          g = o.pointArrayMap,\n          f = g && g.length,\n          m = a.keys,\n          x,\n          y,\n          b,\n          v = 0,\n          k = 1,\n          S = null,\n          M;\n        h.options.chart.allowMutatingData || (a.data && delete o.options.data, o.userOptions.data && delete o.userOptions.data, M = R(!0, t)), t = M || t || [];\n        let C = t.length;\n        if (l && l.enabled && (t = this.sortData(t)), h.options.chart.allowMutatingData && !1 !== s && C && n && !o.cropped && !o.hasGroupedData && o.visible && !o.boosted && (b = this.updateData(t, i)), !b) {\n          if (o.xIncrement = null, o.colorCounter = 0, this.parallelArrays.forEach(function (t) {\n            o[t + \"Data\"].length = 0;\n          }), c && C > c) {\n            if (B(S = o.getFirstValidPoint(t))) for (x = 0; x < C; x++) p[x] = this.autoIncrement(), u[x] = t[x];else if (I(S)) {\n              if (f) {\n                if (S.length === f) for (x = 0; x < C; x++) p[x] = this.autoIncrement(), u[x] = t[x];else for (x = 0; x < C; x++) y = t[x], p[x] = y[0], u[x] = y.slice(1, f + 1);\n              } else if (m && (v = m.indexOf(\"x\"), k = m.indexOf(\"y\"), v = v >= 0 ? v : 0, k = k >= 0 ? k : 1), 1 === S.length && (k = 0), v === k) for (x = 0; x < C; x++) p[x] = this.autoIncrement(), u[x] = t[x][k];else for (x = 0; x < C; x++) y = t[x], p[x] = y[v], u[x] = y[k];\n            } else T(12, !1, h);\n          } else for (x = 0; x < C; x++) y = {\n            series: o\n          }, o.pointClass.prototype.applyOptions.apply(y, [t[x]]), o.updateParallelArrays(y, x);\n          for (u && j(u[0]) && T(14, !0, h), o.data = [], o.options.data = o.userOptions.data = t, x = n; x--;) r[x]?.destroy();\n          d && (d.minRange = d.userMinRange), o.isDirty = h.isDirtyBox = !0, o.isDirtyData = !!r, i = !1;\n        }\n        \"point\" === a.legendType && (this.processData(), this.generatePoints()), e && h.redraw(i);\n      }\n      sortData(t) {\n        let e = this,\n          i = e.options,\n          s = i.dataSorting,\n          o = s.sortKey || \"y\",\n          r = function (t, e) {\n            return M(e) && t.pointClass.prototype.optionsToObject.call({\n              series: t\n            }, e) || {};\n          };\n        t.forEach(function (i, s) {\n          t[s] = r(e, i), t[s].index = s;\n        }, this);\n        let n = t.concat().sort((t, e) => {\n          let i = D(o, t),\n            s = D(o, e);\n          return s < i ? -1 : s > i ? 1 : 0;\n        });\n        return n.forEach(function (t, e) {\n          t.x = e;\n        }, this), e.linkedSeries && e.linkedSeries.forEach(function (e) {\n          let i = e.options,\n            s = i.data;\n          i.dataSorting && i.dataSorting.enabled || !s || (s.forEach(function (i, o) {\n            s[o] = r(e, i), t[o] && (s[o].x = t[o].x, s[o].index = o);\n          }), e.setData(s, !1));\n        }), t;\n      }\n      getProcessedData(t) {\n        let e = this,\n          i = e.xAxis,\n          s = e.options,\n          o = s.cropThreshold,\n          r = t || e.getExtremesFromAll || s.getExtremesFromAll,\n          n = i?.logarithmic,\n          a = e.isCartesian,\n          h,\n          l,\n          d = 0,\n          c,\n          p,\n          u,\n          g = e.xData,\n          f = e.yData,\n          m = !1,\n          x = g.length;\n        i && (p = (c = i.getExtremes()).min, u = c.max, m = !!(i.categories && !i.names.length)), a && e.sorted && !r && (!o || x > o || e.forceCrop) && (g[x - 1] < p || g[0] > u ? (g = [], f = []) : e.yData && (g[0] < p || g[x - 1] > u) && (g = (h = this.cropData(e.xData, e.yData, p, u)).xData, f = h.yData, d = h.start, l = !0));\n        let y = O([n ? g.map(n.log2lin) : g], () => e.requireSorting && !m && T(15, !1, e.chart));\n        return {\n          xData: g,\n          yData: f,\n          cropped: l,\n          cropStart: d,\n          closestPointRange: y\n        };\n      }\n      processData(t) {\n        let e = this.xAxis;\n        if (this.isCartesian && !this.isDirty && !e.isDirty && !this.yAxis.isDirty && !t) return !1;\n        let i = this.getProcessedData();\n        this.cropped = i.cropped, this.cropStart = i.cropStart, this.processedXData = i.xData, this.processedYData = i.yData, this.closestPointRange = this.basePointRange = i.closestPointRange, L(this, \"afterProcessData\");\n      }\n      cropData(t, e, i, s) {\n        let o = t.length,\n          r,\n          n,\n          a = 0,\n          h = o;\n        for (r = 0; r < o; r++) if (t[r] >= i) {\n          a = Math.max(0, r - 1);\n          break;\n        }\n        for (n = r; n < o; n++) if (t[n] > s) {\n          h = n + 1;\n          break;\n        }\n        return {\n          xData: t.slice(a, h),\n          yData: e.slice(a, h),\n          start: a,\n          end: h\n        };\n      }\n      generatePoints() {\n        let t = this.options,\n          e = this.processedData || t.data,\n          i = this.processedXData,\n          s = this.processedYData,\n          o = this.pointClass,\n          r = i.length,\n          n = this.cropStart || 0,\n          a = this.hasGroupedData,\n          h = t.keys,\n          l = [],\n          d = t.dataGrouping && t.dataGrouping.groupAll ? n : 0,\n          c,\n          p,\n          u,\n          g,\n          f = this.data;\n        if (!f && !a) {\n          let t = [];\n          t.length = e.length, f = this.data = t;\n        }\n        for (h && a && (this.options.keys = !1), g = 0; g < r; g++) p = n + g, a ? ((u = new o().init(this, [i[g]].concat(H(s[g])))).dataGroup = this.groupMap[d + g], u.dataGroup.options && (u.options = u.dataGroup.options, A(u, u.dataGroup.options), delete u.dataLabels)) : (u = f[p]) || void 0 === e[p] || (f[p] = u = new o().init(this, e[p], i[g])), u && (u.index = a ? d + g : p, l[g] = u);\n        if (this.options.keys = h, f && (r !== (c = f.length) || a)) for (g = 0; g < c; g++) g !== n || a || (g += r), f[g] && (f[g].destroyElements(), f[g].plotX = void 0);\n        this.data = f, this.points = l, L(this, \"afterGeneratePoints\");\n      }\n      getXExtremes(t) {\n        return {\n          min: v(t),\n          max: b(t)\n        };\n      }\n      getExtremes(t, e) {\n        let i = this.xAxis,\n          s = this.yAxis,\n          o = this.processedXData || this.xData,\n          r = [],\n          n = this.requireSorting && !this.is(\"column\") ? 1 : 0,\n          a = !!s && s.positiveValuesOnly,\n          h,\n          l,\n          d,\n          c,\n          p,\n          u,\n          g,\n          f = 0,\n          m = 0,\n          x = 0;\n        t = t || this.stackedYData || this.processedYData || [];\n        let y = t.length;\n        for (i && (f = (h = i.getExtremes()).min, m = h.max), u = 0; u < y; u++) if (c = o[u], l = (B(p = t[u]) || I(p)) && ((B(p) ? p > 0 : p.length) || !a), d = e || this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !i || (o[u + n] || c) >= f && (o[u - n] || c) <= m, l && d) {\n          if (g = p.length) for (; g--;) B(p[g]) && (r[x++] = p[g]);else r[x++] = p;\n        }\n        let k = {\n          activeYData: r,\n          dataMin: v(r),\n          dataMax: b(r)\n        };\n        return L(this, \"afterGetExtremes\", {\n          dataExtremes: k\n        }), k;\n      }\n      applyExtremes() {\n        let t = this.getExtremes();\n        return this.dataMin = t.dataMin, this.dataMax = t.dataMax, t;\n      }\n      getFirstValidPoint(t) {\n        let e = t.length,\n          i = 0,\n          s = null;\n        for (; null === s && i < e;) s = t[i], i++;\n        return s;\n      }\n      translate() {\n        this.processedXData || this.processData(), this.generatePoints();\n        let t = this.options,\n          e = t.stacking,\n          i = this.xAxis,\n          s = i.categories,\n          o = this.enabledDataSorting,\n          r = this.yAxis,\n          n = this.points,\n          a = n.length,\n          h = this.pointPlacementToXValue(),\n          l = !!h,\n          d = t.threshold,\n          c = t.startFromThreshold ? d : 0,\n          p,\n          u,\n          g,\n          f,\n          m = Number.MAX_VALUE;\n        function x(t) {\n          return k(t, -1e5, 1e5);\n        }\n        for (p = 0; p < a; p++) {\n          let t;\n          let a = n[p],\n            y = a.x,\n            b,\n            v,\n            k = a.y,\n            C = a.low,\n            w = e && r.stacking?.stacks[(this.negStacks && k < (c ? 0 : d) ? \"-\" : \"\") + this.stackKey];\n          u = i.translate(y, !1, !1, !1, !0, h), a.plotX = B(u) ? S(x(u)) : void 0, e && this.visible && w && w[y] && (f = this.getStackIndicator(f, y, this.index), !a.isNull && f.key && (v = (b = w[y]).points[f.key]), b && I(v) && (C = v[0], k = v[1], C === c && f.key === w[y].base && (C = N(B(d) ? d : r.min)), r.positiveValuesOnly && M(C) && C <= 0 && (C = void 0), a.total = a.stackTotal = N(b.total), a.percentage = M(a.y) && b.total ? a.y / b.total * 100 : void 0, a.stackY = k, this.irregularWidths || b.setOffset(this.pointXOffset || 0, this.barW || 0, void 0, void 0, void 0, this.xAxis))), a.yBottom = M(C) ? x(r.translate(C, !1, !0, !1, !0)) : void 0, this.dataModify && (k = this.dataModify.modifyValue(k, p)), B(k) && void 0 !== a.plotX && (t = B(t = r.translate(k, !1, !0, !1, !0)) ? x(t) : void 0), a.plotY = t, a.isInside = this.isPointInside(a), a.clientX = l ? S(i.translate(y, !1, !1, !1, !0, h)) : u, a.negative = (a.y || 0) < (d || 0), a.category = N(s && s[a.x], a.x), a.isNull || !1 === a.visible || (void 0 !== g && (m = Math.min(m, Math.abs(u - g))), g = u), a.zone = this.zones.length ? a.getZone() : void 0, !a.graphic && this.group && o && (a.isNew = !0);\n        }\n        this.closestPointRangePx = m, L(this, \"afterTranslate\");\n      }\n      getValidPoints(t, e, i) {\n        let s = this.chart;\n        return (t || this.points || []).filter(function (t) {\n          let {\n              plotX: o,\n              plotY: r\n            } = t,\n            n = !i && (t.isNull || !B(r));\n          return !n && (!e || !!s.isInsidePlot(o, r, {\n            inverted: s.inverted\n          })) && !1 !== t.visible;\n        });\n      }\n      getClipBox() {\n        let {\n            chart: t,\n            xAxis: e,\n            yAxis: i\n          } = this,\n          s = R(t.clipBox);\n        return e && e.len !== t.plotSizeX && (s.width = e.len), i && i.len !== t.plotSizeY && (s.height = i.len), s;\n      }\n      getSharedClipKey() {\n        return this.sharedClipKey = (this.options.xAxis || 0) + \",\" + (this.options.yAxis || 0), this.sharedClipKey;\n      }\n      setClip() {\n        let {\n            chart: t,\n            group: e,\n            markerGroup: i\n          } = this,\n          s = t.sharedClips,\n          o = t.renderer,\n          r = this.getClipBox(),\n          n = this.getSharedClipKey(),\n          a = s[n];\n        a ? a.animate(r) : s[n] = a = o.clipRect(r), e && e.clip(!1 === this.options.clip ? void 0 : a), i && i.clip();\n      }\n      animate(t) {\n        let {\n            chart: e,\n            group: i,\n            markerGroup: s\n          } = this,\n          o = e.inverted,\n          r = d(this.options.animation),\n          n = [this.getSharedClipKey(), r.duration, r.easing, r.defer].join(\",\"),\n          a = e.sharedClips[n],\n          h = e.sharedClips[n + \"m\"];\n        if (t && i) {\n          let t = this.getClipBox();\n          if (a) a.attr(\"height\", t.height);else {\n            t.width = 0, o && (t.x = e.plotHeight), a = e.renderer.clipRect(t), e.sharedClips[n] = a;\n            let i = {\n              x: -99,\n              y: -99,\n              width: o ? e.plotWidth + 199 : 99,\n              height: o ? 99 : e.plotHeight + 199\n            };\n            h = e.renderer.clipRect(i), e.sharedClips[n + \"m\"] = h;\n          }\n          i.clip(a), s && s.clip(h);\n        } else if (a && !a.hasClass(\"highcharts-animating\")) {\n          let t = this.getClipBox(),\n            e = r.step;\n          s && s.element.childNodes.length && (r.step = function (t, i) {\n            e && e.apply(i, arguments), \"width\" === i.prop && h && h.element && h.attr(o ? \"height\" : \"width\", t + 99);\n          }), a.addClass(\"highcharts-animating\").animate(t, r);\n        }\n      }\n      afterAnimate() {\n        this.setClip(), z(this.chart.sharedClips, (t, e, i) => {\n          t && !this.chart.container.querySelector(`[clip-path=\"url(#${t.id})\"]`) && (t.destroy(), delete i[e]);\n        }), this.finishedAnimating = !0, L(this, \"afterAnimate\");\n      }\n      drawPoints(t = this.points) {\n        let e, i, s, o, r, n, a;\n        let h = this.chart,\n          l = h.styledMode,\n          {\n            colorAxis: d,\n            options: c\n          } = this,\n          p = c.marker,\n          u = this[this.specialGroup || \"markerGroup\"],\n          g = this.xAxis,\n          f = N(p.enabled, !g || !!g.isRadial || null, this.closestPointRangePx >= p.enabledThreshold * p.radius);\n        if (!1 !== p.enabled || this._hasPointMarkers) for (e = 0; e < t.length; e++) {\n          o = (s = (i = t[e]).graphic) ? \"animate\" : \"attr\", r = i.marker || {}, n = !!i.marker;\n          let c = (f && void 0 === r.enabled || r.enabled) && !i.isNull && !1 !== i.visible;\n          if (c) {\n            let t = N(r.symbol, this.symbol, \"rect\");\n            a = this.markerAttribs(i, i.selected && \"select\"), this.enabledDataSorting && (i.startXPos = g.reversed ? -(a.width || 0) : g.width);\n            let e = !1 !== i.isInside;\n            if (!s && e && ((a.width || 0) > 0 || i.hasImage) && (i.graphic = s = h.renderer.symbol(t, a.x, a.y, a.width, a.height, n ? r : p).add(u), this.enabledDataSorting && h.hasRendered && (s.attr({\n              x: i.startXPos\n            }), o = \"animate\")), s && \"animate\" === o && s[e ? \"show\" : \"hide\"](e).animate(a), s) {\n              let t = this.pointAttribs(i, l || !i.selected ? void 0 : \"select\");\n              l ? d && s.css({\n                fill: t.fill\n              }) : s[o](t);\n            }\n            s && s.addClass(i.getClassName(), !0);\n          } else s && (i.graphic = s.destroy());\n        }\n      }\n      markerAttribs(t, e) {\n        let i = this.options,\n          s = i.marker,\n          o = t.marker || {},\n          r = o.symbol || s.symbol,\n          n = {},\n          a,\n          h,\n          l = N(o.radius, s && s.radius);\n        e && (a = s.states[e], l = N((h = o.states && o.states[e]) && h.radius, a && a.radius, l && l + (a && a.radiusPlus || 0))), t.hasImage = r && 0 === r.indexOf(\"url\"), t.hasImage && (l = 0);\n        let d = t.pos();\n        return B(l) && d && (n.x = d[0] - l, n.y = d[1] - l, i.crisp && (n.x = Math.floor(n.x))), l && (n.width = n.height = 2 * l), n;\n      }\n      pointAttribs(t, e) {\n        let i = this.options.marker,\n          s = t && t.options,\n          o = s && s.marker || {},\n          r = s && s.color,\n          n = t && t.color,\n          a = t && t.zone && t.zone.color,\n          h,\n          l,\n          d = this.color,\n          c,\n          p,\n          u = N(o.lineWidth, i.lineWidth),\n          g = 1;\n        return d = r || a || n || d, c = o.fillColor || i.fillColor || d, p = o.lineColor || i.lineColor || d, e = e || \"normal\", h = i.states[e] || {}, u = N((l = o.states && o.states[e] || {}).lineWidth, h.lineWidth, u + N(l.lineWidthPlus, h.lineWidthPlus, 0)), c = l.fillColor || h.fillColor || c, {\n          stroke: p = l.lineColor || h.lineColor || p,\n          \"stroke-width\": u,\n          fill: c,\n          opacity: g = N(l.opacity, h.opacity, g)\n        };\n      }\n      destroy(t) {\n        let e, i, s;\n        let o = this,\n          r = o.chart,\n          n = /AppleWebKit\\/533/.test(m.navigator.userAgent),\n          a = o.data || [];\n        for (L(o, \"destroy\", {\n          keepEventsForUpdate: t\n        }), this.removeEvents(t), (o.axisTypes || []).forEach(function (t) {\n          (s = o[t]) && s.series && (w(s.series, o), s.isDirty = s.forceRedraw = !0);\n        }), o.legendItem && o.chart.legend.destroyItem(o), e = a.length; e--;) (i = a[e]) && i.destroy && i.destroy();\n        o.clips && o.clips.forEach(t => t.destroy()), l.clearTimeout(o.animationTimeout), z(o, function (t, e) {\n          t instanceof h && !t.survive && t[n && \"group\" === e ? \"hide\" : \"destroy\"]();\n        }), r.hoverSeries === o && (r.hoverSeries = void 0), w(r.series, o), r.orderItems(\"series\"), z(o, function (e, i) {\n          t && \"hcEvents\" === i || delete o[i];\n        });\n      }\n      applyZones() {\n        let t = this,\n          e = this.chart,\n          i = e.renderer,\n          s = this.zones,\n          o = this.clips || [],\n          r = this.graph,\n          n = this.area,\n          a = Math.max(e.plotWidth, e.plotHeight),\n          h = this[(this.zoneAxis || \"y\") + \"Axis\"],\n          l = e.inverted,\n          d,\n          c,\n          p,\n          u,\n          g,\n          f,\n          m,\n          x,\n          y,\n          b,\n          v,\n          S = !1;\n        s.length && (r || n) && h && void 0 !== h.min ? (g = h.reversed, f = h.horiz, r && !this.showLine && r.hide(), n && n.hide(), u = h.getExtremes(), s.forEach(function (s, M) {\n          d = g ? f ? e.plotWidth : 0 : f ? 0 : h.toPixels(u.min) || 0, d = k(N(c, d), 0, a), c = k(Math.round(h.toPixels(N(s.value, u.max), !0) || 0), 0, a), S && (d = c = h.toPixels(u.max)), m = Math.abs(d - c), x = Math.min(d, c), y = Math.max(d, c), h.isXAxis ? (p = {\n            x: l ? y : x,\n            y: 0,\n            width: m,\n            height: a\n          }, f || (p.x = e.plotHeight - p.x)) : (p = {\n            x: 0,\n            y: l ? y : x,\n            width: a,\n            height: m\n          }, f && (p.y = e.plotWidth - p.y)), o[M] ? o[M].animate(p) : o[M] = i.clipRect(p), b = t[\"zone-area-\" + M], v = t[\"zone-graph-\" + M], r && v && v.clip(o[M]), n && b && b.clip(o[M]), S = s.value > u.max, t.resetZones && 0 === c && (c = void 0);\n        }), this.clips = o) : t.visible && (r && r.show(), n && n.show());\n      }\n      plotGroup(t, e, i, s, o) {\n        let r = this[t],\n          n = !r,\n          a = {\n            visibility: i,\n            zIndex: s || .1\n          };\n        return void 0 === this.opacity || this.chart.styledMode || \"inactive\" === this.state || (a.opacity = this.opacity), n && (this[t] = r = this.chart.renderer.g().add(o)), r.addClass(\"highcharts-\" + e + \" highcharts-series-\" + this.index + \" highcharts-\" + this.type + \"-series \" + (M(this.colorIndex) ? \"highcharts-color-\" + this.colorIndex + \" \" : \"\") + (this.options.className || \"\") + (r.hasClass(\"highcharts-tracker\") ? \" highcharts-tracker\" : \"\"), !0), r.attr(a)[n ? \"attr\" : \"animate\"](this.getPlotBox(e)), r;\n      }\n      getPlotBox(t) {\n        let e = this.xAxis,\n          i = this.yAxis,\n          s = this.chart,\n          o = s.inverted && !s.polar && e && !1 !== this.invertible && \"series\" === t;\n        return s.inverted && (e = i, i = this.xAxis), {\n          translateX: e ? e.left : s.plotLeft,\n          translateY: i ? i.top : s.plotTop,\n          rotation: o ? 90 : 0,\n          rotationOriginX: o ? (e.len - i.len) / 2 : 0,\n          rotationOriginY: o ? (e.len + i.len) / 2 : 0,\n          scaleX: o ? -1 : 1,\n          scaleY: 1\n        };\n      }\n      removeEvents(t) {\n        t || W(this), this.eventsToUnbind.length && (this.eventsToUnbind.forEach(function (t) {\n          t();\n        }), this.eventsToUnbind.length = 0);\n      }\n      render() {\n        let t = this,\n          e = t.chart,\n          i = t.options,\n          s = d(i.animation),\n          o = t.visible ? \"inherit\" : \"hidden\",\n          r = i.zIndex,\n          n = t.hasRendered,\n          a = e.seriesGroup;\n        e.inverted;\n        let h = t.finishedAnimating ? 0 : s.duration;\n        L(this, \"render\"), t.plotGroup(\"group\", \"series\", o, r, a), t.markerGroup = t.plotGroup(\"markerGroup\", \"markers\", o, r, a), !1 !== i.clip && t.setClip(), t.animate && h && t.animate(!0), t.drawGraph && (t.drawGraph(), t.applyZones()), t.visible && t.drawPoints(), t.drawDataLabels && t.drawDataLabels(), t.redrawPoints && t.redrawPoints(), t.drawTracker && i.enableMouseTracking && t.drawTracker(), t.animate && h && t.animate(), n || (h && s.defer && (h += s.defer), t.animationTimeout = G(function () {\n          t.afterAnimate();\n        }, h || 0)), t.isDirty = !1, t.hasRendered = !0, L(t, \"afterRender\");\n      }\n      redraw() {\n        let t = this.isDirty || this.isDirtyData;\n        this.translate(), this.render(), t && delete this.kdTree;\n      }\n      reserveSpace() {\n        return this.visible || !this.chart.options.chart.ignoreHiddenSeries;\n      }\n      searchPoint(t, e) {\n        let i = this.xAxis,\n          s = this.yAxis,\n          o = this.chart.inverted;\n        return this.searchKDTree({\n          clientX: o ? i.len - t.chartY + i.pos : t.chartX - i.pos,\n          plotY: o ? s.len - t.chartX + s.pos : t.chartY - s.pos\n        }, e, t);\n      }\n      buildKDTree(t) {\n        this.buildingKdTree = !0;\n        let e = this,\n          i = e.options.findNearestPointBy.indexOf(\"y\") > -1 ? 2 : 1;\n        delete e.kdTree, G(function () {\n          e.kdTree = function t(i, s, o) {\n            let r, n;\n            let a = i && i.length;\n            if (a) return r = e.kdAxisArray[s % o], i.sort(function (t, e) {\n              return t[r] - e[r];\n            }), {\n              point: i[n = Math.floor(a / 2)],\n              left: t(i.slice(0, n), s + 1, o),\n              right: t(i.slice(n + 1), s + 1, o)\n            };\n          }(e.getValidPoints(null, !e.directTouch), i, i), e.buildingKdTree = !1;\n        }, e.options.kdNow || t && \"touchstart\" === t.type ? 0 : 1);\n      }\n      searchKDTree(t, e, i) {\n        let s = this,\n          [o, r] = this.kdAxisArray,\n          n = e ? \"distX\" : \"dist\",\n          a = (s.options.findNearestPointBy || \"\").indexOf(\"y\") > -1 ? 2 : 1,\n          h = !!s.isBubble;\n        if (this.kdTree || this.buildingKdTree || this.buildKDTree(i), this.kdTree) return function t(e, i, a, l) {\n          let d = i.point,\n            c = s.kdAxisArray[a % l],\n            p,\n            u,\n            g = d;\n          !function (t, e) {\n            let i = t[o],\n              s = e[o],\n              n = M(i) && M(s) ? i - s : null,\n              a = t[r],\n              l = e[r],\n              d = M(a) && M(l) ? a - l : 0,\n              c = h && e.marker?.radius || 0;\n            e.dist = Math.sqrt((n && n * n || 0) + d * d) - c, e.distX = M(n) ? Math.abs(n) - c : Number.MAX_VALUE;\n          }(e, d);\n          let f = (e[c] || 0) - (d[c] || 0) + (h && d.marker?.radius || 0),\n            m = f < 0 ? \"left\" : \"right\",\n            x = f < 0 ? \"right\" : \"left\";\n          return i[m] && (g = (p = t(e, i[m], a + 1, l))[n] < g[n] ? p : d), i[x] && Math.sqrt(f * f) < g[n] && (g = (u = t(e, i[x], a + 1, l))[n] < g[n] ? u : g), g;\n        }(t, this.kdTree, a, a);\n      }\n      pointPlacementToXValue() {\n        let {\n            options: {\n              pointPlacement: t,\n              pointRange: e\n            },\n            xAxis: i\n          } = this,\n          s = t;\n        return \"between\" === s && (s = i.reversed ? -.5 : .5), B(s) ? s * (e || i.pointRange) : 0;\n      }\n      isPointInside(t) {\n        let {\n            chart: e,\n            xAxis: i,\n            yAxis: s\n          } = this,\n          o = void 0 !== t.plotY && void 0 !== t.plotX && t.plotY >= 0 && t.plotY <= (s ? s.len : e.plotHeight) && t.plotX >= 0 && t.plotX <= (i ? i.len : e.plotWidth);\n        return o;\n      }\n      drawTracker() {\n        let t = this,\n          e = t.options,\n          i = e.trackByArea,\n          s = [].concat(i ? t.areaPath : t.graphPath),\n          o = t.chart,\n          r = o.pointer,\n          n = o.renderer,\n          a = o.options.tooltip.snap,\n          h = t.tracker,\n          l = function (i) {\n            e.enableMouseTracking && o.hoverSeries !== t && t.onMouseOver();\n          },\n          d = \"rgba(192,192,192,\" + (f ? 1e-4 : .002) + \")\";\n        h ? h.attr({\n          d: s\n        }) : t.graph && (t.tracker = n.path(s).attr({\n          visibility: t.visible ? \"inherit\" : \"hidden\",\n          zIndex: 2\n        }).addClass(i ? \"highcharts-tracker-area\" : \"highcharts-tracker-line\").add(t.group), o.styledMode || t.tracker.attr({\n          \"stroke-linecap\": \"round\",\n          \"stroke-linejoin\": \"round\",\n          stroke: d,\n          fill: i ? d : \"none\",\n          \"stroke-width\": t.graph.strokeWidth() + (i ? 0 : 2 * a)\n        }), [t.tracker, t.markerGroup, t.dataLabelsGroup].forEach(function (t) {\n          t && (t.addClass(\"highcharts-tracker\").on(\"mouseover\", l).on(\"mouseout\", function (t) {\n            r.onTrackerMouseOut(t);\n          }), e.cursor && !o.styledMode && t.css({\n            cursor: e.cursor\n          }), g && t.on(\"touchstart\", l));\n        })), L(this, \"afterDrawTracker\");\n      }\n      addPoint(t, e, i, s, o) {\n        let r, n;\n        let a = this.options,\n          h = this.data,\n          l = this.chart,\n          d = this.xAxis,\n          c = d && d.hasNames && d.names,\n          p = a.data,\n          u = this.xData;\n        e = N(e, !0);\n        let g = {\n          series: this\n        };\n        this.pointClass.prototype.applyOptions.apply(g, [t]);\n        let f = g.x;\n        if (n = u.length, this.requireSorting && f < u[n - 1]) for (r = !0; n && u[n - 1] > f;) n--;\n        this.updateParallelArrays(g, \"splice\", [n, 0, 0]), this.updateParallelArrays(g, n), c && g.name && (c[f] = g.name), p.splice(n, 0, t), (r || this.processedData) && (this.data.splice(n, 0, null), this.processData()), \"point\" === a.legendType && this.generatePoints(), i && (h[0] && h[0].remove ? h[0].remove(!1) : (h.shift(), this.updateParallelArrays(g, \"shift\"), p.shift())), !1 !== o && L(this, \"addPoint\", {\n          point: g\n        }), this.isDirty = !0, this.isDirtyData = !0, e && l.redraw(s);\n      }\n      removePoint(t, e, i) {\n        let s = this,\n          o = s.data,\n          r = o[t],\n          n = s.points,\n          a = s.chart,\n          h = function () {\n            n && n.length === o.length && n.splice(t, 1), o.splice(t, 1), s.options.data.splice(t, 1), s.updateParallelArrays(r || {\n              series: s\n            }, \"splice\", [t, 1]), r && r.destroy(), s.isDirty = !0, s.isDirtyData = !0, e && a.redraw();\n          };\n        c(i, a), e = N(e, !0), r ? r.firePointEvent(\"remove\", null, h) : h();\n      }\n      remove(t, e, i, s) {\n        let o = this,\n          r = o.chart;\n        function n() {\n          o.destroy(s), r.isDirtyLegend = r.isDirtyBox = !0, r.linkSeries(s), N(t, !0) && r.redraw(e);\n        }\n        !1 !== i ? L(o, \"remove\", null, n) : n();\n      }\n      update(t, e) {\n        L(this, \"update\", {\n          options: t = C(t, this.userOptions)\n        });\n        let i = this,\n          s = i.chart,\n          o = i.userOptions,\n          r = i.initialType || i.type,\n          n = s.options.plotOptions,\n          a = x[r].prototype,\n          h = i.finishedAnimating && {\n            animation: !1\n          },\n          l = {},\n          d,\n          c,\n          p = [\"colorIndex\", \"eventOptions\", \"navigatorSeries\", \"symbolIndex\", \"baseSeries\"],\n          u = t.type || o.type || s.options.chart.type,\n          g = !(this.hasDerivedData || u && u !== this.type || void 0 !== t.pointStart || void 0 !== t.pointInterval || void 0 !== t.relativeXValue || t.joinBy || t.mapData || [\"dataGrouping\", \"pointStart\", \"pointInterval\", \"pointIntervalUnit\", \"keys\"].some(t => i.hasOptionChanged(t)));\n        u = u || r, g && (p.push(\"data\", \"isDirtyData\", \"isDirtyCanvas\", \"points\", \"processedData\", \"processedXData\", \"processedYData\", \"xIncrement\", \"cropped\", \"_hasPointMarkers\", \"hasDataLabels\", \"clips\", \"nodes\", \"layout\", \"level\", \"mapMap\", \"mapData\", \"minY\", \"maxY\", \"minX\", \"maxX\"), !1 !== t.visible && p.push(\"area\", \"graph\"), i.parallelArrays.forEach(function (t) {\n          p.push(t + \"Data\");\n        }), t.data && (t.dataSorting && A(i.options.dataSorting, t.dataSorting), this.setData(t.data, !1))), t = R(o, h, {\n          index: void 0 === o.index ? i.index : o.index,\n          pointStart: N(n?.series?.pointStart, o.pointStart, i.xData[0])\n        }, !g && {\n          data: i.options.data\n        }, t), g && t.data && (t.data = i.options.data), (p = [\"group\", \"markerGroup\", \"dataLabelsGroup\", \"transformGroup\"].concat(p)).forEach(function (t) {\n          p[t] = i[t], delete i[t];\n        });\n        let f = !1;\n        if (x[u]) {\n          if (f = u !== i.type, i.remove(!1, !1, !1, !0), f) {\n            if (Object.setPrototypeOf) Object.setPrototypeOf(i, x[u].prototype);else {\n              let t = Object.hasOwnProperty.call(i, \"hcEvents\") && i.hcEvents;\n              for (c in a) i[c] = void 0;\n              A(i, x[u].prototype), t ? i.hcEvents = t : delete i.hcEvents;\n            }\n          }\n        } else T(17, !0, s, {\n          missingModuleFor: u\n        });\n        if (p.forEach(function (t) {\n          i[t] = p[t];\n        }), i.init(s, t), g && this.points) for (let t of (!1 === (d = i.options).visible ? (l.graphic = 1, l.dataLabel = 1) : (this.hasMarkerChanged(d, o) && (l.graphic = 1), i.hasDataLabels?.() || (l.dataLabel = 1)), this.points)) t && t.series && (t.resolveColor(), Object.keys(l).length && t.destroyElements(l), !1 === d.showInLegend && t.legendItem && s.legend.destroyItem(t));\n        i.initialType = r, s.linkSeries(), f && i.linkedSeries.length && (i.isDirtyData = !0), L(this, \"afterUpdate\"), N(e, !0) && s.redraw(!!g && void 0);\n      }\n      setName(t) {\n        this.name = this.options.name = this.userOptions.name = t, this.chart.isDirtyLegend = !0;\n      }\n      hasOptionChanged(t) {\n        let e = this.chart,\n          i = this.options[t],\n          s = e.options.plotOptions,\n          o = this.userOptions[t],\n          r = N(s?.[this.type]?.[t], s?.series?.[t]);\n        return o && !M(r) ? i !== o : i !== N(r, i);\n      }\n      onMouseOver() {\n        let t = this.chart,\n          e = t.hoverSeries,\n          i = t.pointer;\n        i.setHoverChartIndex(), e && e !== this && e.onMouseOut(), this.options.events.mouseOver && L(this, \"mouseOver\"), this.setState(\"hover\"), t.hoverSeries = this;\n      }\n      onMouseOut() {\n        let t = this.options,\n          e = this.chart,\n          i = e.tooltip,\n          s = e.hoverPoint;\n        e.hoverSeries = null, s && s.onMouseOut(), this && t.events.mouseOut && L(this, \"mouseOut\"), i && !this.stickyTracking && (!i.shared || this.noSharedTooltip) && i.hide(), e.series.forEach(function (t) {\n          t.setState(\"\", !0);\n        });\n      }\n      setState(t, e) {\n        let i = this,\n          s = i.options,\n          o = i.graph,\n          r = s.inactiveOtherPoints,\n          n = s.states,\n          a = N(n[t || \"normal\"] && n[t || \"normal\"].animation, i.chart.options.chart.animation),\n          h,\n          l = s.lineWidth,\n          d = 0,\n          c = s.opacity;\n        if (t = t || \"\", i.state !== t && ([i.group, i.markerGroup, i.dataLabelsGroup].forEach(function (e) {\n          e && (i.state && e.removeClass(\"highcharts-series-\" + i.state), t && e.addClass(\"highcharts-series-\" + t));\n        }), i.state = t, !i.chart.styledMode)) {\n          if (n[t] && !1 === n[t].enabled) return;\n          if (t && (l = n[t].lineWidth || l + (n[t].lineWidthPlus || 0), c = N(n[t].opacity, c)), o && !o.dashstyle && B(l)) for (h = {\n            \"stroke-width\": l\n          }, o.animate(h, a); i[\"zone-graph-\" + d];) i[\"zone-graph-\" + d].animate(h, a), d += 1;\n          r || [i.group, i.markerGroup, i.dataLabelsGroup, i.labelBySeries].forEach(function (t) {\n            t && t.animate({\n              opacity: c\n            }, a);\n          });\n        }\n        e && r && i.points && i.setAllPointsToState(t || void 0);\n      }\n      setAllPointsToState(t) {\n        this.points.forEach(function (e) {\n          e.setState && e.setState(t);\n        });\n      }\n      setVisible(t, e) {\n        let i = this,\n          s = i.chart,\n          o = s.options.chart.ignoreHiddenSeries,\n          r = i.visible;\n        i.visible = t = i.options.visible = i.userOptions.visible = void 0 === t ? !r : t;\n        let n = t ? \"show\" : \"hide\";\n        [\"group\", \"dataLabelsGroup\", \"markerGroup\", \"tracker\", \"tt\"].forEach(t => {\n          i[t]?.[n]();\n        }), (s.hoverSeries === i || s.hoverPoint?.series === i) && i.onMouseOut(), i.legendItem && s.legend.colorizeItem(i, t), i.isDirty = !0, i.options.stacking && s.series.forEach(t => {\n          t.options.stacking && t.visible && (t.isDirty = !0);\n        }), i.linkedSeries.forEach(e => {\n          e.setVisible(t, !1);\n        }), o && (s.isDirtyBox = !0), L(i, n), !1 !== e && s.redraw();\n      }\n      show() {\n        this.setVisible(!0);\n      }\n      hide() {\n        this.setVisible(!1);\n      }\n      select(t) {\n        this.selected = t = this.options.selected = void 0 === t ? !this.selected : t, this.checkbox && (this.checkbox.checked = t), L(this, t ? \"select\" : \"unselect\");\n      }\n      shouldShowTooltip(t, e, i = {}) {\n        return i.series = this, i.visiblePlotOnly = !0, this.chart.isInsidePlot(t, e, i);\n      }\n      drawLegendSymbol(t, e) {\n        o[this.options.legendSymbol || \"rectangle\"]?.call(this, t, e);\n      }\n    }\n    return X.defaultOptions = n, X.types = a.seriesTypes, X.registerType = a.registerSeriesType, A(X.prototype, {\n      axisTypes: [\"xAxis\", \"yAxis\"],\n      coll: \"series\",\n      colorCounter: 0,\n      directTouch: !1,\n      isCartesian: !0,\n      kdAxisArray: [\"clientX\", \"plotY\"],\n      parallelArrays: [\"x\", \"y\"],\n      pointClass: r,\n      requireSorting: !0,\n      sorted: !0\n    }), a.series = X, X;\n  }), i(e, \"Core/Chart/Chart.js\", [e[\"Core/Animation/AnimationUtilities.js\"], e[\"Core/Axis/Axis.js\"], e[\"Core/Defaults.js\"], e[\"Core/Templating.js\"], e[\"Core/Foundation.js\"], e[\"Core/Globals.js\"], e[\"Core/Renderer/RendererRegistry.js\"], e[\"Core/Series/Series.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Renderer/SVG/SVGRenderer.js\"], e[\"Core/Time.js\"], e[\"Core/Utilities.js\"], e[\"Core/Renderer/HTML/AST.js\"]], function (t, e, i, s, o, r, n, a, h, l, d, c, p) {\n    let {\n        animate: u,\n        animObject: g,\n        setAnimation: f\n      } = t,\n      {\n        defaultOptions: m,\n        defaultTime: x\n      } = i,\n      {\n        numberFormat: y\n      } = s,\n      {\n        registerEventOptions: b\n      } = o,\n      {\n        charts: v,\n        doc: k,\n        marginNames: S,\n        svg: M,\n        win: C\n      } = r,\n      {\n        seriesTypes: w\n      } = h,\n      {\n        addEvent: T,\n        attr: A,\n        createElement: P,\n        css: L,\n        defined: O,\n        diffObjects: D,\n        discardElement: E,\n        erase: I,\n        error: B,\n        extend: j,\n        find: R,\n        fireEvent: z,\n        getStyle: N,\n        isArray: W,\n        isNumber: H,\n        isObject: G,\n        isString: X,\n        merge: Y,\n        objectEach: F,\n        pick: U,\n        pInt: V,\n        relativeLength: q,\n        removeEvent: Z,\n        splat: $,\n        syncTimeout: _,\n        uniqueKey: K\n      } = c;\n    class J {\n      static chart(t, e, i) {\n        return new J(t, e, i);\n      }\n      constructor(t, e, i) {\n        this.axes = void 0, this.axisOffset = void 0, this.bounds = void 0, this.chartHeight = void 0, this.chartWidth = void 0, this.clipBox = void 0, this.colorCounter = void 0, this.container = void 0, this.eventOptions = void 0, this.index = void 0, this.isResizing = void 0, this.labelCollectors = void 0, this.margin = void 0, this.numberFormatter = void 0, this.options = void 0, this.plotBox = void 0, this.plotHeight = void 0, this.plotLeft = void 0, this.plotTop = void 0, this.plotWidth = void 0, this.pointCount = void 0, this.pointer = void 0, this.renderer = void 0, this.renderTo = void 0, this.series = void 0, this.sharedClips = {}, this.spacing = void 0, this.spacingBox = void 0, this.symbolCounter = void 0, this.time = void 0, this.titleOffset = void 0, this.userOptions = void 0, this.xAxis = void 0, this.yAxis = void 0, this.zooming = void 0, this.getArgs(t, e, i);\n      }\n      getArgs(t, e, i) {\n        X(t) || t.nodeName ? (this.renderTo = t, this.init(e, i)) : this.init(t, e);\n      }\n      setZoomOptions() {\n        let t = this.options.chart,\n          e = t.zooming;\n        this.zooming = {\n          ...e,\n          type: U(t.zoomType, e.type),\n          key: U(t.zoomKey, e.key),\n          pinchType: U(t.pinchType, e.pinchType),\n          singleTouch: U(t.zoomBySingleTouch, e.singleTouch, !1),\n          resetButton: Y(e.resetButton, t.resetZoomButton)\n        };\n      }\n      init(t, e) {\n        z(this, \"init\", {\n          args: arguments\n        }, function () {\n          let i = Y(m, t),\n            s = i.chart;\n          this.userOptions = j({}, t), this.margin = [], this.spacing = [], this.bounds = {\n            h: {},\n            v: {}\n          }, this.labelCollectors = [], this.callback = e, this.isResizing = 0, this.options = i, this.axes = [], this.series = [], this.time = t.time && Object.keys(t.time).length ? new d(t.time) : r.time, this.numberFormatter = s.numberFormatter || y, this.styledMode = s.styledMode, this.hasCartesianSeries = s.showAxes, this.index = v.length, v.push(this), r.chartCount++, b(this, s), this.xAxis = [], this.yAxis = [], this.pointCount = this.colorCounter = this.symbolCounter = 0, this.setZoomOptions(), z(this, \"afterInit\"), this.firstRender();\n        });\n      }\n      initSeries(t) {\n        let e = this.options.chart,\n          i = t.type || e.type,\n          s = w[i];\n        s || B(17, !0, this, {\n          missingModuleFor: i\n        });\n        let o = new s();\n        return \"function\" == typeof o.init && o.init(this, t), o;\n      }\n      setSeriesData() {\n        this.getSeriesOrderByLinks().forEach(function (t) {\n          t.points || t.data || !t.enabledDataSorting || t.setData(t.options.data, !1);\n        });\n      }\n      getSeriesOrderByLinks() {\n        return this.series.concat().sort(function (t, e) {\n          return t.linkedSeries.length || e.linkedSeries.length ? e.linkedSeries.length - t.linkedSeries.length : 0;\n        });\n      }\n      orderItems(t, e = 0) {\n        let i = this[t],\n          s = this.options[t] = $(this.options[t]).slice(),\n          o = this.userOptions[t] = this.userOptions[t] ? $(this.userOptions[t]).slice() : [];\n        if (this.hasRendered && (s.splice(e), o.splice(e)), i) for (let t = e, r = i.length; t < r; ++t) {\n          let e = i[t];\n          e && (e.index = t, e instanceof a && (e.name = e.getName()), e.options.isInternal || (s[t] = e.options, o[t] = e.userOptions));\n        }\n      }\n      isInsidePlot(t, e, i = {}) {\n        let {\n            inverted: s,\n            plotBox: o,\n            plotLeft: r,\n            plotTop: n,\n            scrollablePlotBox: a\n          } = this,\n          h = 0,\n          l = 0;\n        i.visiblePlotOnly && this.scrollingContainer && ({\n          scrollLeft: h,\n          scrollTop: l\n        } = this.scrollingContainer);\n        let d = i.series,\n          c = i.visiblePlotOnly && a || o,\n          p = i.inverted ? e : t,\n          u = i.inverted ? t : e,\n          g = {\n            x: p,\n            y: u,\n            isInsidePlot: !0,\n            options: i\n          };\n        if (!i.ignoreX) {\n          let t = d && (s && !this.polar ? d.yAxis : d.xAxis) || {\n              pos: r,\n              len: 1 / 0\n            },\n            e = i.paneCoordinates ? t.pos + p : r + p;\n          e >= Math.max(h + r, t.pos) && e <= Math.min(h + r + c.width, t.pos + t.len) || (g.isInsidePlot = !1);\n        }\n        if (!i.ignoreY && g.isInsidePlot) {\n          let t = !s && i.axis && !i.axis.isXAxis && i.axis || d && (s ? d.xAxis : d.yAxis) || {\n              pos: n,\n              len: 1 / 0\n            },\n            e = i.paneCoordinates ? t.pos + u : n + u;\n          e >= Math.max(l + n, t.pos) && e <= Math.min(l + n + c.height, t.pos + t.len) || (g.isInsidePlot = !1);\n        }\n        return z(this, \"afterIsInsidePlot\", g), g.isInsidePlot;\n      }\n      redraw(t) {\n        z(this, \"beforeRedraw\");\n        let e = this.hasCartesianSeries ? this.axes : this.colorAxis || [],\n          i = this.series,\n          s = this.pointer,\n          o = this.legend,\n          r = this.userOptions.legend,\n          n = this.renderer,\n          a = n.isHidden(),\n          h = [],\n          l,\n          d,\n          c,\n          p = this.isDirtyBox,\n          u = this.isDirtyLegend,\n          g;\n        for (n.rootFontSize = n.boxWrapper.getStyle(\"font-size\"), this.setResponsive && this.setResponsive(!1), f(!!this.hasRendered && t, this), a && this.temporaryDisplay(), this.layOutTitles(!1), c = i.length; c--;) if (((g = i[c]).options.stacking || g.options.centerInCategory) && (d = !0, g.isDirty)) {\n          l = !0;\n          break;\n        }\n        if (l) for (c = i.length; c--;) (g = i[c]).options.stacking && (g.isDirty = !0);\n        i.forEach(function (t) {\n          t.isDirty && (\"point\" === t.options.legendType ? (\"function\" == typeof t.updateTotals && t.updateTotals(), u = !0) : r && (r.labelFormatter || r.labelFormat) && (u = !0)), t.isDirtyData && z(t, \"updatedData\");\n        }), u && o && o.options.enabled && (o.render(), this.isDirtyLegend = !1), d && this.getStacks(), e.forEach(function (t) {\n          t.updateNames(), t.setScale();\n        }), this.getMargins(), e.forEach(function (t) {\n          t.isDirty && (p = !0);\n        }), e.forEach(function (t) {\n          let e = t.min + \",\" + t.max;\n          t.extKey !== e && (t.extKey = e, h.push(function () {\n            z(t, \"afterSetExtremes\", j(t.eventArgs, t.getExtremes())), delete t.eventArgs;\n          })), (p || d) && t.redraw();\n        }), p && this.drawChartBox(), z(this, \"predraw\"), i.forEach(function (t) {\n          (p || t.isDirty) && t.visible && t.redraw(), t.isDirtyData = !1;\n        }), s && s.reset(!0), n.draw(), z(this, \"redraw\"), z(this, \"render\"), a && this.temporaryDisplay(!0), h.forEach(function (t) {\n          t.call();\n        });\n      }\n      get(t) {\n        let e = this.series;\n        function i(e) {\n          return e.id === t || e.options && e.options.id === t;\n        }\n        let s = R(this.axes, i) || R(this.series, i);\n        for (let t = 0; !s && t < e.length; t++) s = R(e[t].points || [], i);\n        return s;\n      }\n      getAxes() {\n        let t = this.options;\n        for (let i of (z(this, \"getAxes\"), [\"xAxis\", \"yAxis\"])) {\n          let s = t[i] = $(t[i] || {});\n          for (let t of s) new e(this, t, i);\n        }\n        z(this, \"afterGetAxes\");\n      }\n      getSelectedPoints() {\n        return this.series.reduce((t, e) => (e.getPointsCollection().forEach(e => {\n          U(e.selectedStaging, e.selected) && t.push(e);\n        }), t), []);\n      }\n      getSelectedSeries() {\n        return this.series.filter(function (t) {\n          return t.selected;\n        });\n      }\n      setTitle(t, e, i) {\n        this.applyDescription(\"title\", t), this.applyDescription(\"subtitle\", e), this.applyDescription(\"caption\", void 0), this.layOutTitles(i);\n      }\n      applyDescription(t, e) {\n        let i = this,\n          s = this.options[t] = Y(this.options[t], e),\n          o = this[t];\n        o && e && (this[t] = o = o.destroy()), s && !o && ((o = this.renderer.text(s.text, 0, 0, s.useHTML).attr({\n          align: s.align,\n          class: \"highcharts-\" + t,\n          zIndex: s.zIndex || 4\n        }).add()).update = function (e, s) {\n          i.applyDescription(t, e), i.layOutTitles(s);\n        }, this.styledMode || o.css(j(\"title\" === t ? {\n          fontSize: this.options.isStock ? \"1em\" : \"1.2em\"\n        } : {}, s.style)), this[t] = o);\n      }\n      layOutTitles(t = !0) {\n        let e = [0, 0, 0],\n          i = this.renderer,\n          s = this.spacingBox;\n        [\"title\", \"subtitle\", \"caption\"].forEach(function (t) {\n          let o = this[t],\n            r = this.options[t],\n            n = r.verticalAlign || \"top\",\n            a = \"title\" === t ? \"top\" === n ? -3 : 0 : \"top\" === n ? e[0] + 2 : 0;\n          if (o) {\n            o.css({\n              width: (r.width || s.width + (r.widthAdjust || 0)) + \"px\"\n            });\n            let t = i.fontMetrics(o).b,\n              h = Math.round(o.getBBox(r.useHTML).height);\n            o.align(j({\n              y: \"bottom\" === n ? t : a + t,\n              height: h\n            }, r), !1, \"spacingBox\"), r.floating || (\"top\" === n ? e[0] = Math.ceil(e[0] + h) : \"bottom\" === n && (e[2] = Math.ceil(e[2] + h)));\n          }\n        }, this), e[0] && \"top\" === (this.options.title.verticalAlign || \"top\") && (e[0] += this.options.title.margin), e[2] && \"bottom\" === this.options.caption.verticalAlign && (e[2] += this.options.caption.margin);\n        let o = !this.titleOffset || this.titleOffset.join(\",\") !== e.join(\",\");\n        this.titleOffset = e, z(this, \"afterLayOutTitles\"), !this.isDirtyBox && o && (this.isDirtyBox = this.isDirtyLegend = o, this.hasRendered && t && this.isDirtyBox && this.redraw());\n      }\n      getContainerBox() {\n        return {\n          width: N(this.renderTo, \"width\", !0) || 0,\n          height: N(this.renderTo, \"height\", !0) || 0\n        };\n      }\n      getChartSize() {\n        let t = this.options.chart,\n          e = t.width,\n          i = t.height,\n          s = this.getContainerBox();\n        this.chartWidth = Math.max(0, e || s.width || 600), this.chartHeight = Math.max(0, q(i, this.chartWidth) || (s.height > 1 ? s.height : 400)), this.containerBox = s;\n      }\n      temporaryDisplay(t) {\n        let e = this.renderTo,\n          i;\n        if (t) for (; e && e.style;) e.hcOrigStyle && (L(e, e.hcOrigStyle), delete e.hcOrigStyle), e.hcOrigDetached && (k.body.removeChild(e), e.hcOrigDetached = !1), e = e.parentNode;else for (; e && e.style && (k.body.contains(e) || e.parentNode || (e.hcOrigDetached = !0, k.body.appendChild(e)), (\"none\" === N(e, \"display\", !1) || e.hcOricDetached) && (e.hcOrigStyle = {\n          display: e.style.display,\n          height: e.style.height,\n          overflow: e.style.overflow\n        }, i = {\n          display: \"block\",\n          overflow: \"hidden\"\n        }, e !== this.renderTo && (i.height = 0), L(e, i), e.offsetWidth || e.style.setProperty(\"display\", \"block\", \"important\")), (e = e.parentNode) !== k.body););\n      }\n      setClassName(t) {\n        this.container.className = \"highcharts-container \" + (t || \"\");\n      }\n      getContainer() {\n        let t = this.options,\n          e = t.chart,\n          i = \"data-highcharts-chart\",\n          s = K(),\n          o,\n          r = this.renderTo;\n        r || (this.renderTo = r = e.renderTo), X(r) && (this.renderTo = r = k.getElementById(r)), r || B(13, !0, this);\n        let a = V(A(r, i));\n        H(a) && v[a] && v[a].hasRendered && v[a].destroy(), A(r, i, this.index), r.innerHTML = p.emptyHTML, e.skipClone || r.offsetWidth || this.temporaryDisplay(), this.getChartSize();\n        let h = this.chartWidth,\n          d = this.chartHeight;\n        L(r, {\n          overflow: \"hidden\"\n        }), this.styledMode || (o = j({\n          position: \"relative\",\n          overflow: \"hidden\",\n          width: h + \"px\",\n          height: d + \"px\",\n          textAlign: \"left\",\n          lineHeight: \"normal\",\n          zIndex: 0,\n          \"-webkit-tap-highlight-color\": \"rgba(0,0,0,0)\",\n          userSelect: \"none\",\n          \"touch-action\": \"manipulation\",\n          outline: \"none\"\n        }, e.style || {}));\n        let c = P(\"div\", {\n          id: s\n        }, o, r);\n        this.container = c, this._cursor = c.style.cursor;\n        let u = e.renderer || !M ? n.getRendererType(e.renderer) : l;\n        if (this.renderer = new u(c, h, d, void 0, e.forExport, t.exporting && t.exporting.allowHTML, this.styledMode), this.containerBox = this.getContainerBox(), f(void 0, this), this.setClassName(e.className), this.styledMode) for (let e in t.defs) this.renderer.definition(t.defs[e]);else this.renderer.setStyle(e.style);\n        this.renderer.chartIndex = this.index, z(this, \"afterGetContainer\");\n      }\n      getMargins(t) {\n        let {\n          spacing: e,\n          margin: i,\n          titleOffset: s\n        } = this;\n        this.resetMargins(), s[0] && !O(i[0]) && (this.plotTop = Math.max(this.plotTop, s[0] + e[0])), s[2] && !O(i[2]) && (this.marginBottom = Math.max(this.marginBottom, s[2] + e[2])), this.legend && this.legend.display && this.legend.adjustMargins(i, e), z(this, \"getMargins\"), t || this.getAxisMargins();\n      }\n      getAxisMargins() {\n        let t = this,\n          e = t.axisOffset = [0, 0, 0, 0],\n          i = t.colorAxis,\n          s = t.margin,\n          o = function (t) {\n            t.forEach(function (t) {\n              t.visible && t.getOffset();\n            });\n          };\n        t.hasCartesianSeries ? o(t.axes) : i && i.length && o(i), S.forEach(function (i, o) {\n          O(s[o]) || (t[i] += e[o]);\n        }), t.setChartSize();\n      }\n      getOptions() {\n        return D(this.userOptions, m);\n      }\n      reflow(t) {\n        let e = this,\n          i = e.containerBox,\n          s = e.getContainerBox();\n        delete e.pointer.chartPosition, !e.isPrinting && !e.isResizing && i && s.width && ((s.width !== i.width || s.height !== i.height) && (c.clearTimeout(e.reflowTimeout), e.reflowTimeout = _(function () {\n          e.container && e.setSize(void 0, void 0, !1);\n        }, t ? 100 : 0)), e.containerBox = s);\n      }\n      setReflow() {\n        let t = this,\n          e = e => {\n            t.options?.chart.reflow && t.hasLoaded && t.reflow(e);\n          };\n        if (\"function\" == typeof ResizeObserver) new ResizeObserver(e).observe(t.renderTo);else {\n          let t = T(C, \"resize\", e);\n          T(this, \"destroy\", t);\n        }\n      }\n      setSize(t, e, i) {\n        let s = this,\n          o = s.renderer;\n        s.isResizing += 1, f(i, s);\n        let r = o.globalAnimation;\n        s.oldChartHeight = s.chartHeight, s.oldChartWidth = s.chartWidth, void 0 !== t && (s.options.chart.width = t), void 0 !== e && (s.options.chart.height = e), s.getChartSize(), s.styledMode || (r ? u : L)(s.container, {\n          width: s.chartWidth + \"px\",\n          height: s.chartHeight + \"px\"\n        }, r), s.setChartSize(!0), o.setSize(s.chartWidth, s.chartHeight, r), s.axes.forEach(function (t) {\n          t.isDirty = !0, t.setScale();\n        }), s.isDirtyLegend = !0, s.isDirtyBox = !0, s.layOutTitles(), s.getMargins(), s.redraw(r), s.oldChartHeight = null, z(s, \"resize\"), setTimeout(() => {\n          s && z(s, \"endResize\", void 0, () => {\n            s.isResizing -= 1;\n          });\n        }, g(r).duration);\n      }\n      setChartSize(t) {\n        let e, i, s, o;\n        let r = this.inverted,\n          n = this.renderer,\n          a = this.chartWidth,\n          h = this.chartHeight,\n          l = this.options.chart,\n          d = this.spacing,\n          c = this.clipOffset;\n        this.plotLeft = e = Math.round(this.plotLeft), this.plotTop = i = Math.round(this.plotTop), this.plotWidth = s = Math.max(0, Math.round(a - e - this.marginRight)), this.plotHeight = o = Math.max(0, Math.round(h - i - this.marginBottom)), this.plotSizeX = r ? o : s, this.plotSizeY = r ? s : o, this.plotBorderWidth = l.plotBorderWidth || 0, this.spacingBox = n.spacingBox = {\n          x: d[3],\n          y: d[0],\n          width: a - d[3] - d[1],\n          height: h - d[0] - d[2]\n        }, this.plotBox = n.plotBox = {\n          x: e,\n          y: i,\n          width: s,\n          height: o\n        };\n        let p = 2 * Math.floor(this.plotBorderWidth / 2),\n          u = Math.ceil(Math.max(p, c[3]) / 2),\n          g = Math.ceil(Math.max(p, c[0]) / 2);\n        this.clipBox = {\n          x: u,\n          y: g,\n          width: Math.floor(this.plotSizeX - Math.max(p, c[1]) / 2 - u),\n          height: Math.max(0, Math.floor(this.plotSizeY - Math.max(p, c[2]) / 2 - g))\n        }, t || (this.axes.forEach(function (t) {\n          t.setAxisSize(), t.setAxisTranslation();\n        }), n.alignElements()), z(this, \"afterSetChartSize\", {\n          skipAxes: t\n        });\n      }\n      resetMargins() {\n        z(this, \"resetMargins\");\n        let t = this,\n          e = t.options.chart;\n        [\"margin\", \"spacing\"].forEach(function (i) {\n          let s = e[i],\n            o = G(s) ? s : [s, s, s, s];\n          [\"Top\", \"Right\", \"Bottom\", \"Left\"].forEach(function (s, r) {\n            t[i][r] = U(e[i + s], o[r]);\n          });\n        }), S.forEach(function (e, i) {\n          t[e] = U(t.margin[i], t.spacing[i]);\n        }), t.axisOffset = [0, 0, 0, 0], t.clipOffset = [0, 0, 0, 0];\n      }\n      drawChartBox() {\n        let t = this.options.chart,\n          e = this.renderer,\n          i = this.chartWidth,\n          s = this.chartHeight,\n          o = this.styledMode,\n          r = this.plotBGImage,\n          n = t.backgroundColor,\n          a = t.plotBackgroundColor,\n          h = t.plotBackgroundImage,\n          l = this.plotLeft,\n          d = this.plotTop,\n          c = this.plotWidth,\n          p = this.plotHeight,\n          u = this.plotBox,\n          g = this.clipRect,\n          f = this.clipBox,\n          m = this.chartBackground,\n          x = this.plotBackground,\n          y = this.plotBorder,\n          b,\n          v,\n          k,\n          S = \"animate\";\n        m || (this.chartBackground = m = e.rect().addClass(\"highcharts-background\").add(), S = \"attr\"), o ? b = v = m.strokeWidth() : (v = (b = t.borderWidth || 0) + (t.shadow ? 8 : 0), k = {\n          fill: n || \"none\"\n        }, (b || m[\"stroke-width\"]) && (k.stroke = t.borderColor, k[\"stroke-width\"] = b), m.attr(k).shadow(t.shadow)), m[S]({\n          x: v / 2,\n          y: v / 2,\n          width: i - v - b % 2,\n          height: s - v - b % 2,\n          r: t.borderRadius\n        }), S = \"animate\", x || (S = \"attr\", this.plotBackground = x = e.rect().addClass(\"highcharts-plot-background\").add()), x[S](u), !o && (x.attr({\n          fill: a || \"none\"\n        }).shadow(t.plotShadow), h && (r ? (h !== r.attr(\"href\") && r.attr(\"href\", h), r.animate(u)) : this.plotBGImage = e.image(h, l, d, c, p).add())), g ? g.animate({\n          width: f.width,\n          height: f.height\n        }) : this.clipRect = e.clipRect(f), S = \"animate\", y || (S = \"attr\", this.plotBorder = y = e.rect().addClass(\"highcharts-plot-border\").attr({\n          zIndex: 1\n        }).add()), o || y.attr({\n          stroke: t.plotBorderColor,\n          \"stroke-width\": t.plotBorderWidth || 0,\n          fill: \"none\"\n        }), y[S](y.crisp({\n          x: l,\n          y: d,\n          width: c,\n          height: p\n        }, -y.strokeWidth())), this.isDirtyBox = !1, z(this, \"afterDrawChartBox\");\n      }\n      propFromSeries() {\n        let t, e, i;\n        let s = this,\n          o = s.options.chart,\n          r = s.options.series;\n        [\"inverted\", \"angular\", \"polar\"].forEach(function (n) {\n          for (e = w[o.type], i = o[n] || e && e.prototype[n], t = r && r.length; !i && t--;) (e = w[r[t].type]) && e.prototype[n] && (i = !0);\n          s[n] = i;\n        });\n      }\n      linkSeries(t) {\n        let e = this,\n          i = e.series;\n        i.forEach(function (t) {\n          t.linkedSeries.length = 0;\n        }), i.forEach(function (t) {\n          let i = t.options.linkedTo;\n          X(i) && (i = \":previous\" === i ? e.series[t.index - 1] : e.get(i)) && i.linkedParent !== t && (i.linkedSeries.push(t), t.linkedParent = i, i.enabledDataSorting && t.setDataSortingOptions(), t.visible = U(t.options.visible, i.options.visible, t.visible));\n        }), z(this, \"afterLinkSeries\", {\n          isUpdating: t\n        });\n      }\n      renderSeries() {\n        this.series.forEach(function (t) {\n          t.translate(), t.render();\n        });\n      }\n      render() {\n        let t = this.axes,\n          e = this.colorAxis,\n          i = this.renderer,\n          s = function (t) {\n            t.forEach(function (t) {\n              t.visible && t.render();\n            });\n          },\n          o = 0;\n        this.setTitle(), z(this, \"beforeMargins\"), this.getStacks && this.getStacks(), this.getMargins(!0), this.setChartSize();\n        let r = this.plotWidth;\n        t.some(function (t) {\n          if (t.horiz && t.visible && t.options.labels.enabled && t.series.length) return o = 21, !0;\n        }), this.plotHeight = Math.max(this.plotHeight - o, 0);\n        let n = this.plotHeight;\n        t.forEach(function (t) {\n          t.setScale();\n        }), this.getAxisMargins();\n        let a = r / this.plotWidth > 1.1,\n          h = n / this.plotHeight > 1.05;\n        (a || h) && (t.forEach(function (t) {\n          (t.horiz && a || !t.horiz && h) && t.setTickInterval(!0);\n        }), this.getMargins()), this.drawChartBox(), this.hasCartesianSeries ? s(t) : e && e.length && s(e), this.seriesGroup || (this.seriesGroup = i.g(\"series-group\").attr({\n          zIndex: 3\n        }).shadow(this.options.chart.seriesGroupShadow).add()), this.renderSeries(), this.addCredits(), this.setResponsive && this.setResponsive(), this.hasRendered = !0;\n      }\n      addCredits(t) {\n        let e = this,\n          i = Y(!0, this.options.credits, t);\n        i.enabled && !this.credits && (this.credits = this.renderer.text(i.text + (this.mapCredits || \"\"), 0, 0).addClass(\"highcharts-credits\").on(\"click\", function () {\n          i.href && (C.location.href = i.href);\n        }).attr({\n          align: i.position.align,\n          zIndex: 8\n        }), e.styledMode || this.credits.css(i.style), this.credits.add().align(i.position), this.credits.update = function (t) {\n          e.credits = e.credits.destroy(), e.addCredits(t);\n        });\n      }\n      destroy() {\n        let t;\n        let e = this,\n          i = e.axes,\n          s = e.series,\n          o = e.container,\n          n = o && o.parentNode;\n        for (z(e, \"destroy\"), e.renderer.forExport ? I(v, e) : v[e.index] = void 0, r.chartCount--, e.renderTo.removeAttribute(\"data-highcharts-chart\"), Z(e), t = i.length; t--;) i[t] = i[t].destroy();\n        for (this.scroller && this.scroller.destroy && this.scroller.destroy(), t = s.length; t--;) s[t] = s[t].destroy();\n        [\"title\", \"subtitle\", \"chartBackground\", \"plotBackground\", \"plotBGImage\", \"plotBorder\", \"seriesGroup\", \"clipRect\", \"credits\", \"pointer\", \"rangeSelector\", \"legend\", \"resetZoomButton\", \"tooltip\", \"renderer\"].forEach(function (t) {\n          let i = e[t];\n          i && i.destroy && (e[t] = i.destroy());\n        }), o && (o.innerHTML = p.emptyHTML, Z(o), n && E(o)), F(e, function (t, i) {\n          delete e[i];\n        });\n      }\n      firstRender() {\n        let t = this,\n          e = t.options;\n        t.getContainer(), t.resetMargins(), t.setChartSize(), t.propFromSeries(), t.getAxes();\n        let i = W(e.series) ? e.series : [];\n        e.series = [], i.forEach(function (e) {\n          t.initSeries(e);\n        }), t.linkSeries(), t.setSeriesData(), z(t, \"beforeRender\"), t.render(), t.pointer.getChartPosition(), t.renderer.imgCount || t.hasLoaded || t.onload(), t.temporaryDisplay(!0);\n      }\n      onload() {\n        this.callbacks.concat([this.callback]).forEach(function (t) {\n          t && void 0 !== this.index && t.apply(this, [this]);\n        }, this), z(this, \"load\"), z(this, \"render\"), O(this.index) && this.setReflow(), this.warnIfA11yModuleNotLoaded(), this.hasLoaded = !0;\n      }\n      warnIfA11yModuleNotLoaded() {\n        let {\n          options: t,\n          title: e\n        } = this;\n        !t || this.accessibility || (this.renderer.boxWrapper.attr({\n          role: \"img\",\n          \"aria-label\": (e && e.element.textContent || \"\").replace(/</g, \"&lt;\")\n        }), t.accessibility && !1 === t.accessibility.enabled || B('Highcharts warning: Consider including the \"accessibility.js\" module to make your chart more usable for people with disabilities. Set the \"accessibility.enabled\" option to false to remove this warning. See https://www.highcharts.com/docs/accessibility/accessibility-module.', !1, this));\n      }\n      addSeries(t, e, i) {\n        let s;\n        let o = this;\n        return t && (e = U(e, !0), z(o, \"addSeries\", {\n          options: t\n        }, function () {\n          s = o.initSeries(t), o.isDirtyLegend = !0, o.linkSeries(), s.enabledDataSorting && s.setData(t.data, !1), z(o, \"afterAddSeries\", {\n            series: s\n          }), e && o.redraw(i);\n        })), s;\n      }\n      addAxis(t, e, i, s) {\n        return this.createAxis(e ? \"xAxis\" : \"yAxis\", {\n          axis: t,\n          redraw: i,\n          animation: s\n        });\n      }\n      addColorAxis(t, e, i) {\n        return this.createAxis(\"colorAxis\", {\n          axis: t,\n          redraw: e,\n          animation: i\n        });\n      }\n      createAxis(t, i) {\n        let s = new e(this, i.axis, t);\n        return U(i.redraw, !0) && this.redraw(i.animation), s;\n      }\n      showLoading(t) {\n        let e = this,\n          i = e.options,\n          s = i.loading,\n          o = function () {\n            r && L(r, {\n              left: e.plotLeft + \"px\",\n              top: e.plotTop + \"px\",\n              width: e.plotWidth + \"px\",\n              height: e.plotHeight + \"px\"\n            });\n          },\n          r = e.loadingDiv,\n          n = e.loadingSpan;\n        r || (e.loadingDiv = r = P(\"div\", {\n          className: \"highcharts-loading highcharts-loading-hidden\"\n        }, null, e.container)), n || (e.loadingSpan = n = P(\"span\", {\n          className: \"highcharts-loading-inner\"\n        }, null, r), T(e, \"redraw\", o)), r.className = \"highcharts-loading\", p.setElementHTML(n, U(t, i.lang.loading, \"\")), e.styledMode || (L(r, j(s.style, {\n          zIndex: 10\n        })), L(n, s.labelStyle), e.loadingShown || (L(r, {\n          opacity: 0,\n          display: \"\"\n        }), u(r, {\n          opacity: s.style.opacity || .5\n        }, {\n          duration: s.showDuration || 0\n        }))), e.loadingShown = !0, o();\n      }\n      hideLoading() {\n        let t = this.options,\n          e = this.loadingDiv;\n        e && (e.className = \"highcharts-loading highcharts-loading-hidden\", this.styledMode || u(e, {\n          opacity: 0\n        }, {\n          duration: t.loading.hideDuration || 100,\n          complete: function () {\n            L(e, {\n              display: \"none\"\n            });\n          }\n        })), this.loadingShown = !1;\n      }\n      update(t, e, i, s) {\n        let o, r, n;\n        let a = this,\n          h = {\n            credits: \"addCredits\",\n            title: \"setTitle\",\n            subtitle: \"setSubtitle\",\n            caption: \"setCaption\"\n          },\n          l = t.isResponsiveOptions,\n          c = [];\n        z(a, \"update\", {\n          options: t\n        }), l || a.setResponsive(!1, !0), t = D(t, a.options), a.userOptions = Y(a.userOptions, t);\n        let p = t.chart;\n        p && (Y(!0, a.options.chart, p), this.setZoomOptions(), \"className\" in p && a.setClassName(p.className), (\"inverted\" in p || \"polar\" in p || \"type\" in p) && (a.propFromSeries(), o = !0), \"alignTicks\" in p && (o = !0), \"events\" in p && b(this, p), F(p, function (t, e) {\n          -1 !== a.propsRequireUpdateSeries.indexOf(\"chart.\" + e) && (r = !0), -1 !== a.propsRequireDirtyBox.indexOf(e) && (a.isDirtyBox = !0), -1 !== a.propsRequireReflow.indexOf(e) && (l ? a.isDirtyBox = !0 : n = !0);\n        }), !a.styledMode && p.style && a.renderer.setStyle(a.options.chart.style || {})), !a.styledMode && t.colors && (this.options.colors = t.colors), t.time && (this.time === x && (this.time = new d(t.time)), Y(!0, a.options.time, t.time)), F(t, function (e, i) {\n          a[i] && \"function\" == typeof a[i].update ? a[i].update(e, !1) : \"function\" == typeof a[h[i]] ? a[h[i]](e) : \"colors\" !== i && -1 === a.collectionsWithUpdate.indexOf(i) && Y(!0, a.options[i], t[i]), \"chart\" !== i && -1 !== a.propsRequireUpdateSeries.indexOf(i) && (r = !0);\n        }), this.collectionsWithUpdate.forEach(function (e) {\n          t[e] && ($(t[e]).forEach(function (t, s) {\n            let o;\n            let r = O(t.id);\n            r && (o = a.get(t.id)), !o && a[e] && (o = a[e][U(t.index, s)]) && (r && O(o.options.id) || o.options.isInternal) && (o = void 0), o && o.coll === e && (o.update(t, !1), i && (o.touched = !0)), !o && i && a.collectionsWithInit[e] && (a.collectionsWithInit[e][0].apply(a, [t].concat(a.collectionsWithInit[e][1] || []).concat([!1])).touched = !0);\n          }), i && a[e].forEach(function (t) {\n            t.touched || t.options.isInternal ? delete t.touched : c.push(t);\n          }));\n        }), c.forEach(function (t) {\n          t.chart && t.remove && t.remove(!1);\n        }), o && a.axes.forEach(function (t) {\n          t.update({}, !1);\n        }), r && a.getSeriesOrderByLinks().forEach(function (t) {\n          t.chart && t.update({}, !1);\n        }, this);\n        let u = p && p.width,\n          g = p && (X(p.height) ? q(p.height, u || a.chartWidth) : p.height);\n        n || H(u) && u !== a.chartWidth || H(g) && g !== a.chartHeight ? a.setSize(u, g, s) : U(e, !0) && a.redraw(s), z(a, \"afterUpdate\", {\n          options: t,\n          redraw: e,\n          animation: s\n        });\n      }\n      setSubtitle(t, e) {\n        this.applyDescription(\"subtitle\", t), this.layOutTitles(e);\n      }\n      setCaption(t, e) {\n        this.applyDescription(\"caption\", t), this.layOutTitles(e);\n      }\n      showResetZoom() {\n        let t = this,\n          e = m.lang,\n          i = t.zooming.resetButton,\n          s = i.theme,\n          o = \"chart\" === i.relativeTo || \"spacingBox\" === i.relativeTo ? null : \"scrollablePlotBox\";\n        function r() {\n          t.zoomOut();\n        }\n        z(this, \"beforeShowResetZoom\", null, function () {\n          t.resetZoomButton = t.renderer.button(e.resetZoom, null, null, r, s).attr({\n            align: i.position.align,\n            title: e.resetZoomTitle\n          }).addClass(\"highcharts-reset-zoom\").add().align(i.position, !1, o);\n        }), z(this, \"afterShowResetZoom\");\n      }\n      zoomOut() {\n        z(this, \"selection\", {\n          resetSelection: !0\n        }, this.zoom);\n      }\n      zoom(t) {\n        let e = this,\n          i = e.pointer,\n          s = !1,\n          o;\n        !t || t.resetSelection ? (e.axes.forEach(function (t) {\n          o = t.zoom();\n        }), i.initiated = !1) : t.xAxis.concat(t.yAxis).forEach(function (t) {\n          let r = t.axis,\n            n = r.isXAxis,\n            {\n              hasPinched: a,\n              mouseDownX: h,\n              mouseDownY: l\n            } = i;\n          (i[n ? \"zoomX\" : \"zoomY\"] && O(h) && O(l) && e.isInsidePlot(h - e.plotLeft, l - e.plotTop, {\n            axis: r,\n            ignoreX: a,\n            ignoreY: a\n          }) || !O(e.inverted ? h : l)) && (o = r.zoom(t.min, t.max), r.displayBtn && (s = !0));\n        });\n        let r = e.resetZoomButton;\n        s && !r ? e.showResetZoom() : !s && G(r) && (e.resetZoomButton = r.destroy()), o && e.redraw(U(e.options.chart.animation, t && t.animation, e.pointCount < 100));\n      }\n      pan(t, e) {\n        let i;\n        let s = this,\n          o = s.hoverPoints,\n          r = \"object\" == typeof e ? e : {\n            enabled: e,\n            type: \"x\"\n          },\n          n = s.options.chart;\n        n && n.panning && (n.panning = r);\n        let a = r.type;\n        z(this, \"pan\", {\n          originalEvent: t\n        }, function () {\n          o && o.forEach(function (t) {\n            t.setState();\n          });\n          let e = s.xAxis;\n          \"xy\" === a ? e = e.concat(s.yAxis) : \"y\" === a && (e = s.yAxis);\n          let r = {};\n          e.forEach(function (e) {\n            if (!e.options.panningEnabled || e.options.isInternal) return;\n            let o = e.horiz,\n              n = t[o ? \"chartX\" : \"chartY\"],\n              h = o ? \"mouseDownX\" : \"mouseDownY\",\n              l = s[h],\n              d = e.minPointOffset || 0,\n              c = e.reversed && !s.inverted || !e.reversed && s.inverted ? -1 : 1,\n              p = e.getExtremes(),\n              u = e.toValue(l - n, !0) + d * c,\n              g = e.toValue(l + e.len - n, !0) - (d * c || e.isXAxis && e.pointRangePadding || 0),\n              f = g < u,\n              m = e.hasVerticalPanning(),\n              x = f ? g : u,\n              y = f ? u : g,\n              b = e.panningState,\n              v;\n            m && !e.isXAxis && (!b || b.isDirty) && e.series.forEach(function (t) {\n              let e = t.getProcessedData(!0),\n                i = t.getExtremes(e.yData, !0);\n              b || (b = {\n                startMin: Number.MAX_VALUE,\n                startMax: -Number.MAX_VALUE\n              }), H(i.dataMin) && H(i.dataMax) && (b.startMin = Math.min(U(t.options.threshold, 1 / 0), i.dataMin, b.startMin), b.startMax = Math.max(U(t.options.threshold, -1 / 0), i.dataMax, b.startMax));\n            });\n            let k = Math.min(U(b && b.startMin, p.dataMin), d ? p.min : e.toValue(e.toPixels(p.min) - e.minPixelPadding)),\n              S = Math.max(U(b && b.startMax, p.dataMax), d ? p.max : e.toValue(e.toPixels(p.max) + e.minPixelPadding));\n            e.panningState = b, e.isOrdinal || ((v = k - x) > 0 && (y += v, x = k), (v = y - S) > 0 && (y = S, x -= v), e.series.length && x !== p.min && y !== p.max && x >= k && y <= S && (e.setExtremes(x, y, !1, !1, {\n              trigger: \"pan\"\n            }), !s.resetZoomButton && x !== k && y !== S && a.match(\"y\") && (s.showResetZoom(), e.displayBtn = !1), i = !0), r[h] = n);\n          }), F(r, (t, e) => {\n            s[e] = t;\n          }), i && s.redraw(!1), L(s.container, {\n            cursor: \"move\"\n          });\n        });\n      }\n    }\n    return j(J.prototype, {\n      callbacks: [],\n      collectionsWithInit: {\n        xAxis: [J.prototype.addAxis, [!0]],\n        yAxis: [J.prototype.addAxis, [!1]],\n        series: [J.prototype.addSeries]\n      },\n      collectionsWithUpdate: [\"xAxis\", \"yAxis\", \"series\"],\n      propsRequireDirtyBox: [\"backgroundColor\", \"borderColor\", \"borderWidth\", \"borderRadius\", \"plotBackgroundColor\", \"plotBackgroundImage\", \"plotBorderColor\", \"plotBorderWidth\", \"plotShadow\", \"shadow\"],\n      propsRequireReflow: [\"margin\", \"marginTop\", \"marginRight\", \"marginBottom\", \"marginLeft\", \"spacing\", \"spacingTop\", \"spacingRight\", \"spacingBottom\", \"spacingLeft\"],\n      propsRequireUpdateSeries: [\"chart.inverted\", \"chart.polar\", \"chart.ignoreHiddenSeries\", \"chart.type\", \"colors\", \"plotOptions\", \"time\", \"tooltip\"]\n    }), J;\n  }), i(e, \"Extensions/ScrollablePlotArea.js\", [e[\"Core/Animation/AnimationUtilities.js\"], e[\"Core/Axis/Axis.js\"], e[\"Core/Chart/Chart.js\"], e[\"Core/Series/Series.js\"], e[\"Core/Renderer/RendererRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s, o, r) {\n    let {\n        stop: n\n      } = t,\n      {\n        addEvent: a,\n        createElement: h,\n        defined: l,\n        merge: d,\n        pick: c\n      } = r;\n    a(i, \"afterSetChartSize\", function (t) {\n      let i = this.options.chart.scrollablePlotArea,\n        s = i && i.minWidth,\n        o = i && i.minHeight,\n        r,\n        n,\n        a;\n      this.renderer.forExport || (s ? (this.scrollablePixelsX = r = Math.max(0, s - this.chartWidth), r && (this.scrollablePlotBox = this.renderer.scrollablePlotBox = d(this.plotBox), this.plotBox.width = this.plotWidth += r, this.inverted ? this.clipBox.height += r : this.clipBox.width += r, a = {\n        1: {\n          name: \"right\",\n          value: r\n        }\n      })) : o && (this.scrollablePixelsY = n = Math.max(0, o - this.chartHeight), l(n) && (this.scrollablePlotBox = this.renderer.scrollablePlotBox = d(this.plotBox), this.plotBox.height = this.plotHeight += n, this.inverted ? this.clipBox.width += n : this.clipBox.height += n, a = {\n        2: {\n          name: \"bottom\",\n          value: n\n        }\n      })), a && !t.skipAxes && this.axes.forEach(function (t) {\n        a[t.side] ? t.getPlotLinePath = function () {\n          let i = a[t.side].name,\n            s = a[t.side].value,\n            o = this[i],\n            r;\n          return this[i] = o - s, r = e.prototype.getPlotLinePath.apply(this, arguments), this[i] = o, r;\n        } : (t.setAxisSize(), t.setAxisTranslation());\n      }));\n    }), a(i, \"render\", function () {\n      this.scrollablePixelsX || this.scrollablePixelsY ? (this.setUpScrolling && this.setUpScrolling(), this.applyFixed()) : this.fixedDiv && this.applyFixed();\n    }), i.prototype.setUpScrolling = function () {\n      let t;\n      let e = {\n        WebkitOverflowScrolling: \"touch\",\n        overflowX: \"hidden\",\n        overflowY: \"hidden\"\n      };\n      this.scrollablePixelsX && (e.overflowX = \"auto\"), this.scrollablePixelsY && (e.overflowY = \"auto\"), this.scrollingParent = h(\"div\", {\n        className: \"highcharts-scrolling-parent\"\n      }, {\n        position: \"relative\"\n      }, this.renderTo), this.scrollingContainer = h(\"div\", {\n        className: \"highcharts-scrolling\"\n      }, e, this.scrollingParent), a(this.scrollingContainer, \"scroll\", () => {\n        this.pointer && (delete this.pointer.chartPosition, this.hoverPoint && (t = this.hoverPoint), this.pointer.runPointActions(void 0, t, !0));\n      }), this.innerContainer = h(\"div\", {\n        className: \"highcharts-inner-container\"\n      }, null, this.scrollingContainer), this.innerContainer.appendChild(this.container), this.setUpScrolling = null;\n    }, i.prototype.moveFixedElements = function () {\n      let t = this.container,\n        e = this.fixedRenderer,\n        i = [\".highcharts-breadcrumbs-group\", \".highcharts-contextbutton\", \".highcharts-credits\", \".highcharts-legend\", \".highcharts-legend-checkbox\", \".highcharts-navigator-series\", \".highcharts-navigator-xaxis\", \".highcharts-navigator-yaxis\", \".highcharts-navigator\", \".highcharts-reset-zoom\", \".highcharts-drillup-button\", \".highcharts-scrollbar\", \".highcharts-subtitle\", \".highcharts-title\"],\n        s;\n      this.scrollablePixelsX && !this.inverted ? s = \".highcharts-yaxis\" : this.scrollablePixelsX && this.inverted ? s = \".highcharts-xaxis\" : this.scrollablePixelsY && !this.inverted ? s = \".highcharts-xaxis\" : this.scrollablePixelsY && this.inverted && (s = \".highcharts-yaxis\"), s && i.push(`${s}:not(.highcharts-radial-axis)`, `${s}-labels:not(.highcharts-radial-axis-labels)`), i.forEach(function (i) {\n        [].forEach.call(t.querySelectorAll(i), function (t) {\n          (t.namespaceURI === e.SVG_NS ? e.box : e.box.parentNode).appendChild(t), t.style.pointerEvents = \"auto\";\n        });\n      });\n    }, i.prototype.applyFixed = function () {\n      let t, e, i;\n      let s = !this.fixedDiv,\n        r = this.options.chart,\n        l = r.scrollablePlotArea,\n        d = o.getRendererType();\n      s ? (this.fixedDiv = h(\"div\", {\n        className: \"highcharts-fixed\"\n      }, {\n        position: \"absolute\",\n        overflow: \"hidden\",\n        pointerEvents: \"none\",\n        zIndex: (r.style && r.style.zIndex || 0) + 2,\n        top: 0\n      }, null, !0), this.scrollingContainer && this.scrollingContainer.parentNode.insertBefore(this.fixedDiv, this.scrollingContainer), this.renderTo.style.overflow = \"visible\", this.fixedRenderer = t = new d(this.fixedDiv, this.chartWidth, this.chartHeight, this.options.chart.style), this.scrollableMask = t.path().attr({\n        fill: this.options.chart.backgroundColor || \"#fff\",\n        \"fill-opacity\": c(l.opacity, .85),\n        zIndex: -1\n      }).addClass(\"highcharts-scrollable-mask\").add(), a(this, \"afterShowResetZoom\", this.moveFixedElements), a(this, \"afterApplyDrilldown\", this.moveFixedElements), a(this, \"afterLayOutTitles\", this.moveFixedElements)) : this.fixedRenderer.setSize(this.chartWidth, this.chartHeight), (this.scrollableDirty || s) && (this.scrollableDirty = !1, this.moveFixedElements()), e = this.chartWidth + (this.scrollablePixelsX || 0), i = this.chartHeight + (this.scrollablePixelsY || 0), n(this.container), this.container.style.width = e + \"px\", this.container.style.height = i + \"px\", this.renderer.boxWrapper.attr({\n        width: e,\n        height: i,\n        viewBox: [0, 0, e, i].join(\" \")\n      }), this.chartBackground.attr({\n        width: e,\n        height: i\n      }), this.scrollingContainer.style.height = this.chartHeight + \"px\", s && (l.scrollPositionX && (this.scrollingContainer.scrollLeft = this.scrollablePixelsX * l.scrollPositionX), l.scrollPositionY && (this.scrollingContainer.scrollTop = this.scrollablePixelsY * l.scrollPositionY));\n      let p = this.axisOffset,\n        u = this.plotTop - p[0] - 1,\n        g = this.plotLeft - p[3] - 1,\n        f = this.plotTop + this.plotHeight + p[2] + 1,\n        m = this.plotLeft + this.plotWidth + p[1] + 1,\n        x = this.plotLeft + this.plotWidth - (this.scrollablePixelsX || 0),\n        y = this.plotTop + this.plotHeight - (this.scrollablePixelsY || 0),\n        b;\n      b = this.scrollablePixelsX ? [[\"M\", 0, u], [\"L\", this.plotLeft - 1, u], [\"L\", this.plotLeft - 1, f], [\"L\", 0, f], [\"Z\"], [\"M\", x, u], [\"L\", this.chartWidth, u], [\"L\", this.chartWidth, f], [\"L\", x, f], [\"Z\"]] : this.scrollablePixelsY ? [[\"M\", g, 0], [\"L\", g, this.plotTop - 1], [\"L\", m, this.plotTop - 1], [\"L\", m, 0], [\"Z\"], [\"M\", g, y], [\"L\", g, this.chartHeight], [\"L\", m, this.chartHeight], [\"L\", m, y], [\"Z\"]] : [[\"M\", 0, 0]], \"adjustHeight\" !== this.redrawTrigger && this.scrollableMask.attr({\n        d: b\n      });\n    }, a(e, \"afterInit\", function () {\n      this.chart.scrollableDirty = !0;\n    }), a(s, \"show\", function () {\n      this.chart.scrollableDirty = !0;\n    });\n  }), i(e, \"Core/Axis/Stacking/StackItem.js\", [e[\"Core/Templating.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    let {\n        format: s\n      } = t,\n      {\n        series: o\n      } = e,\n      {\n        destroyObjectProperties: r,\n        fireEvent: n,\n        isNumber: a,\n        pick: h\n      } = i;\n    return class {\n      constructor(t, e, i, s, o) {\n        let r = t.chart.inverted,\n          n = t.reversed;\n        this.axis = t;\n        let a = this.isNegative = !!i != !!n;\n        this.options = e = e || {}, this.x = s, this.total = null, this.cumulative = null, this.points = {}, this.hasValidPoints = !1, this.stack = o, this.leftCliff = 0, this.rightCliff = 0, this.alignOptions = {\n          align: e.align || (r ? a ? \"left\" : \"right\" : \"center\"),\n          verticalAlign: e.verticalAlign || (r ? \"middle\" : a ? \"bottom\" : \"top\"),\n          y: e.y,\n          x: e.x\n        }, this.textAlign = e.textAlign || (r ? a ? \"right\" : \"left\" : \"center\");\n      }\n      destroy() {\n        r(this, this.axis);\n      }\n      render(t) {\n        let e = this.axis.chart,\n          i = this.options,\n          o = i.format,\n          r = o ? s(o, this, e) : i.formatter.call(this);\n        if (this.label) this.label.attr({\n          text: r,\n          visibility: \"hidden\"\n        });else {\n          this.label = e.renderer.label(r, null, void 0, i.shape, void 0, void 0, i.useHTML, !1, \"stack-labels\");\n          let s = {\n            r: i.borderRadius || 0,\n            text: r,\n            padding: h(i.padding, 5),\n            visibility: \"hidden\"\n          };\n          e.styledMode || (s.fill = i.backgroundColor, s.stroke = i.borderColor, s[\"stroke-width\"] = i.borderWidth, this.label.css(i.style || {})), this.label.attr(s), this.label.added || this.label.add(t);\n        }\n        this.label.labelrank = e.plotSizeY, n(this, \"afterRender\");\n      }\n      setOffset(t, e, i, s, r, l) {\n        let {\n            alignOptions: d,\n            axis: c,\n            label: p,\n            options: u,\n            textAlign: g\n          } = this,\n          f = c.chart,\n          m = this.getStackBox({\n            xOffset: t,\n            width: e,\n            boxBottom: i,\n            boxTop: s,\n            defaultX: r,\n            xAxis: l\n          }),\n          {\n            verticalAlign: x\n          } = d;\n        if (p && m) {\n          let t = p.getBBox(),\n            e = p.padding,\n            i = \"justify\" === h(u.overflow, \"justify\"),\n            s;\n          d.x = u.x || 0, d.y = u.y || 0;\n          let {\n            x: r,\n            y: n\n          } = this.adjustStackPosition({\n            labelBox: t,\n            verticalAlign: x,\n            textAlign: g\n          });\n          m.x -= r, m.y -= n, p.align(d, !1, m), (s = f.isInsidePlot(p.alignAttr.x + d.x + r, p.alignAttr.y + d.y + n)) || (i = !1), i && o.prototype.justifyDataLabel.call(c, p, d, p.alignAttr, t, m), p.attr({\n            x: p.alignAttr.x,\n            y: p.alignAttr.y,\n            rotation: u.rotation,\n            rotationOriginX: t.width / 2,\n            rotationOriginY: t.height / 2\n          }), h(!i && u.crop, !0) && (s = a(p.x) && a(p.y) && f.isInsidePlot(p.x - e + (p.width || 0), p.y) && f.isInsidePlot(p.x + e, p.y)), p[s ? \"show\" : \"hide\"]();\n        }\n        n(this, \"afterSetOffset\", {\n          xOffset: t,\n          width: e\n        });\n      }\n      adjustStackPosition({\n        labelBox: t,\n        verticalAlign: e,\n        textAlign: i\n      }) {\n        let s = {\n            bottom: 0,\n            middle: 1,\n            top: 2,\n            right: 1,\n            center: 0,\n            left: -1\n          },\n          o = s[e],\n          r = s[i];\n        return {\n          x: t.width / 2 + t.width / 2 * r,\n          y: t.height / 2 * o\n        };\n      }\n      getStackBox(t) {\n        let e = this.axis,\n          i = e.chart,\n          {\n            boxTop: s,\n            defaultX: o,\n            xOffset: r,\n            width: n,\n            boxBottom: l\n          } = t,\n          d = e.stacking.usePercentage ? 100 : h(s, this.total, 0),\n          c = e.toPixels(d),\n          p = t.xAxis || i.xAxis[0],\n          u = h(o, p.translate(this.x)) + r,\n          g = e.toPixels(l || a(e.min) && e.logarithmic && e.logarithmic.lin2log(e.min) || 0),\n          f = Math.abs(c - g),\n          m = i.inverted,\n          x = this.isNegative;\n        return m ? {\n          x: (x ? c : c - f) - i.plotLeft,\n          y: p.height - u - n,\n          width: f,\n          height: n\n        } : {\n          x: u + p.transB - i.plotLeft,\n          y: (x ? c - f : c) - i.plotTop,\n          width: n,\n          height: f\n        };\n      }\n    };\n  }), i(e, \"Core/Axis/Stacking/StackingAxis.js\", [e[\"Core/Animation/AnimationUtilities.js\"], e[\"Core/Axis/Axis.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Axis/Stacking/StackItem.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s, o) {\n    var r;\n    let {\n        getDeferredAnimation: n\n      } = t,\n      {\n        series: {\n          prototype: a\n        }\n      } = i,\n      {\n        addEvent: h,\n        correctFloat: l,\n        defined: d,\n        destroyObjectProperties: c,\n        fireEvent: p,\n        isArray: u,\n        isNumber: g,\n        objectEach: f,\n        pick: m\n      } = o;\n    function x() {\n      let t = this.inverted;\n      this.axes.forEach(t => {\n        t.stacking && t.stacking.stacks && t.hasVisibleSeries && (t.stacking.oldStacks = t.stacking.stacks);\n      }), this.series.forEach(e => {\n        let i = e.xAxis && e.xAxis.options || {};\n        e.options.stacking && e.reserveSpace() && (e.stackKey = [e.type, m(e.options.stack, \"\"), t ? i.top : i.left, t ? i.height : i.width].join(\",\"));\n      });\n    }\n    function y() {\n      let t = this.stacking;\n      if (t) {\n        let e = t.stacks;\n        f(e, (t, i) => {\n          c(t), delete e[i];\n        }), t.stackTotalGroup?.destroy();\n      }\n    }\n    function b() {\n      this.stacking || (this.stacking = new w(this));\n    }\n    function v(t, e, i, s) {\n      return !d(t) || t.x !== e || s && t.stackKey !== s ? t = {\n        x: e,\n        index: 0,\n        key: s,\n        stackKey: s\n      } : t.index++, t.key = [i, e, t.index].join(\",\"), t;\n    }\n    function k() {\n      let t;\n      let e = this,\n        i = e.yAxis,\n        s = e.stackKey || \"\",\n        o = i.stacking.stacks,\n        r = e.processedXData,\n        n = e.options.stacking,\n        a = e[n + \"Stacker\"];\n      a && [s, \"-\" + s].forEach(i => {\n        let s = r.length,\n          n,\n          h,\n          l;\n        for (; s--;) n = r[s], t = e.getStackIndicator(t, n, e.index, i), h = o[i]?.[n], (l = h?.points[t.key || \"\"]) && a.call(e, l, h, s);\n      });\n    }\n    function S(t, e, i) {\n      let s = e.total ? 100 / e.total : 0;\n      t[0] = l(t[0] * s), t[1] = l(t[1] * s), this.stackedYData[i] = t[1];\n    }\n    function M(t) {\n      this.options.centerInCategory && (this.is(\"column\") || this.is(\"columnrange\")) && !this.options.stacking && this.chart.series.length > 1 ? a.setStackedPoints.call(this, t, \"group\") : t.stacking.resetStacks();\n    }\n    function C(t, e) {\n      let i, o, r, n, a, h, c, p, g;\n      let f = e || this.options.stacking;\n      if (!f || !this.reserveSpace() || ({\n        group: \"xAxis\"\n      }[f] || \"yAxis\") !== t.coll) return;\n      let x = this.processedXData,\n        y = this.processedYData,\n        b = [],\n        v = y.length,\n        k = this.options,\n        S = k.threshold || 0,\n        M = k.startFromThreshold ? S : 0,\n        C = k.stack,\n        w = e ? `${this.type},${f}` : this.stackKey || \"\",\n        T = \"-\" + w,\n        A = this.negStacks,\n        P = t.stacking,\n        L = P.stacks,\n        O = P.oldStacks;\n      for (P.stacksTouched += 1, c = 0; c < v; c++) {\n        p = x[c], g = y[c], h = (i = this.getStackIndicator(i, p, this.index)).key || \"\", L[a = (o = A && g < (M ? 0 : S)) ? T : w] || (L[a] = {}), L[a][p] || (O[a]?.[p] ? (L[a][p] = O[a][p], L[a][p].total = null) : L[a][p] = new s(t, t.options.stackLabels, !!o, p, C)), r = L[a][p], null !== g ? (r.points[h] = r.points[this.index] = [m(r.cumulative, M)], d(r.cumulative) || (r.base = h), r.touched = P.stacksTouched, i.index > 0 && !1 === this.singleStacks && (r.points[h][0] = r.points[this.index + \",\" + p + \",0\"][0])) : (delete r.points[h], delete r.points[this.index]);\n        let e = r.total || 0;\n        \"percent\" === f ? (n = o ? w : T, e = A && L[n]?.[p] ? (n = L[n][p]).total = Math.max(n.total || 0, e) + Math.abs(g) || 0 : l(e + (Math.abs(g) || 0))) : \"group\" === f ? (u(g) && (g = g[0]), null !== g && e++) : e = l(e + (g || 0)), \"group\" === f ? r.cumulative = (e || 1) - 1 : r.cumulative = l(m(r.cumulative, M) + (g || 0)), r.total = e, null !== g && (r.points[h].push(r.cumulative), b[c] = r.cumulative, r.hasValidPoints = !0);\n      }\n      \"percent\" === f && (P.usePercentage = !0), \"group\" !== f && (this.stackedYData = b), P.oldStacks = {};\n    }\n    class w {\n      constructor(t) {\n        this.oldStacks = {}, this.stacks = {}, this.stacksTouched = 0, this.axis = t;\n      }\n      buildStacks() {\n        let t, e;\n        let i = this.axis,\n          s = i.series,\n          o = \"xAxis\" === i.coll,\n          r = i.options.reversedStacks,\n          n = s.length;\n        for (this.resetStacks(), this.usePercentage = !1, e = n; e--;) t = s[r ? e : n - e - 1], o && t.setGroupedPoints(i), t.setStackedPoints(i);\n        if (!o) for (e = 0; e < n; e++) s[e].modifyStacks();\n        p(i, \"afterBuildStacks\");\n      }\n      cleanStacks() {\n        this.oldStacks && (this.stacks = this.oldStacks, f(this.stacks, t => {\n          f(t, t => {\n            t.cumulative = t.total;\n          });\n        }));\n      }\n      resetStacks() {\n        f(this.stacks, t => {\n          f(t, (e, i) => {\n            g(e.touched) && e.touched < this.stacksTouched ? (e.destroy(), delete t[i]) : (e.total = null, e.cumulative = null);\n          });\n        });\n      }\n      renderStackTotals() {\n        let t = this.axis,\n          e = t.chart,\n          i = e.renderer,\n          s = this.stacks,\n          o = t.options.stackLabels?.animation,\n          r = n(e, o || !1),\n          a = this.stackTotalGroup = this.stackTotalGroup || i.g(\"stack-labels\").attr({\n            zIndex: 6,\n            opacity: 0\n          }).add();\n        a.translate(e.plotLeft, e.plotTop), f(s, t => {\n          f(t, t => {\n            t.render(a);\n          });\n        }), a.animate({\n          opacity: 1\n        }, r);\n      }\n    }\n    return function (t) {\n      let e = [];\n      t.compose = function (t, i, s) {\n        if (o.pushUnique(e, t) && (h(t, \"init\", b), h(t, \"destroy\", y)), o.pushUnique(e, i)) {\n          let t = i.prototype;\n          t.getStacks = x;\n        }\n        if (o.pushUnique(e, s)) {\n          let t = s.prototype;\n          t.getStackIndicator = v, t.modifyStacks = k, t.percentStacker = S, t.setGroupedPoints = M, t.setStackedPoints = C;\n        }\n      };\n    }(r || (r = {})), r;\n  }), i(e, \"Series/Line/LineSeries.js\", [e[\"Core/Series/Series.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    let {\n      defined: s,\n      merge: o,\n      isObject: r\n    } = i;\n    class n extends t {\n      constructor() {\n        super(...arguments), this.data = void 0, this.options = void 0, this.points = void 0;\n      }\n      drawGraph() {\n        let t = this,\n          e = this.options,\n          i = (this.gappedPath || this.getGraphPath).call(this),\n          s = this.chart.styledMode,\n          n = [[\"graph\", \"highcharts-graph\"]];\n        s || n[0].push(e.lineColor || this.color || \"#cccccc\", e.dashStyle), (n = t.getZonesGraphs(n)).forEach(function (n, a) {\n          let h = n[0],\n            l,\n            d = t[h],\n            c = d ? \"animate\" : \"attr\";\n          d ? (d.endX = t.preventGraphAnimation ? null : i.xMap, d.animate({\n            d: i\n          })) : i.length && (t[h] = d = t.chart.renderer.path(i).addClass(n[1]).attr({\n            zIndex: 1\n          }).add(t.group)), d && !s && (l = {\n            stroke: n[2],\n            \"stroke-width\": e.lineWidth || 0,\n            fill: t.fillGraph && t.color || \"none\"\n          }, n[3] ? l.dashstyle = n[3] : \"square\" !== e.linecap && (l[\"stroke-linecap\"] = l[\"stroke-linejoin\"] = \"round\"), d[c](l).shadow(a < 2 && e.shadow && o({\n            filterUnits: \"userSpaceOnUse\"\n          }, r(e.shadow) ? e.shadow : {}))), d && (d.startX = i.xMap, d.isArea = i.isArea);\n        });\n      }\n      getGraphPath(t, e, i) {\n        let o = this,\n          r = o.options,\n          n = [],\n          a = [],\n          h,\n          l = r.step;\n        t = t || o.points;\n        let d = t.reversed;\n        return d && t.reverse(), (l = {\n          right: 1,\n          center: 2\n        }[l] || l && 3) && d && (l = 4 - l), (t = this.getValidPoints(t, !1, !(r.connectNulls && !e && !i))).forEach(function (d, c) {\n          let p;\n          let u = d.plotX,\n            g = d.plotY,\n            f = t[c - 1],\n            m = d.isNull || \"number\" != typeof g;\n          (d.leftCliff || f && f.rightCliff) && !i && (h = !0), m && !s(e) && c > 0 ? h = !r.connectNulls : m && !e ? h = !0 : (0 === c || h ? p = [[\"M\", d.plotX, d.plotY]] : o.getPointSpline ? p = [o.getPointSpline(t, d, c)] : l ? (p = 1 === l ? [[\"L\", f.plotX, g]] : 2 === l ? [[\"L\", (f.plotX + u) / 2, f.plotY], [\"L\", (f.plotX + u) / 2, g]] : [[\"L\", u, f.plotY]]).push([\"L\", u, g]) : p = [[\"L\", u, g]], a.push(d.x), l && (a.push(d.x), 2 === l && a.push(d.x)), n.push.apply(n, p), h = !1);\n        }), n.xMap = a, o.graphPath = n, n;\n      }\n      getZonesGraphs(t) {\n        return this.zones.forEach(function (e, i) {\n          let s = [\"zone-graph-\" + i, \"highcharts-graph highcharts-zone-graph-\" + i + \" \" + (e.className || \"\")];\n          this.chart.styledMode || s.push(e.color || this.color, e.dashStyle || this.options.dashStyle), t.push(s);\n        }, this), t;\n      }\n    }\n    return n.defaultOptions = o(t.defaultOptions, {\n      legendSymbol: \"lineMarker\"\n    }), e.registerSeriesType(\"line\", n), n;\n  }), i(e, \"Series/Area/AreaSeries.js\", [e[\"Core/Color/Color.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    let {\n        parse: s\n      } = t,\n      {\n        seriesTypes: {\n          line: o\n        }\n      } = e,\n      {\n        extend: r,\n        merge: n,\n        objectEach: a,\n        pick: h\n      } = i;\n    class l extends o {\n      constructor() {\n        super(...arguments), this.data = void 0, this.options = void 0, this.points = void 0;\n      }\n      drawGraph() {\n        this.areaPath = [], super.drawGraph.apply(this);\n        let t = this,\n          e = this.areaPath,\n          i = this.options,\n          s = this.zones,\n          o = [[\"area\", \"highcharts-area\", this.color, i.fillColor]];\n        s.forEach(function (e, s) {\n          o.push([\"zone-area-\" + s, \"highcharts-area highcharts-zone-area-\" + s + \" \" + e.className, e.color || t.color, e.fillColor || i.fillColor]);\n        }), o.forEach(function (s) {\n          let o = s[0],\n            r = {},\n            n = t[o],\n            a = n ? \"animate\" : \"attr\";\n          n ? (n.endX = t.preventGraphAnimation ? null : e.xMap, n.animate({\n            d: e\n          })) : (r.zIndex = 0, (n = t[o] = t.chart.renderer.path(e).addClass(s[1]).add(t.group)).isArea = !0), t.chart.styledMode || (s[3] ? r.fill = s[3] : (r.fill = s[2], r[\"fill-opacity\"] = h(i.fillOpacity, .75))), n[a](r), n.startX = e.xMap, n.shiftUnit = i.step ? 2 : 1;\n        });\n      }\n      getGraphPath(t) {\n        let e, i, s;\n        let r = o.prototype.getGraphPath,\n          n = this.options,\n          a = n.stacking,\n          l = this.yAxis,\n          d = [],\n          c = [],\n          p = this.index,\n          u = l.stacking.stacks[this.stackKey],\n          g = n.threshold,\n          f = Math.round(l.getThreshold(n.threshold)),\n          m = h(n.connectNulls, \"percent\" === a),\n          x = function (i, s, o) {\n            let r = t[i],\n              n = a && u[r.x].points[p],\n              h = r[o + \"Null\"] || 0,\n              m = r[o + \"Cliff\"] || 0,\n              x,\n              y,\n              b = !0;\n            m || h ? (x = (h ? n[0] : n[1]) + m, y = n[0] + m, b = !!h) : !a && t[s] && t[s].isNull && (x = y = g), void 0 !== x && (c.push({\n              plotX: e,\n              plotY: null === x ? f : l.getThreshold(x),\n              isNull: b,\n              isCliff: !0\n            }), d.push({\n              plotX: e,\n              plotY: null === y ? f : l.getThreshold(y),\n              doCurve: !1\n            }));\n          };\n        t = t || this.points, a && (t = this.getStackPoints(t));\n        for (let o = 0, r = t.length; o < r; ++o) a || (t[o].leftCliff = t[o].rightCliff = t[o].leftNull = t[o].rightNull = void 0), i = t[o].isNull, e = h(t[o].rectPlotX, t[o].plotX), s = a ? h(t[o].yBottom, f) : f, i && !m || (m || x(o, o - 1, \"left\"), i && !a && m || (c.push(t[o]), d.push({\n          x: o,\n          plotX: e,\n          plotY: s\n        })), m || x(o, o + 1, \"right\"));\n        let y = r.call(this, c, !0, !0);\n        d.reversed = !0;\n        let b = r.call(this, d, !0, !0),\n          v = b[0];\n        v && \"M\" === v[0] && (b[0] = [\"L\", v[1], v[2]]);\n        let k = y.concat(b);\n        k.length && k.push([\"Z\"]);\n        let S = r.call(this, c, !1, m);\n        return k.xMap = y.xMap, this.areaPath = k, S;\n      }\n      getStackPoints(t) {\n        let e = this,\n          i = [],\n          s = [],\n          o = this.xAxis,\n          r = this.yAxis,\n          n = r.stacking.stacks[this.stackKey],\n          l = {},\n          d = r.series,\n          c = d.length,\n          p = r.options.reversedStacks ? 1 : -1,\n          u = d.indexOf(e);\n        if (t = t || this.points, this.options.stacking) {\n          for (let e = 0; e < t.length; e++) t[e].leftNull = t[e].rightNull = void 0, l[t[e].x] = t[e];\n          a(n, function (t, e) {\n            null !== t.total && s.push(e);\n          }), s.sort(function (t, e) {\n            return t - e;\n          });\n          let g = d.map(t => t.visible);\n          s.forEach(function (t, a) {\n            let f = 0,\n              m,\n              x;\n            if (l[t] && !l[t].isNull) i.push(l[t]), [-1, 1].forEach(function (i) {\n              let o = 1 === i ? \"rightNull\" : \"leftNull\",\n                r = n[s[a + i]],\n                h = 0;\n              if (r) {\n                let i = u;\n                for (; i >= 0 && i < c;) {\n                  let s = d[i].index;\n                  !(m = r.points[s]) && (s === e.index ? l[t][o] = !0 : g[i] && (x = n[t].points[s]) && (h -= x[1] - x[0])), i += p;\n                }\n              }\n              l[t][1 === i ? \"rightCliff\" : \"leftCliff\"] = h;\n            });else {\n              let e = u;\n              for (; e >= 0 && e < c;) {\n                let i = d[e].index;\n                if (m = n[t].points[i]) {\n                  f = m[1];\n                  break;\n                }\n                e += p;\n              }\n              f = h(f, 0), f = r.translate(f, 0, 1, 0, 1), i.push({\n                isNull: !0,\n                plotX: o.translate(t, 0, 0, 0, 1),\n                x: t,\n                plotY: f,\n                yBottom: f\n              });\n            }\n          });\n        }\n        return i;\n      }\n    }\n    return l.defaultOptions = n(o.defaultOptions, {\n      threshold: 0,\n      legendSymbol: \"rectangle\"\n    }), r(l.prototype, {\n      singleStacks: !1\n    }), e.registerSeriesType(\"area\", l), l;\n  }), i(e, \"Series/Spline/SplineSeries.js\", [e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e) {\n    let {\n        line: i\n      } = t.seriesTypes,\n      {\n        merge: s,\n        pick: o\n      } = e;\n    class r extends i {\n      constructor() {\n        super(...arguments), this.data = void 0, this.options = void 0, this.points = void 0;\n      }\n      getPointSpline(t, e, i) {\n        let s, r, n, a;\n        let h = e.plotX || 0,\n          l = e.plotY || 0,\n          d = t[i - 1],\n          c = t[i + 1];\n        function p(t) {\n          return t && !t.isNull && !1 !== t.doCurve && !e.isCliff;\n        }\n        if (p(d) && p(c)) {\n          let t = d.plotX || 0,\n            i = d.plotY || 0,\n            o = c.plotX || 0,\n            p = c.plotY || 0,\n            u = 0;\n          s = (1.5 * h + t) / 2.5, r = (1.5 * l + i) / 2.5, n = (1.5 * h + o) / 2.5, a = (1.5 * l + p) / 2.5, n !== s && (u = (a - r) * (n - h) / (n - s) + l - a), r += u, a += u, r > i && r > l ? (r = Math.max(i, l), a = 2 * l - r) : r < i && r < l && (r = Math.min(i, l), a = 2 * l - r), a > p && a > l ? (a = Math.max(p, l), r = 2 * l - a) : a < p && a < l && (a = Math.min(p, l), r = 2 * l - a), e.rightContX = n, e.rightContY = a, e.controlPoints = {\n            low: [s, r],\n            high: [n, a]\n          };\n        }\n        let u = [\"C\", o(d.rightContX, d.plotX, 0), o(d.rightContY, d.plotY, 0), o(s, h, 0), o(r, l, 0), h, l];\n        return d.rightContX = d.rightContY = void 0, u;\n      }\n    }\n    return r.defaultOptions = s(i.defaultOptions), t.registerSeriesType(\"spline\", r), r;\n  }), i(e, \"Series/AreaSpline/AreaSplineSeries.js\", [e[\"Series/Spline/SplineSeries.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    let {\n        area: s,\n        area: {\n          prototype: o\n        }\n      } = e.seriesTypes,\n      {\n        extend: r,\n        merge: n\n      } = i;\n    class a extends t {\n      constructor() {\n        super(...arguments), this.data = void 0, this.points = void 0, this.options = void 0;\n      }\n    }\n    return a.defaultOptions = n(t.defaultOptions, s.defaultOptions), r(a.prototype, {\n      getGraphPath: o.getGraphPath,\n      getStackPoints: o.getStackPoints,\n      drawGraph: o.drawGraph\n    }), e.registerSeriesType(\"areaspline\", a), a;\n  }), i(e, \"Series/Column/ColumnSeriesDefaults.js\", [], function () {\n    return {\n      borderRadius: 3,\n      centerInCategory: !1,\n      groupPadding: .2,\n      marker: null,\n      pointPadding: .1,\n      minPointLength: 0,\n      cropThreshold: 50,\n      pointRange: null,\n      states: {\n        hover: {\n          halo: !1,\n          brightness: .1\n        },\n        select: {\n          color: \"#cccccc\",\n          borderColor: \"#000000\"\n        }\n      },\n      dataLabels: {\n        align: void 0,\n        verticalAlign: void 0,\n        y: void 0\n      },\n      startFromThreshold: !0,\n      stickyTracking: !1,\n      tooltip: {\n        distance: 6\n      },\n      threshold: 0,\n      borderColor: \"#ffffff\"\n    };\n  }), i(e, \"Series/Column/ColumnSeries.js\", [e[\"Core/Animation/AnimationUtilities.js\"], e[\"Core/Color/Color.js\"], e[\"Series/Column/ColumnSeriesDefaults.js\"], e[\"Core/Globals.js\"], e[\"Core/Series/Series.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s, o, r, n) {\n    let {\n        animObject: a\n      } = t,\n      {\n        parse: h\n      } = e,\n      {\n        hasTouch: l,\n        noop: d\n      } = s,\n      {\n        clamp: c,\n        defined: p,\n        extend: u,\n        fireEvent: g,\n        isArray: f,\n        isNumber: m,\n        merge: x,\n        pick: y,\n        objectEach: b,\n        relativeLength: v\n      } = n;\n    class k extends o {\n      constructor() {\n        super(...arguments), this.borderWidth = void 0, this.data = void 0, this.group = void 0, this.options = void 0, this.points = void 0;\n      }\n      animate(t) {\n        let e, i;\n        let s = this,\n          o = this.yAxis,\n          r = o.pos,\n          n = s.options,\n          h = this.chart.inverted,\n          l = {},\n          d = h ? \"translateX\" : \"translateY\";\n        t ? (l.scaleY = .001, i = c(o.toPixels(n.threshold), r, r + o.len), h ? l.translateX = i - o.len : l.translateY = i, s.clipBox && s.setClip(), s.group.attr(l)) : (e = Number(s.group.attr(d)), s.group.animate({\n          scaleY: 1\n        }, u(a(s.options.animation), {\n          step: function (t, i) {\n            s.group && (l[d] = e + i.pos * (r - e), s.group.attr(l));\n          }\n        })));\n      }\n      init(t, e) {\n        super.init.apply(this, arguments);\n        let i = this;\n        (t = i.chart).hasRendered && t.series.forEach(function (t) {\n          t.type === i.type && (t.isDirty = !0);\n        });\n      }\n      getColumnMetrics() {\n        let t = this,\n          e = t.options,\n          i = t.xAxis,\n          s = t.yAxis,\n          o = i.options.reversedStacks,\n          r = i.reversed && !o || !i.reversed && o,\n          n = {},\n          a,\n          h = 0;\n        !1 === e.grouping ? h = 1 : t.chart.series.forEach(function (e) {\n          let i;\n          let o = e.yAxis,\n            r = e.options;\n          e.type === t.type && e.reserveSpace() && s.len === o.len && s.pos === o.pos && (r.stacking && \"group\" !== r.stacking ? (void 0 === n[a = e.stackKey] && (n[a] = h++), i = n[a]) : !1 !== r.grouping && (i = h++), e.columnIndex = i);\n        });\n        let l = Math.min(Math.abs(i.transA) * (!i.brokenAxis?.hasBreaks && i.ordinal?.slope || e.pointRange || i.closestPointRange || i.tickInterval || 1), i.len),\n          d = l * e.groupPadding,\n          c = (l - 2 * d) / (h || 1),\n          p = Math.min(e.maxPointWidth || i.len, y(e.pointWidth, c * (1 - 2 * e.pointPadding))),\n          u = (c - p) / 2,\n          g = (t.columnIndex || 0) + (r ? 1 : 0),\n          f = u + (d + g * c - l / 2) * (r ? -1 : 1);\n        return t.columnMetrics = {\n          width: p,\n          offset: f,\n          paddedWidth: c,\n          columnCount: h\n        }, t.columnMetrics;\n      }\n      crispCol(t, e, i, s) {\n        this.chart;\n        let o = this.borderWidth,\n          r = -(o % 2 ? .5 : 0),\n          n = o % 2 ? .5 : 1;\n        this.options.crisp && (i = Math.round(t + i) + r - (t = Math.round(t) + r));\n        let a = Math.round(e + s) + n,\n          h = .5 >= Math.abs(e) && a > .5;\n        return s = a - (e = Math.round(e) + n), h && s && (e -= 1, s += 1), {\n          x: t,\n          y: e,\n          width: i,\n          height: s\n        };\n      }\n      adjustForMissingColumns(t, e, i, s) {\n        if (!i.isNull && s.columnCount > 1) {\n          let o = this.xAxis.series.filter(t => t.visible).map(t => t.index),\n            r = 0,\n            n = 0;\n          b(this.xAxis.stacking?.stacks, t => {\n            if (\"number\" == typeof i.x) {\n              let e = t[i.x.toString()];\n              if (e) {\n                let t = e.points[this.index];\n                if (f(t)) {\n                  let t = Object.keys(e.points).filter(t => !t.match(\",\") && e.points[t] && e.points[t].length > 1).map(parseFloat).filter(t => -1 !== o.indexOf(t)).sort((t, e) => e - t);\n                  r = t.indexOf(this.index), n = t.length;\n                }\n              }\n            }\n          });\n          let a = (n - 1) * s.paddedWidth + e;\n          t = (i.plotX || 0) + a / 2 - e - r * s.paddedWidth;\n        }\n        return t;\n      }\n      translate() {\n        let t = this,\n          e = t.chart,\n          i = t.options,\n          s = t.dense = t.closestPointRange * t.xAxis.transA < 2,\n          r = t.borderWidth = y(i.borderWidth, s ? 0 : 1),\n          n = t.xAxis,\n          a = t.yAxis,\n          h = i.threshold,\n          l = y(i.minPointLength, 5),\n          d = t.getColumnMetrics(),\n          u = d.width,\n          f = t.pointXOffset = d.offset,\n          x = t.dataMin,\n          b = t.dataMax,\n          v = t.barW = Math.max(u, 1 + 2 * r),\n          k = t.translatedThreshold = a.getThreshold(h);\n        e.inverted && (k -= .5), i.pointPadding && (v = Math.ceil(v)), o.prototype.translate.apply(t), t.points.forEach(function (s) {\n          let o = y(s.yBottom, k),\n            r = 999 + Math.abs(o),\n            g = s.plotX || 0,\n            S = c(s.plotY, -r, a.len + r);\n          s.stackBox;\n          let M,\n            C = Math.min(S, o),\n            w = Math.max(S, o) - C,\n            T = u,\n            A = g + f,\n            P = v;\n          l && Math.abs(w) < l && (w = l, M = !a.reversed && !s.negative || a.reversed && s.negative, m(h) && m(b) && s.y === h && b <= h && (a.min || 0) < h && (x !== b || (a.max || 0) <= h) && (M = !M, s.negative = !s.negative), C = Math.abs(C - k) > l ? o - l : k - (M ? l : 0)), p(s.options.pointWidth) && (A -= Math.round(((T = P = Math.ceil(s.options.pointWidth)) - u) / 2)), i.centerInCategory && !i.stacking && (A = t.adjustForMissingColumns(A, T, s, d)), s.barX = A, s.pointWidth = T, s.tooltipPos = e.inverted ? [c(a.len + a.pos - e.plotLeft - S, a.pos - e.plotLeft, a.len + a.pos - e.plotLeft), n.len + n.pos - e.plotTop - A - P / 2, w] : [n.left - e.plotLeft + A + P / 2, c(S + a.pos - e.plotTop, a.pos - e.plotTop, a.len + a.pos - e.plotTop), w], s.shapeType = t.pointClass.prototype.shapeType || \"roundedRect\", s.shapeArgs = t.crispCol(A, s.isNull ? k : C, P, s.isNull ? 0 : w);\n        }), g(this, \"afterColumnTranslate\");\n      }\n      drawGraph() {\n        this.group[this.dense ? \"addClass\" : \"removeClass\"](\"highcharts-dense-data\");\n      }\n      pointAttribs(t, e) {\n        let i = this.options,\n          s = this.pointAttrToOptions || {},\n          o = s.stroke || \"borderColor\",\n          r = s[\"stroke-width\"] || \"borderWidth\",\n          n,\n          a,\n          l,\n          d = t && t.color || this.color,\n          c = t && t[o] || i[o] || d,\n          p = t && t.options.dashStyle || i.dashStyle,\n          u = t && t[r] || i[r] || this[r] || 0,\n          g = y(t && t.opacity, i.opacity, 1);\n        t && this.zones.length && (a = t.getZone(), d = t.options.color || a && (a.color || t.nonZonedColor) || this.color, a && (c = a.borderColor || c, p = a.dashStyle || p, u = a.borderWidth || u)), e && t && (l = (n = x(i.states[e], t.options.states && t.options.states[e] || {})).brightness, d = n.color || void 0 !== l && h(d).brighten(n.brightness).get() || d, c = n[o] || c, u = n[r] || u, p = n.dashStyle || p, g = y(n.opacity, g));\n        let f = {\n          fill: d,\n          stroke: c,\n          \"stroke-width\": u,\n          opacity: g\n        };\n        return p && (f.dashstyle = p), f;\n      }\n      drawPoints(t = this.points) {\n        let e;\n        let i = this,\n          s = this.chart,\n          o = i.options,\n          r = s.renderer,\n          n = o.animationLimit || 250;\n        t.forEach(function (t) {\n          let a = t.plotY,\n            h = t.graphic,\n            l = !!h,\n            d = h && s.pointCount < n ? \"animate\" : \"attr\";\n          m(a) && null !== t.y ? (e = t.shapeArgs, h && t.hasNewShapeType() && (h = h.destroy()), i.enabledDataSorting && (t.startXPos = i.xAxis.reversed ? -(e && e.width || 0) : i.xAxis.width), !h && (t.graphic = h = r[t.shapeType](e).add(t.group || i.group), h && i.enabledDataSorting && s.hasRendered && s.pointCount < n && (h.attr({\n            x: t.startXPos\n          }), l = !0, d = \"animate\")), h && l && h[d](x(e)), s.styledMode || h[d](i.pointAttribs(t, t.selected && \"select\")).shadow(!1 !== t.allowShadow && o.shadow), h && (h.addClass(t.getClassName(), !0), h.attr({\n            visibility: t.visible ? \"inherit\" : \"hidden\"\n          }))) : h && (t.graphic = h.destroy());\n        });\n      }\n      drawTracker(t = this.points) {\n        let e;\n        let i = this,\n          s = i.chart,\n          o = s.pointer,\n          r = function (t) {\n            let e = o.getPointFromEvent(t);\n            void 0 !== e && i.options.enableMouseTracking && (o.isDirectTouch = !0, e.onMouseOver(t));\n          };\n        t.forEach(function (t) {\n          e = f(t.dataLabels) ? t.dataLabels : t.dataLabel ? [t.dataLabel] : [], t.graphic && (t.graphic.element.point = t), e.forEach(function (e) {\n            e.div ? e.div.point = t : e.element.point = t;\n          });\n        }), i._hasTracking || (i.trackerGroups.forEach(function (t) {\n          i[t] && (i[t].addClass(\"highcharts-tracker\").on(\"mouseover\", r).on(\"mouseout\", function (t) {\n            o.onTrackerMouseOut(t);\n          }), l && i[t].on(\"touchstart\", r), !s.styledMode && i.options.cursor && i[t].css({\n            cursor: i.options.cursor\n          }));\n        }), i._hasTracking = !0), g(this, \"afterDrawTracker\");\n      }\n      remove() {\n        let t = this,\n          e = t.chart;\n        e.hasRendered && e.series.forEach(function (e) {\n          e.type === t.type && (e.isDirty = !0);\n        }), o.prototype.remove.apply(t, arguments);\n      }\n    }\n    return k.defaultOptions = x(o.defaultOptions, i), u(k.prototype, {\n      directTouch: !0,\n      getSymbol: d,\n      negStacks: !0,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"]\n    }), r.registerSeriesType(\"column\", k), k;\n  }), i(e, \"Core/Series/DataLabel.js\", [e[\"Core/Animation/AnimationUtilities.js\"], e[\"Core/Templating.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    var s;\n    let {\n        getDeferredAnimation: o\n      } = t,\n      {\n        format: r\n      } = e,\n      {\n        defined: n,\n        extend: a,\n        fireEvent: h,\n        isArray: l,\n        isString: d,\n        merge: c,\n        objectEach: p,\n        pick: u,\n        pInt: g,\n        splat: f\n      } = i;\n    return function (t) {\n      let e = [];\n      function s() {\n        return f(this.options.dataLabels || {}).some(t => t?.enabled);\n      }\n      function m(t, e, i, s, o) {\n        let r = this,\n          h = this.chart,\n          l = this.isCartesian && h.inverted,\n          d = this.enabledDataSorting,\n          c = t.plotX,\n          p = t.plotY,\n          g = i.rotation,\n          f = i.align,\n          m = n(c) && n(p) && h.isInsidePlot(c, Math.round(p), {\n            inverted: l,\n            paneCoordinates: !0,\n            series: r\n          }),\n          x = i => {\n            d && r.xAxis && !k && r.setDataLabelStartPos(t, e, o, m, i);\n          },\n          y,\n          b,\n          v,\n          k = \"justify\" === u(i.overflow, d ? \"none\" : \"justify\"),\n          S = this.visible && !1 !== t.visible && n(c) && (t.series.forceDL || d && !k || m || u(i.inside, !!this.options.stacking) && s && h.isInsidePlot(c, l ? s.x + 1 : s.y + s.height - 1, {\n            inverted: l,\n            paneCoordinates: !0,\n            series: r\n          })),\n          M = t.pos();\n        if (S && M) {\n          g && e.attr({\n            align: f\n          });\n          let t = e.getBBox(!0),\n            n = [0, 0];\n          if (y = h.renderer.fontMetrics(e).b, s = a({\n            x: M[0],\n            y: Math.round(M[1]),\n            width: 0,\n            height: 0\n          }, s), a(i, {\n            width: t.width,\n            height: t.height\n          }), g ? (k = !1, b = h.renderer.rotCorr(y, g), v = {\n            x: s.x + (i.x || 0) + s.width / 2 + b.x,\n            y: s.y + (i.y || 0) + {\n              top: 0,\n              middle: .5,\n              bottom: 1\n            }[i.verticalAlign] * s.height\n          }, n = [t.x - Number(e.attr(\"x\")), t.y - Number(e.attr(\"y\"))], x(v), e[o ? \"attr\" : \"animate\"](v)) : (x(s), e.align(i, void 0, s), v = e.alignAttr), k && s.height >= 0) this.justifyDataLabel(e, i, v, t, s, o);else if (u(i.crop, !0)) {\n            let {\n              x: e,\n              y: i\n            } = v;\n            e += n[0], i += n[1], S = h.isInsidePlot(e, i, {\n              paneCoordinates: !0,\n              series: r\n            }) && h.isInsidePlot(e + t.width, i + t.height, {\n              paneCoordinates: !0,\n              series: r\n            });\n          }\n          i.shape && !g && e[o ? \"attr\" : \"animate\"]({\n            anchorX: M[0],\n            anchorY: M[1]\n          });\n        }\n        o && d && (e.placed = !1), S || d && !k ? e.show() : (e.hide(), e.placed = !1);\n      }\n      function x() {\n        return this.plotGroup(\"dataLabelsGroup\", \"data-labels\", this.hasRendered ? \"inherit\" : \"hidden\", this.options.dataLabels.zIndex || 6);\n      }\n      function y(t) {\n        let e = this.hasRendered || 0,\n          i = this.initDataLabelsGroup().attr({\n            opacity: +e\n          });\n        return !e && i && (this.visible && i.show(), this.options.animation ? i.animate({\n          opacity: 1\n        }, t) : i.attr({\n          opacity: 1\n        })), i;\n      }\n      function b(t) {\n        t = t || this.points;\n        let e = this,\n          i = e.chart,\n          s = e.options,\n          a = i.renderer,\n          {\n            backgroundColor: l,\n            plotBackgroundColor: c\n          } = i.options.chart,\n          m = i.options.plotOptions,\n          x = a.getContrast(d(c) && c || d(l) && l || \"#000000\"),\n          y = s.dataLabels,\n          b;\n        y = k(k(m?.series?.dataLabels, m?.[e.type]?.dataLabels), y);\n        let {\n            animation: v,\n            defer: S\n          } = f(y)[0],\n          M = S ? o(i, v, e) : {\n            defer: 0,\n            duration: 0\n          };\n        h(this, \"drawDataLabels\"), e.hasDataLabels?.() && (b = this.initDataLabels(M), t.forEach(t => {\n          let o = t.dataLabels || [];\n          f(k(y, t.dlOptions || t.options?.dataLabels)).forEach((h, l) => {\n            let c = h.enabled && t.visible && (!t.isNull || t.dataLabelOnNull) && function (t, e) {\n                let i = e.filter;\n                if (i) {\n                  let e = i.operator,\n                    s = t[i.property],\n                    o = i.value;\n                  return \">\" === e && s > o || \"<\" === e && s < o || \">=\" === e && s >= o || \"<=\" === e && s <= o || \"==\" === e && s == o || \"===\" === e && s === o;\n                }\n                return !0;\n              }(t, h),\n              f = h.style || {},\n              m = h.distance,\n              y,\n              v,\n              k,\n              S,\n              M = {},\n              C = o[l],\n              w = !C;\n            if (c) {\n              if (v = u(h[t.formatPrefix + \"Format\"], h.format), y = t.getLabelConfig(), k = n(v) ? r(v, y, i) : (h[t.formatPrefix + \"Formatter\"] || h.formatter).call(y, h), S = h.rotation, !i.styledMode && (f.color = u(h.color, f.color, d(e.color) ? e.color : void 0, \"#000000\"), \"contrast\" === f.color ? (t.contrastColor = a.getContrast(t.color || e.color), f.color = !n(m) && h.inside || 0 > g(m || 0) || s.stacking ? t.contrastColor : x) : delete t.contrastColor, s.cursor && (f.cursor = s.cursor)), M = {\n                r: h.borderRadius || 0,\n                rotation: S,\n                padding: h.padding,\n                zIndex: 1\n              }, !i.styledMode) {\n                let {\n                  backgroundColor: e,\n                  borderColor: i\n                } = h;\n                M.fill = \"auto\" === e ? t.color : e, M.stroke = \"auto\" === i ? t.color : i, M[\"stroke-width\"] = h.borderWidth;\n              }\n              p(M, (t, e) => {\n                void 0 === t && delete M[e];\n              });\n            }\n            if (!C || c && n(k) && !!C.div == !!h.useHTML && (C.rotation && h.rotation || C.rotation === h.rotation) || (C = void 0, w = !0), c && n(k) && (C ? M.text = k : (C = S ? a.text(k, 0, 0, h.useHTML).addClass(\"highcharts-data-label\") : a.label(k, 0, 0, h.shape, void 0, void 0, h.useHTML, void 0, \"data-label\")) && C.addClass(\" highcharts-data-label-color-\" + t.colorIndex + \" \" + (h.className || \"\") + (h.useHTML ? \" highcharts-tracker\" : \"\")), C)) {\n              C.options = h, C.attr(M), i.styledMode || C.css(f).shadow(h.shadow);\n              let s = h[t.formatPrefix + \"TextPath\"] || h.textPath;\n              s && !h.useHTML && (C.setTextPath(t.getDataLabelPath?.(C) || t.graphic, s), t.dataLabelPath && !s.enabled && (t.dataLabelPath = t.dataLabelPath.destroy())), C.added || C.add(b), e.alignDataLabel(t, C, h, void 0, w), C.isActive = !0, o[l] && o[l] !== C && o[l].destroy(), o[l] = C;\n            }\n          });\n          let h = o.length;\n          for (; h--;) o[h] && o[h].isActive ? o[h].isActive = !1 : (o[h]?.destroy(), o.splice(h, 1));\n          t.dataLabel = o[0], t.dataLabels = o;\n        })), h(this, \"afterDrawDataLabels\");\n      }\n      function v(t, e, i, s, o, r) {\n        let n = this.chart,\n          a = e.align,\n          h = e.verticalAlign,\n          l = t.box ? 0 : t.padding || 0,\n          {\n            x: d = 0,\n            y: c = 0\n          } = e,\n          p,\n          u;\n        return (p = (i.x || 0) + l) < 0 && (\"right\" === a && d >= 0 ? (e.align = \"left\", e.inside = !0) : d -= p, u = !0), (p = (i.x || 0) + s.width - l) > n.plotWidth && (\"left\" === a && d <= 0 ? (e.align = \"right\", e.inside = !0) : d += n.plotWidth - p, u = !0), (p = i.y + l) < 0 && (\"bottom\" === h && c >= 0 ? (e.verticalAlign = \"top\", e.inside = !0) : c -= p, u = !0), (p = (i.y || 0) + s.height - l) > n.plotHeight && (\"top\" === h && c <= 0 ? (e.verticalAlign = \"bottom\", e.inside = !0) : c += n.plotHeight - p, u = !0), u && (e.x = d, e.y = c, t.placed = !r, t.align(e, void 0, o)), u;\n      }\n      function k(t, e) {\n        let i = [],\n          s;\n        if (l(t) && !l(e)) i = t.map(function (t) {\n          return c(t, e);\n        });else if (l(e) && !l(t)) i = e.map(function (e) {\n          return c(t, e);\n        });else if (l(t) || l(e)) {\n          if (l(t) && l(e)) for (s = Math.max(t.length, e.length); s--;) i[s] = c(t[s], e[s]);\n        } else i = c(t, e);\n        return i;\n      }\n      function S(t, e, i, s, o) {\n        let r = this.chart,\n          n = r.inverted,\n          a = this.xAxis,\n          h = a.reversed,\n          l = ((n ? e.height : e.width) || 0) / 2,\n          d = t.pointWidth,\n          c = d ? d / 2 : 0;\n        e.startXPos = n ? o.x : h ? -l - c : a.width - l + c, e.startYPos = n ? h ? this.yAxis.height - l + c : -l - c : o.y, s ? \"hidden\" === e.visibility && (e.show(), e.attr({\n          opacity: 0\n        }).animate({\n          opacity: 1\n        })) : e.attr({\n          opacity: 1\n        }).animate({\n          opacity: 0\n        }, void 0, e.hide), r.hasRendered && (i && e.attr({\n          x: e.startXPos,\n          y: e.startYPos\n        }), e.placed = !0);\n      }\n      t.compose = function (t) {\n        if (i.pushUnique(e, t)) {\n          let e = t.prototype;\n          e.initDataLabelsGroup = x, e.initDataLabels = y, e.alignDataLabel = m, e.drawDataLabels = b, e.justifyDataLabel = v, e.setDataLabelStartPos = S, e.hasDataLabels = s;\n        }\n      };\n    }(s || (s = {})), s;\n  }), i(e, \"Series/Column/ColumnDataLabel.js\", [e[\"Core/Series/DataLabel.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    var s;\n    let {\n        series: o\n      } = e,\n      {\n        merge: r,\n        pick: n\n      } = i;\n    return function (e) {\n      let s = [];\n      function a(t, e, i, s, a) {\n        let h = this.chart.inverted,\n          l = t.series,\n          d = (l.xAxis ? l.xAxis.len : this.chart.plotSizeX) || 0,\n          c = (l.yAxis ? l.yAxis.len : this.chart.plotSizeY) || 0,\n          p = t.dlBox || t.shapeArgs,\n          u = n(t.below, t.plotY > n(this.translatedThreshold, c)),\n          g = n(i.inside, !!this.options.stacking);\n        if (p) {\n          if (s = r(p), !(\"allow\" === i.overflow && !1 === i.crop)) {\n            s.y < 0 && (s.height += s.y, s.y = 0);\n            let t = s.y + s.height - c;\n            t > 0 && t < s.height && (s.height -= t);\n          }\n          h && (s = {\n            x: c - s.y - s.height,\n            y: d - s.x - s.width,\n            width: s.height,\n            height: s.width\n          }), g || (h ? (s.x += u ? 0 : s.width, s.width = 0) : (s.y += u ? s.height : 0, s.height = 0));\n        }\n        i.align = n(i.align, !h || g ? \"center\" : u ? \"right\" : \"left\"), i.verticalAlign = n(i.verticalAlign, h || g ? \"middle\" : u ? \"top\" : \"bottom\"), o.prototype.alignDataLabel.call(this, t, e, i, s, a), i.inside && t.contrastColor && e.css({\n          color: t.contrastColor\n        });\n      }\n      e.compose = function (e) {\n        t.compose(o), i.pushUnique(s, e) && (e.prototype.alignDataLabel = a);\n      };\n    }(s || (s = {})), s;\n  }), i(e, \"Series/Bar/BarSeries.js\", [e[\"Series/Column/ColumnSeries.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    let {\n      extend: s,\n      merge: o\n    } = i;\n    class r extends t {\n      constructor() {\n        super(...arguments), this.data = void 0, this.options = void 0, this.points = void 0;\n      }\n    }\n    return r.defaultOptions = o(t.defaultOptions, {}), s(r.prototype, {\n      inverted: !0\n    }), e.registerSeriesType(\"bar\", r), r;\n  }), i(e, \"Series/Scatter/ScatterSeriesDefaults.js\", [], function () {\n    return {\n      lineWidth: 0,\n      findNearestPointBy: \"xy\",\n      jitter: {\n        x: 0,\n        y: 0\n      },\n      marker: {\n        enabled: !0\n      },\n      tooltip: {\n        headerFormat: '<span style=\"color:{point.color}\">‚óè</span> <span style=\"font-size: 0.8em\"> {series.name}</span><br/>',\n        pointFormat: \"x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>\"\n      }\n    };\n  }), i(e, \"Series/Scatter/ScatterSeries.js\", [e[\"Series/Scatter/ScatterSeriesDefaults.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    let {\n        column: s,\n        line: o\n      } = e.seriesTypes,\n      {\n        addEvent: r,\n        extend: n,\n        merge: a\n      } = i;\n    class h extends o {\n      constructor() {\n        super(...arguments), this.data = void 0, this.options = void 0, this.points = void 0;\n      }\n      applyJitter() {\n        let t = this,\n          e = this.options.jitter,\n          i = this.points.length;\n        e && this.points.forEach(function (s, o) {\n          [\"x\", \"y\"].forEach(function (r, n) {\n            let a,\n              h = \"plot\" + r.toUpperCase(),\n              l,\n              d,\n              c;\n            e[r] && !s.isNull && (a = t[r + \"Axis\"], c = e[r] * a.transA, a && !a.isLog && (l = Math.max(0, s[h] - c), d = Math.min(a.len, s[h] + c), s[h] = l + (d - l) * function (t) {\n              let e = 1e4 * Math.sin(t);\n              return e - Math.floor(e);\n            }(o + n * i), \"x\" === r && (s.clientX = s.plotX)));\n          });\n        });\n      }\n      drawGraph() {\n        this.options.lineWidth ? super.drawGraph() : this.graph && (this.graph = this.graph.destroy());\n      }\n    }\n    return h.defaultOptions = a(o.defaultOptions, t), n(h.prototype, {\n      drawTracker: s.prototype.drawTracker,\n      sorted: !1,\n      requireSorting: !1,\n      noSharedTooltip: !0,\n      trackerGroups: [\"group\", \"markerGroup\", \"dataLabelsGroup\"],\n      takeOrdinalPosition: !1\n    }), r(h, \"afterTranslate\", function () {\n      this.applyJitter();\n    }), e.registerSeriesType(\"scatter\", h), h;\n  }), i(e, \"Series/CenteredUtilities.js\", [e[\"Core/Globals.js\"], e[\"Core/Series/Series.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    var s, o;\n    let {\n        deg2rad: r\n      } = t,\n      {\n        fireEvent: n,\n        isNumber: a,\n        pick: h,\n        relativeLength: l\n      } = i;\n    return (o = s || (s = {})).getCenter = function () {\n      let t = this.options,\n        i = this.chart,\n        s = 2 * (t.slicedOffset || 0),\n        o = i.plotWidth - 2 * s,\n        r = i.plotHeight - 2 * s,\n        d = t.center,\n        c = Math.min(o, r),\n        p = t.thickness,\n        u,\n        g = t.size,\n        f = t.innerSize || 0,\n        m,\n        x;\n      \"string\" == typeof g && (g = parseFloat(g)), \"string\" == typeof f && (f = parseFloat(f));\n      let y = [h(d[0], \"50%\"), h(d[1], \"50%\"), h(g && g < 0 ? void 0 : t.size, \"100%\"), h(f && f < 0 ? void 0 : t.innerSize || 0, \"0%\")];\n      for (!i.angular || this instanceof e || (y[3] = 0), m = 0; m < 4; ++m) x = y[m], u = m < 2 || 2 === m && /%$/.test(x), y[m] = l(x, [o, r, c, y[2]][m]) + (u ? s : 0);\n      return y[3] > y[2] && (y[3] = y[2]), a(p) && 2 * p < y[2] && p > 0 && (y[3] = y[2] - 2 * p), n(this, \"afterGetCenter\", {\n        positions: y\n      }), y;\n    }, o.getStartAndEndRadians = function (t, e) {\n      let i = a(t) ? t : 0,\n        s = a(e) && e > i && e - i < 360 ? e : i + 360;\n      return {\n        start: r * (i + -90),\n        end: r * (s + -90)\n      };\n    }, s;\n  }), i(e, \"Series/Pie/PiePoint.js\", [e[\"Core/Animation/AnimationUtilities.js\"], e[\"Core/Series/Point.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    let {\n        setAnimation: s\n      } = t,\n      {\n        addEvent: o,\n        defined: r,\n        extend: n,\n        isNumber: a,\n        isString: h,\n        pick: l,\n        relativeLength: d\n      } = i;\n    class c extends e {\n      constructor() {\n        super(...arguments), this.half = 0, this.options = void 0, this.series = void 0;\n      }\n      getConnectorPath(t) {\n        let e = t.dataLabelPosition,\n          i = t.options || {},\n          s = i.connectorShape,\n          o = this.connectorShapes[s] || s;\n        return e && o.call(this, {\n          ...e.computed,\n          alignment: e.alignment\n        }, e.connectorPosition, i) || [];\n      }\n      getTranslate() {\n        return this.sliced && this.slicedTranslation || {\n          translateX: 0,\n          translateY: 0\n        };\n      }\n      haloPath(t) {\n        let e = this.shapeArgs;\n        return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(e.x, e.y, e.r + t, e.r + t, {\n          innerR: e.r - 1,\n          start: e.start,\n          end: e.end,\n          borderRadius: e.borderRadius\n        });\n      }\n      init() {\n        super.init.apply(this, arguments), this.name = l(this.name, \"Slice\");\n        let t = t => {\n          this.slice(\"select\" === t.type);\n        };\n        return o(this, \"select\", t), o(this, \"unselect\", t), this;\n      }\n      isValid() {\n        return a(this.y) && this.y >= 0;\n      }\n      setVisible(t, e) {\n        let i = this.series,\n          s = i.chart,\n          o = i.options.ignoreHiddenPoint;\n        e = l(e, o), t !== this.visible && (this.visible = this.options.visible = t = void 0 === t ? !this.visible : t, i.options.data[i.data.indexOf(this)] = this.options, [\"graphic\", \"dataLabel\", \"connector\"].forEach(e => {\n          this[e] && this[e][t ? \"show\" : \"hide\"](t);\n        }), this.legendItem && s.legend.colorizeItem(this, t), t || \"hover\" !== this.state || this.setState(\"\"), o && (i.isDirty = !0), e && s.redraw());\n      }\n      slice(t, e, i) {\n        let o = this.series,\n          n = o.chart;\n        s(i, n), e = l(e, !0), this.sliced = this.options.sliced = t = r(t) ? t : !this.sliced, o.options.data[o.data.indexOf(this)] = this.options, this.graphic && this.graphic.animate(this.getTranslate());\n      }\n    }\n    return n(c.prototype, {\n      connectorShapes: {\n        fixedOffset: function (t, e, i) {\n          let s = e.breakAt,\n            o = e.touchingSliceAt,\n            r = i.softConnector ? [\"C\", t.x + (\"left\" === t.alignment ? -5 : 5), t.y, 2 * s.x - o.x, 2 * s.y - o.y, s.x, s.y] : [\"L\", s.x, s.y];\n          return [[\"M\", t.x, t.y], r, [\"L\", o.x, o.y]];\n        },\n        straight: function (t, e) {\n          let i = e.touchingSliceAt;\n          return [[\"M\", t.x, t.y], [\"L\", i.x, i.y]];\n        },\n        crookedLine: function (t, e, i) {\n          let {\n              breakAt: s,\n              touchingSliceAt: o\n            } = e,\n            {\n              series: r\n            } = this,\n            [n, a, h] = r.center,\n            l = h / 2,\n            {\n              plotLeft: c,\n              plotWidth: p\n            } = r.chart,\n            u = \"left\" === t.alignment,\n            {\n              x: g,\n              y: f\n            } = t,\n            m = s.x;\n          if (i.crookDistance) {\n            let t = d(i.crookDistance, 1);\n            m = u ? n + l + (p + c - n - l) * (1 - t) : c + (n - l) * t;\n          } else m = n + (a - f) * Math.tan((this.angle || 0) - Math.PI / 2);\n          let x = [[\"M\", g, f]];\n          return (u ? m <= g && m >= s.x : m >= g && m <= s.x) && x.push([\"L\", m, f]), x.push([\"L\", s.x, s.y], [\"L\", o.x, o.y]), x;\n        }\n      }\n    }), c;\n  }), i(e, \"Series/Pie/PieSeriesDefaults.js\", [], function () {\n    return {\n      borderRadius: 3,\n      center: [null, null],\n      clip: !1,\n      colorByPoint: !0,\n      dataLabels: {\n        connectorPadding: 5,\n        connectorShape: \"crookedLine\",\n        crookDistance: void 0,\n        distance: 30,\n        enabled: !0,\n        formatter: function () {\n          return this.point.isNull ? void 0 : this.point.name;\n        },\n        softConnector: !0,\n        x: 0\n      },\n      fillColor: void 0,\n      ignoreHiddenPoint: !0,\n      inactiveOtherPoints: !0,\n      legendType: \"point\",\n      marker: null,\n      size: null,\n      showInLegend: !1,\n      slicedOffset: 10,\n      stickyTracking: !1,\n      tooltip: {\n        followPointer: !0\n      },\n      borderColor: \"#ffffff\",\n      borderWidth: 1,\n      lineWidth: void 0,\n      states: {\n        hover: {\n          brightness: .1\n        }\n      }\n    };\n  }), i(e, \"Series/Pie/PieSeries.js\", [e[\"Series/CenteredUtilities.js\"], e[\"Series/Column/ColumnSeries.js\"], e[\"Core/Globals.js\"], e[\"Series/Pie/PiePoint.js\"], e[\"Series/Pie/PieSeriesDefaults.js\"], e[\"Core/Series/Series.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Renderer/SVG/Symbols.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s, o, r, n, a, h) {\n    let {\n        getStartAndEndRadians: l\n      } = t,\n      {\n        noop: d\n      } = i,\n      {\n        clamp: c,\n        extend: p,\n        fireEvent: u,\n        merge: g,\n        pick: f,\n        relativeLength: m,\n        splat: x\n      } = h;\n    class y extends r {\n      constructor() {\n        super(...arguments), this.center = void 0, this.data = void 0, this.options = void 0, this.points = void 0;\n      }\n      animate(t) {\n        let e = this,\n          i = e.points,\n          s = e.startAngleRad;\n        t || i.forEach(function (t) {\n          let i = t.graphic,\n            o = t.shapeArgs;\n          i && o && (i.attr({\n            r: f(t.startR, e.center && e.center[3] / 2),\n            start: s,\n            end: s\n          }), i.animate({\n            r: o.r,\n            start: o.start,\n            end: o.end\n          }, e.options.animation));\n        });\n      }\n      drawEmpty() {\n        let t, e;\n        let i = this.startAngleRad,\n          s = this.endAngleRad,\n          o = this.options;\n        0 === this.total && this.center ? (t = this.center[0], e = this.center[1], this.graph || (this.graph = this.chart.renderer.arc(t, e, this.center[1] / 2, 0, i, s).addClass(\"highcharts-empty-series\").add(this.group)), this.graph.attr({\n          d: a.arc(t, e, this.center[2] / 2, 0, {\n            start: i,\n            end: s,\n            innerR: this.center[3] / 2\n          })\n        }), this.chart.styledMode || this.graph.attr({\n          \"stroke-width\": o.borderWidth,\n          fill: o.fillColor || \"none\",\n          stroke: o.color || \"#cccccc\"\n        })) : this.graph && (this.graph = this.graph.destroy());\n      }\n      drawPoints() {\n        let t = this.chart.renderer;\n        this.points.forEach(function (e) {\n          e.graphic && e.hasNewShapeType() && (e.graphic = e.graphic.destroy()), e.graphic || (e.graphic = t[e.shapeType](e.shapeArgs).add(e.series.group), e.delayedRendering = !0);\n        });\n      }\n      generatePoints() {\n        super.generatePoints(), this.updateTotals();\n      }\n      getX(t, e, i, s) {\n        let o = this.center,\n          r = this.radii ? this.radii[i.index] || 0 : o[2] / 2,\n          n = s.dataLabelPosition,\n          a = n?.distance || 0,\n          h = Math.asin(c((t - o[1]) / (r + a), -1, 1)),\n          l = o[0] + (e ? -1 : 1) * (Math.cos(h) * (r + a)) + (a > 0 ? (e ? -1 : 1) * (s.padding || 0) : 0);\n        return l;\n      }\n      hasData() {\n        return !!this.processedXData.length;\n      }\n      redrawPoints() {\n        let t, e, i, s;\n        let o = this,\n          r = o.chart;\n        this.drawEmpty(), o.group && !r.styledMode && o.group.shadow(o.options.shadow), o.points.forEach(function (n) {\n          let a = {};\n          e = n.graphic, !n.isNull && e ? (s = n.shapeArgs, t = n.getTranslate(), r.styledMode || (i = o.pointAttribs(n, n.selected && \"select\")), n.delayedRendering ? (e.setRadialReference(o.center).attr(s).attr(t), r.styledMode || e.attr(i).attr({\n            \"stroke-linejoin\": \"round\"\n          }), n.delayedRendering = !1) : (e.setRadialReference(o.center), r.styledMode || g(!0, a, i), g(!0, a, s, t), e.animate(a)), e.attr({\n            visibility: n.visible ? \"inherit\" : \"hidden\"\n          }), e.addClass(n.getClassName(), !0)) : e && (n.graphic = e.destroy());\n        });\n      }\n      sortByAngle(t, e) {\n        t.sort(function (t, i) {\n          return void 0 !== t.angle && (i.angle - t.angle) * e;\n        });\n      }\n      translate(t) {\n        u(this, \"translate\"), this.generatePoints();\n        let e = this.options,\n          i = e.slicedOffset,\n          s = l(e.startAngle, e.endAngle),\n          o = this.startAngleRad = s.start,\n          r = this.endAngleRad = s.end,\n          n = r - o,\n          a = this.points,\n          h = e.ignoreHiddenPoint,\n          d = a.length,\n          c,\n          p,\n          g,\n          f,\n          m,\n          x,\n          y,\n          b = 0;\n        for (t || (this.center = t = this.getCenter()), x = 0; x < d; x++) {\n          y = a[x], c = o + b * n, y.isValid() && (!h || y.visible) && (b += y.percentage / 100), p = o + b * n;\n          let e = {\n            x: t[0],\n            y: t[1],\n            r: t[2] / 2,\n            innerR: t[3] / 2,\n            start: Math.round(1e3 * c) / 1e3,\n            end: Math.round(1e3 * p) / 1e3\n          };\n          y.shapeType = \"arc\", y.shapeArgs = e, (g = (p + c) / 2) > 1.5 * Math.PI ? g -= 2 * Math.PI : g < -Math.PI / 2 && (g += 2 * Math.PI), y.slicedTranslation = {\n            translateX: Math.round(Math.cos(g) * i),\n            translateY: Math.round(Math.sin(g) * i)\n          }, f = Math.cos(g) * t[2] / 2, m = Math.sin(g) * t[2] / 2, y.tooltipPos = [t[0] + .7 * f, t[1] + .7 * m], y.half = g < -Math.PI / 2 || g > Math.PI / 2 ? 1 : 0, y.angle = g;\n        }\n        u(this, \"afterTranslate\");\n      }\n      updateTotals() {\n        let t = this.points,\n          e = t.length,\n          i = this.options.ignoreHiddenPoint,\n          s,\n          o,\n          r = 0;\n        for (s = 0; s < e; s++) (o = t[s]).isValid() && (!i || o.visible) && (r += o.y);\n        for (s = 0, this.total = r; s < e; s++) (o = t[s]).percentage = r > 0 && (o.visible || !i) ? o.y / r * 100 : 0, o.total = r;\n      }\n    }\n    return y.defaultOptions = g(r.defaultOptions, o), p(y.prototype, {\n      axisTypes: [],\n      directTouch: !0,\n      drawGraph: void 0,\n      drawTracker: e.prototype.drawTracker,\n      getCenter: t.getCenter,\n      getSymbol: d,\n      isCartesian: !1,\n      noSharedTooltip: !0,\n      pointAttribs: e.prototype.pointAttribs,\n      pointClass: s,\n      requireSorting: !1,\n      searchPoint: d,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"]\n    }), n.registerSeriesType(\"pie\", y), y;\n  }), i(e, \"Series/Pie/PieDataLabel.js\", [e[\"Core/Series/DataLabel.js\"], e[\"Core/Globals.js\"], e[\"Core/Renderer/RendererUtilities.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s, o) {\n    var r;\n    let {\n        noop: n\n      } = e,\n      {\n        distribute: a\n      } = i,\n      {\n        series: h\n      } = s,\n      {\n        arrayMax: l,\n        clamp: d,\n        defined: c,\n        pick: p,\n        relativeLength: u\n      } = o;\n    return function (e) {\n      let i = [],\n        s = {\n          radialDistributionY: function (t, e) {\n            return (e.dataLabelPosition?.top || 0) + t.distributeBox.pos;\n          },\n          radialDistributionX: function (t, e, i, s, o) {\n            let r = o.dataLabelPosition;\n            return t.getX(i < (r?.top || 0) + 2 || i > (r?.bottom || 0) - 2 ? s : i, e.half, e, o);\n          },\n          justify: function (t, e, i, s) {\n            return s[0] + (t.half ? -1 : 1) * (i + (e.dataLabelPosition?.distance || 0));\n          },\n          alignToPlotEdges: function (t, e, i, s) {\n            let o = t.getBBox().width;\n            return e ? o + s : i - o - s;\n          },\n          alignToConnectors: function (t, e, i, s) {\n            let o = 0,\n              r;\n            return t.forEach(function (t) {\n              (r = t.dataLabel.getBBox().width) > o && (o = r);\n            }), e ? o + s : i - o - s;\n          }\n        };\n      function r(t, e) {\n        let {\n            center: i,\n            options: s\n          } = this,\n          o = i[2] / 2,\n          r = t.angle || 0,\n          n = Math.cos(r),\n          a = Math.sin(r),\n          h = i[0] + n * o,\n          l = i[1] + a * o,\n          d = Math.min((s.slicedOffset || 0) + (s.borderWidth || 0), e / 5);\n        return {\n          natural: {\n            x: h + n * e,\n            y: l + a * e\n          },\n          computed: {},\n          alignment: e < 0 ? \"center\" : t.half ? \"right\" : \"left\",\n          connectorPosition: {\n            breakAt: {\n              x: h + n * d,\n              y: l + a * d\n            },\n            touchingSliceAt: {\n              x: h,\n              y: l\n            }\n          },\n          distance: e\n        };\n      }\n      function g() {\n        let t = this,\n          e = t.points,\n          i = t.chart,\n          s = i.plotWidth,\n          o = i.plotHeight,\n          r = i.plotLeft,\n          n = Math.round(i.chartWidth / 3),\n          d = t.center,\n          g = d[2] / 2,\n          f = d[1],\n          m = [[], []],\n          x = [0, 0, 0, 0],\n          y = t.dataLabelPositioners,\n          b,\n          v,\n          k,\n          S = 0;\n        t.visible && t.hasDataLabels?.() && (e.forEach(t => {\n          (t.dataLabels || []).forEach(t => {\n            t.shortened && (t.attr({\n              width: \"auto\"\n            }).css({\n              width: \"auto\",\n              textOverflow: \"clip\"\n            }), t.shortened = !1);\n          });\n        }), h.prototype.drawDataLabels.apply(t), e.forEach(t => {\n          (t.dataLabels || []).forEach((e, i) => {\n            let s = d[2] / 2,\n              o = e.options,\n              r = u(o?.distance || 0, s);\n            0 === i && m[t.half].push(t), !c(o?.style?.width) && e.getBBox().width > n && (e.css({\n              width: Math.round(.7 * n) + \"px\"\n            }), e.shortened = !0), e.dataLabelPosition = this.getDataLabelPosition(t, r), S = Math.max(S, r);\n          });\n        }), m.forEach((e, n) => {\n          let h = e.length,\n            l = [],\n            u,\n            m,\n            b = 0,\n            M;\n          h && (t.sortByAngle(e, n - .5), S > 0 && (u = Math.max(0, f - g - S), m = Math.min(f + g + S, i.plotHeight), e.forEach(t => {\n            (t.dataLabels || []).forEach((e, s) => {\n              let o = e.dataLabelPosition;\n              o && o.distance > 0 && (o.top = Math.max(0, f - g - o.distance), o.bottom = Math.min(f + g + o.distance, i.plotHeight), b = e.getBBox().height || 21, t.distributeBox = {\n                target: (e.dataLabelPosition?.natural.y || 0) - o.top + b / 2,\n                size: b,\n                rank: t.y\n              }, l.push(t.distributeBox));\n            });\n          }), a(l, M = m + b - u, M / 5)), e.forEach(i => {\n            (i.dataLabels || []).forEach(a => {\n              let h = a.options || {},\n                u = i.distributeBox,\n                f = a.dataLabelPosition,\n                m = f?.natural.y || 0,\n                b = h.connectorPadding || 0,\n                S = 0,\n                M = m,\n                C = \"inherit\";\n              if (f) {\n                if (l && c(u) && f.distance > 0 && (void 0 === u.pos ? C = \"hidden\" : (k = u.size, M = y.radialDistributionY(i, a))), h.justify) S = y.justify(i, a, g, d);else switch (h.alignTo) {\n                  case \"connectors\":\n                    S = y.alignToConnectors(e, n, s, r);\n                    break;\n                  case \"plotEdges\":\n                    S = y.alignToPlotEdges(a, n, s, r);\n                    break;\n                  default:\n                    S = y.radialDistributionX(t, i, M, m, a);\n                }\n                if (f.attribs = {\n                  visibility: C,\n                  align: f.alignment\n                }, f.posAttribs = {\n                  x: S + (h.x || 0) + ({\n                    left: b,\n                    right: -b\n                  }[f.alignment] || 0),\n                  y: M + (h.y || 0) - a.getBBox().height / 2\n                }, f.computed.x = S, f.computed.y = M, p(h.crop, !0)) {\n                  let t;\n                  S - (v = a.getBBox().width) < b && 1 === n ? (t = Math.round(v - S + b), x[3] = Math.max(t, x[3])) : S + v > s - b && 0 === n && (t = Math.round(S + v - s + b), x[1] = Math.max(t, x[1])), M - k / 2 < 0 ? x[0] = Math.max(Math.round(-M + k / 2), x[0]) : M + k / 2 > o && (x[2] = Math.max(Math.round(M + k / 2 - o), x[2])), f.sideOverflow = t;\n                }\n              }\n            });\n          }));\n        }), (0 === l(x) || this.verifyDataLabelOverflow(x)) && (this.placeDataLabels(), this.points.forEach(e => {\n          (e.dataLabels || []).forEach(s => {\n            let {\n                connectorColor: o,\n                connectorWidth: r = 1\n              } = s.options || {},\n              n = s.dataLabelPosition;\n            if (r) {\n              let a;\n              b = s.connector, n && n.distance > 0 ? (a = !b, b || (s.connector = b = i.renderer.path().addClass(\"highcharts-data-label-connector  highcharts-color-\" + e.colorIndex + (e.className ? \" \" + e.className : \"\")).add(t.dataLabelsGroup)), i.styledMode || b.attr({\n                \"stroke-width\": r,\n                stroke: o || e.color || \"#666666\"\n              }), b[a ? \"attr\" : \"animate\"]({\n                d: e.getConnectorPath(s)\n              }), b.attr({\n                visibility: n.attribs?.visibility\n              })) : b && (s.connector = b.destroy());\n            }\n          });\n        })));\n      }\n      function f() {\n        this.points.forEach(t => {\n          (t.dataLabels || []).forEach(t => {\n            let e = t.dataLabelPosition;\n            e ? (e.sideOverflow && (t.css({\n              width: Math.max(t.getBBox().width - e.sideOverflow, 0) + \"px\",\n              textOverflow: (t.options?.style || {}).textOverflow || \"ellipsis\"\n            }), t.shortened = !0), t.attr(e.attribs), t[t.moved ? \"animate\" : \"attr\"](e.posAttribs), t.moved = !0) : t && t.attr({\n              y: -9999\n            });\n          }), delete t.distributeBox;\n        }, this);\n      }\n      function m(t) {\n        let e = this.center,\n          i = this.options,\n          s = i.center,\n          o = i.minSize || 80,\n          r = o,\n          n = null !== i.size;\n        return !n && (null !== s[0] ? r = Math.max(e[2] - Math.max(t[1], t[3]), o) : (r = Math.max(e[2] - t[1] - t[3], o), e[0] += (t[3] - t[1]) / 2), null !== s[1] ? r = d(r, o, e[2] - Math.max(t[0], t[2])) : (r = d(r, o, e[2] - t[0] - t[2]), e[1] += (t[0] - t[2]) / 2), r < e[2] ? (e[2] = r, e[3] = Math.min(i.thickness ? Math.max(0, r - 2 * i.thickness) : Math.max(0, u(i.innerSize || 0, r)), r), this.translate(e), this.drawDataLabels && this.drawDataLabels()) : n = !0), n;\n      }\n      e.compose = function (e) {\n        if (t.compose(h), o.pushUnique(i, e)) {\n          let t = e.prototype;\n          t.dataLabelPositioners = s, t.alignDataLabel = n, t.drawDataLabels = g, t.getDataLabelPosition = r, t.placeDataLabels = f, t.verifyDataLabelOverflow = m;\n        }\n      };\n    }(r || (r = {})), r;\n  }), i(e, \"Extensions/OverlappingDataLabels.js\", [e[\"Core/Utilities.js\"]], function (t) {\n    let {\n        addEvent: e,\n        fireEvent: i,\n        isNumber: s,\n        objectEach: o,\n        pick: r,\n        pushUnique: n\n      } = t,\n      a = [];\n    function h(t) {\n      let e = t.length,\n        o = this.renderer,\n        r = (t, e) => !(e.x >= t.x + t.width || e.x + e.width <= t.x || e.y >= t.y + t.height || e.y + e.height <= t.y),\n        n = t => {\n          let e = t.box ? 0 : t.padding || 0,\n            i,\n            r,\n            n,\n            a = 0,\n            h = 0,\n            l,\n            d;\n          if (t && (!t.alignAttr || t.placed)) return i = t.alignAttr || {\n            x: t.attr(\"x\"),\n            y: t.attr(\"y\")\n          }, r = t.parentGroup, t.width || (n = t.getBBox(), t.width = n.width, t.height = n.height, a = o.fontMetrics(t.element).h), l = t.width - 2 * e, (d = {\n            left: \"0\",\n            center: \"0.5\",\n            right: \"1\"\n          }[t.alignValue]) ? h = +d * l : s(t.x) && Math.round(t.x) !== t.translateX && (h = t.x - (t.translateX || 0)), {\n            x: i.x + (r.translateX || 0) + e - (h || 0),\n            y: i.y + (r.translateY || 0) + e - a,\n            width: t.width - 2 * e,\n            height: (t.height || 0) - 2 * e\n          };\n        },\n        a,\n        h,\n        d,\n        c,\n        p,\n        u = !1;\n      for (let i = 0; i < e; i++) (a = t[i]) && (a.oldOpacity = a.opacity, a.newOpacity = 1, a.absoluteBox = n(a));\n      t.sort((t, e) => (e.labelrank || 0) - (t.labelrank || 0));\n      for (let i = 0; i < e; ++i) {\n        c = (h = t[i]) && h.absoluteBox;\n        for (let s = i + 1; s < e; ++s) p = (d = t[s]) && d.absoluteBox, c && p && h !== d && 0 !== h.newOpacity && 0 !== d.newOpacity && \"hidden\" !== h.visibility && \"hidden\" !== d.visibility && r(c, p) && ((h.labelrank < d.labelrank ? h : d).newOpacity = 0);\n      }\n      for (let e of t) l(e, this) && (u = !0);\n      u && i(this, \"afterHideAllOverlappingLabels\");\n    }\n    function l(t, e) {\n      let s,\n        o = !1;\n      return t && (s = t.newOpacity, t.oldOpacity !== s && (t.alignAttr && t.placed ? (t[s ? \"removeClass\" : \"addClass\"](\"highcharts-data-label-hidden\"), o = !0, t.alignAttr.opacity = s, t[t.isOld ? \"animate\" : \"attr\"](t.alignAttr, null, function () {\n        e.styledMode || t.css({\n          pointerEvents: s ? \"auto\" : \"none\"\n        });\n      }), i(e, \"afterHideOverlappingLabel\")) : t.attr({\n        opacity: s\n      })), t.isOld = !0), o;\n    }\n    function d() {\n      let t = this,\n        e = [];\n      for (let i of t.labelCollectors || []) e = e.concat(i());\n      for (let i of t.yAxis || []) i.stacking && i.options.stackLabels && !i.options.stackLabels.allowOverlap && o(i.stacking.stacks, t => {\n        o(t, t => {\n          t.label && e.push(t.label);\n        });\n      });\n      for (let i of t.series || []) if (i.visible && i.hasDataLabels?.()) {\n        let s = i => {\n          for (let s of i) s.visible && (s.dataLabels || []).forEach(i => {\n            let o = i.options || {};\n            i.labelrank = r(o.labelrank, s.labelrank, s.shapeArgs?.height), o.allowOverlap ?? Number(o.distance) > 0 ? (i.oldOpacity = i.opacity, i.newOpacity = 1, l(i, t)) : e.push(i);\n          });\n        };\n        s(i.nodes || []), s(i.points);\n      }\n      this.hideOverlappingLabels(e);\n    }\n    return {\n      compose: function (t) {\n        if (n(a, t)) {\n          let i = t.prototype;\n          i.hideOverlappingLabels = h, e(t, \"render\", d);\n        }\n      }\n    };\n  }), i(e, \"Extensions/BorderRadius.js\", [e[\"Core/Defaults.js\"], e[\"Core/Globals.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    let {\n        defaultOptions: s\n      } = t,\n      {\n        noop: o\n      } = e,\n      {\n        addEvent: r,\n        extend: n,\n        isObject: a,\n        merge: h,\n        pushUnique: l,\n        relativeLength: d\n      } = i,\n      c = [],\n      p = {\n        radius: 0,\n        scope: \"stack\",\n        where: void 0\n      },\n      u = o,\n      g = o;\n    function f(t, e, i, s, o = {}) {\n      let r = u(t, e, i, s, o),\n        {\n          innerR: n = 0,\n          r: a = i,\n          start: h = 0,\n          end: l = 0\n        } = o;\n      if (o.open || !o.borderRadius) return r;\n      let c = l - h,\n        p = Math.sin(c / 2),\n        g = Math.max(Math.min(d(o.borderRadius || 0, a - n), (a - n) / 2, a * p / (1 + p)), 0),\n        f = Math.min(g, 2 * (c / Math.PI) * n),\n        m = r.length - 1;\n      for (; m--;) !function (t, e, i) {\n        let s, o, r;\n        let n = t[e],\n          a = t[e + 1];\n        if (\"Z\" === a[0] && (a = t[0]), (\"M\" === n[0] || \"L\" === n[0]) && \"A\" === a[0] ? (s = n, o = a, r = !0) : \"A\" === n[0] && (\"M\" === a[0] || \"L\" === a[0]) && (s = a, o = n), s && o && o.params) {\n          let n = o[1],\n            a = o[5],\n            h = o.params,\n            {\n              start: l,\n              end: d,\n              cx: c,\n              cy: p\n            } = h,\n            u = a ? n - i : n + i,\n            g = u ? Math.asin(i / u) : 0,\n            f = a ? g : -g,\n            m = Math.cos(g) * u;\n          r ? (h.start = l + f, s[1] = c + m * Math.cos(l), s[2] = p + m * Math.sin(l), t.splice(e + 1, 0, [\"A\", i, i, 0, 0, 1, c + n * Math.cos(h.start), p + n * Math.sin(h.start)])) : (h.end = d - f, o[6] = c + n * Math.cos(h.end), o[7] = p + n * Math.sin(h.end), t.splice(e + 1, 0, [\"A\", i, i, 0, 0, 1, c + m * Math.cos(d), p + m * Math.sin(d)])), o[4] = Math.abs(h.end - h.start) < Math.PI ? 0 : 1;\n        }\n      }(r, m, m > 1 ? f : g);\n      return r;\n    }\n    function m() {\n      if (this.options.borderRadius && !(this.chart.is3d && this.chart.is3d())) {\n        let {\n            options: t,\n            yAxis: e\n          } = this,\n          i = \"percent\" === t.stacking,\n          o = s.plotOptions?.[this.type]?.borderRadius,\n          r = x(t.borderRadius, a(o) ? o : {}),\n          h = e.options.reversed;\n        for (let s of this.points) {\n          let {\n            shapeArgs: o\n          } = s;\n          if (\"roundedRect\" === s.shapeType && o) {\n            let {\n                width: a = 0,\n                height: l = 0,\n                y: c = 0\n              } = o,\n              p = c,\n              u = l;\n            if (\"stack\" === r.scope && s.stackTotal) {\n              let o = e.translate(i ? 100 : s.stackTotal, !1, !0, !1, !0),\n                r = e.translate(t.threshold || 0, !1, !0, !1, !0),\n                n = this.crispCol(0, Math.min(o, r), 0, Math.abs(o - r));\n              p = n.y, u = n.height;\n            }\n            let g = (s.negative ? -1 : 1) * (h ? -1 : 1) == -1,\n              f = r.where;\n            !f && this.is(\"waterfall\") && Math.abs((s.yBottom || 0) - (this.translatedThreshold || 0)) > this.borderWidth && (f = \"all\"), f || (f = \"end\");\n            let m = Math.min(d(r.radius, a), a / 2, \"all\" === f ? l / 2 : 1 / 0) || 0;\n            \"end\" === f && (g && (p -= m), u += m), n(o, {\n              brBoxHeight: u,\n              brBoxY: p,\n              r: m\n            });\n          }\n        }\n      }\n    }\n    function x(t, e) {\n      return a(t) || (t = {\n        radius: t || 0\n      }), h(p, e, t);\n    }\n    function y() {\n      let t = x(this.options.borderRadius);\n      for (let e of this.points) {\n        let i = e.shapeArgs;\n        i && (i.borderRadius = d(t.radius, (i.r || 0) - (i.innerR || 0)));\n      }\n    }\n    function b(t, e, i, s, o = {}) {\n      let r = g(t, e, i, s, o),\n        {\n          r: n = 0,\n          brBoxHeight: a = s,\n          brBoxY: h = e\n        } = o,\n        l = e - h,\n        d = h + a - (e + s),\n        c = l - n > -.1 ? 0 : n,\n        p = d - n > -.1 ? 0 : n,\n        u = Math.max(c && l, 0),\n        f = Math.max(p && d, 0),\n        m = [t + c, e],\n        x = [t + i - c, e],\n        y = [t + i, e + c],\n        b = [t + i, e + s - p],\n        v = [t + i - p, e + s],\n        k = [t + p, e + s],\n        S = [t, e + s - p],\n        M = [t, e + c],\n        C = (t, e) => Math.sqrt(Math.pow(t, 2) - Math.pow(e, 2));\n      if (u) {\n        let t = C(c, c - u);\n        m[0] -= t, x[0] += t, y[1] = M[1] = e + c - u;\n      }\n      if (s < c - u) {\n        let o = C(c, c - u - s);\n        y[0] = b[0] = t + i - c + o, v[0] = Math.min(y[0], v[0]), k[0] = Math.max(b[0], k[0]), S[0] = M[0] = t + c - o, y[1] = M[1] = e + s;\n      }\n      if (f) {\n        let t = C(p, p - f);\n        v[0] += t, k[0] -= t, b[1] = S[1] = e + s - p + f;\n      }\n      if (s < p - f) {\n        let o = C(p, p - f - s);\n        y[0] = b[0] = t + i - p + o, x[0] = Math.min(y[0], x[0]), m[0] = Math.max(b[0], m[0]), S[0] = M[0] = t + p - o, b[1] = S[1] = e;\n      }\n      return r.length = 0, r.push([\"M\", ...m], [\"L\", ...x], [\"A\", c, c, 0, 0, 1, ...y], [\"L\", ...b], [\"A\", p, p, 0, 0, 1, ...v], [\"L\", ...k], [\"A\", p, p, 0, 0, 1, ...S], [\"L\", ...M], [\"A\", c, c, 0, 0, 1, ...m], [\"Z\"]), r;\n    }\n    return {\n      compose: function (t, e, i, s) {\n        if (l(c, t) && r(t, \"afterColumnTranslate\", m, {\n          order: 9\n        }), l(c, e) && r(e, \"afterTranslate\", y), l(c, i) && i.symbolCustomAttribs.push(\"borderRadius\", \"brBoxHeight\", \"brBoxY\"), l(c, s)) {\n          let t = s.prototype.symbols;\n          u = t.arc, g = t.roundedRect, t.arc = f, t.roundedRect = b;\n        }\n      },\n      optionsToObject: x\n    };\n  }), i(e, \"Core/Responsive.js\", [e[\"Core/Utilities.js\"]], function (t) {\n    var e;\n    let {\n      diffObjects: i,\n      extend: s,\n      find: o,\n      isArray: r,\n      isObject: n,\n      merge: a,\n      objectEach: h,\n      pick: l,\n      splat: d,\n      uniqueKey: c\n    } = t;\n    return function (e) {\n      let r = [];\n      function n(t, e) {\n        let i = t.condition,\n          s = i.callback || function () {\n            return this.chartWidth <= l(i.maxWidth, Number.MAX_VALUE) && this.chartHeight <= l(i.maxHeight, Number.MAX_VALUE) && this.chartWidth >= l(i.minWidth, 0) && this.chartHeight >= l(i.minHeight, 0);\n          };\n        s.call(this) && e.push(t._id);\n      }\n      function h(t, e) {\n        let s = this.options.responsive,\n          r = this.currentResponsive,\n          n = [],\n          h;\n        !e && s && s.rules && s.rules.forEach(t => {\n          void 0 === t._id && (t._id = c()), this.matchResponsiveRule(t, n);\n        }, this);\n        let l = a(...n.map(t => o((s || {}).rules || [], e => e._id === t)).map(t => t && t.chartOptions));\n        l.isResponsiveOptions = !0, n = n.toString() || void 0;\n        let d = r && r.ruleIds;\n        n !== d && (r && this.update(r.undoOptions, t, !0), n ? ((h = i(l, this.options, !0, this.collectionsWithUpdate)).isResponsiveOptions = !0, this.currentResponsive = {\n          ruleIds: n,\n          mergedOptions: l,\n          undoOptions: h\n        }, this.update(l, t, !0)) : this.currentResponsive = void 0);\n      }\n      e.compose = function (e) {\n        return t.pushUnique(r, e) && s(e.prototype, {\n          matchResponsiveRule: n,\n          setResponsive: h\n        }), e;\n      };\n    }(e || (e = {})), e;\n  }), i(e, \"masters/highcharts.src.js\", [e[\"Core/Globals.js\"], e[\"Core/Utilities.js\"], e[\"Core/Defaults.js\"], e[\"Core/Animation/Fx.js\"], e[\"Core/Animation/AnimationUtilities.js\"], e[\"Core/Renderer/HTML/AST.js\"], e[\"Core/Templating.js\"], e[\"Core/Renderer/RendererUtilities.js\"], e[\"Core/Renderer/SVG/SVGElement.js\"], e[\"Core/Renderer/SVG/SVGRenderer.js\"], e[\"Core/Renderer/HTML/HTMLElement.js\"], e[\"Core/Renderer/HTML/HTMLRenderer.js\"], e[\"Core/Axis/Axis.js\"], e[\"Core/Axis/DateTimeAxis.js\"], e[\"Core/Axis/LogarithmicAxis.js\"], e[\"Core/Axis/PlotLineOrBand/PlotLineOrBand.js\"], e[\"Core/Axis/Tick.js\"], e[\"Core/Tooltip.js\"], e[\"Core/Series/Point.js\"], e[\"Core/Pointer.js\"], e[\"Core/Legend/Legend.js\"], e[\"Core/Chart/Chart.js\"], e[\"Core/Axis/Stacking/StackingAxis.js\"], e[\"Core/Axis/Stacking/StackItem.js\"], e[\"Core/Series/Series.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Series/Column/ColumnSeries.js\"], e[\"Series/Column/ColumnDataLabel.js\"], e[\"Series/Pie/PieSeries.js\"], e[\"Series/Pie/PieDataLabel.js\"], e[\"Core/Series/DataLabel.js\"], e[\"Extensions/OverlappingDataLabels.js\"], e[\"Extensions/BorderRadius.js\"], e[\"Core/Responsive.js\"], e[\"Core/Color/Color.js\"], e[\"Core/Time.js\"]], function (t, e, i, s, o, r, n, a, h, l, d, c, p, u, g, f, m, x, y, b, v, k, S, M, C, w, T, A, P, L, O, D, E, I, B, j) {\n    return t.animate = o.animate, t.animObject = o.animObject, t.getDeferredAnimation = o.getDeferredAnimation, t.setAnimation = o.setAnimation, t.stop = o.stop, t.timers = s.timers, t.AST = r, t.Axis = p, t.Chart = k, t.chart = k.chart, t.Fx = s, t.Legend = v, t.PlotLineOrBand = f, t.Point = y, t.Pointer = b, t.Series = C, t.StackItem = M, t.SVGElement = h, t.SVGRenderer = l, t.Templating = n, t.Tick = m, t.Time = j, t.Tooltip = x, t.Color = B, t.color = B.parse, c.compose(l), d.compose(h), b.compose(k), v.compose(k), t.defaultOptions = i.defaultOptions, t.getOptions = i.getOptions, t.time = i.defaultTime, t.setOptions = i.setOptions, t.dateFormat = n.dateFormat, t.format = n.format, t.numberFormat = n.numberFormat, e.extend(t, e), t.distribute = a.distribute, t.seriesType = w.seriesType, A.compose(T), E.compose(C, P, h, l), O.compose(C), u.compose(p), g.compose(p), D.compose(k), L.compose(P), f.compose(p), I.compose(k), S.compose(p, k, C), x.compose(b), t;\n  }), e[\"masters/highcharts.src.js\"]._modules = e, e[\"masters/highcharts.src.js\"];\n}); //# sourceMappingURL=highcharts.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}