{"ast":null,"code":"/**\n * Highcharts JS v11.2.0 (2023-10-30)\n *\n * (c) 2009-2021 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */!function (t) {\n  \"object\" == typeof module && module.exports ? (t.default = t, module.exports = t) : \"function\" == typeof define && define.amd ? define(\"highcharts/highcharts-more\", [\"highcharts\"], function (e) {\n    return t(e), t.Highcharts = e, t;\n  }) : t(\"undefined\" != typeof Highcharts ? Highcharts : void 0);\n}(function (t) {\n  \"use strict\";\n\n  var e = t ? t._modules : {};\n  function i(t, e, i, s) {\n    t.hasOwnProperty(e) || (t[e] = s.apply(null, i), \"function\" == typeof CustomEvent && window.dispatchEvent(new CustomEvent(\"HighchartsModuleLoaded\", {\n      detail: {\n        path: e,\n        module: t[e]\n      }\n    })));\n  }\n  i(e, \"Extensions/Pane.js\", [e[\"Core/Chart/Chart.js\"], e[\"Series/CenteredUtilities.js\"], e[\"Core/Globals.js\"], e[\"Core/Pointer.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s, o) {\n    let {\n      addEvent: a,\n      correctFloat: r,\n      defined: n,\n      extend: l,\n      merge: h,\n      pick: p,\n      splat: d\n    } = o;\n    t.prototype.collectionsWithUpdate.push(\"pane\");\n    class c {\n      constructor(t, e) {\n        this.background = void 0, this.center = void 0, this.chart = void 0, this.options = void 0, this.coll = \"pane\", this.defaultOptions = {\n          center: [\"50%\", \"50%\"],\n          size: \"85%\",\n          innerSize: \"0%\",\n          startAngle: 0\n        }, this.defaultBackgroundOptions = {\n          shape: \"circle\",\n          borderWidth: 1,\n          borderColor: \"#cccccc\",\n          backgroundColor: {\n            linearGradient: {\n              x1: 0,\n              y1: 0,\n              x2: 0,\n              y2: 1\n            },\n            stops: [[0, \"#ffffff\"], [1, \"#e6e6e6\"]]\n          },\n          from: -Number.MAX_VALUE,\n          innerRadius: 0,\n          to: Number.MAX_VALUE,\n          outerRadius: \"105%\"\n        }, this.init(t, e);\n      }\n      init(t, e) {\n        this.chart = e, this.background = [], e.pane.push(this), this.setOptions(t);\n      }\n      setOptions(t) {\n        this.options = t = h(this.defaultOptions, this.chart.angular ? {\n          background: {}\n        } : void 0, t);\n      }\n      render() {\n        let t = this.options,\n          e = this.options.background,\n          i = this.chart.renderer,\n          s,\n          o;\n        if (this.group || (this.group = i.g(\"pane-group\").attr({\n          zIndex: t.zIndex || 0\n        }).add()), this.updateCenter(), e) for (o = 0, s = Math.max((e = d(e)).length, this.background.length || 0); o < s; o++) e[o] && this.axis ? this.renderBackground(h(this.defaultBackgroundOptions, e[o]), o) : this.background[o] && (this.background[o] = this.background[o].destroy(), this.background.splice(o, 1));\n      }\n      renderBackground(t, e) {\n        let i = \"animate\",\n          s = {\n            class: \"highcharts-pane \" + (t.className || \"\")\n          };\n        this.chart.styledMode || l(s, {\n          fill: t.backgroundColor,\n          stroke: t.borderColor,\n          \"stroke-width\": t.borderWidth\n        }), this.background[e] || (this.background[e] = this.chart.renderer.path().add(this.group), i = \"attr\"), this.background[e][i]({\n          d: this.axis.getPlotBandPath(t.from, t.to, t)\n        }).attr(s);\n      }\n      updateCenter(t) {\n        this.center = (t || this.axis || {}).center = e.getCenter.call(this);\n      }\n      update(t, e) {\n        h(!0, this.options, t), this.setOptions(this.options), this.render(), this.chart.axes.forEach(function (t) {\n          t.pane === this && (t.pane = null, t.update({}, e));\n        }, this);\n      }\n    }\n    function u(t, e, i, s, o) {\n      let a = !0,\n        l = i[0],\n        h = i[1],\n        p = Math.sqrt(Math.pow(t - l, 2) + Math.pow(e - h, 2));\n      if (n(s) && n(o)) {\n        let i = Math.atan2(r(e - h, 8), r(t - l, 8));\n        o !== s && (a = s > o ? i >= s && i <= Math.PI || i <= o && i >= -Math.PI : i >= s && i <= r(o, 8));\n      }\n      return p <= Math.ceil(i[2] / 2) && a;\n    }\n    return t.prototype.getHoverPane = function (t) {\n      let e;\n      let i = this;\n      return t && i.pane.forEach(s => {\n        let o = t.chartX - i.plotLeft,\n          a = t.chartY - i.plotTop;\n        u(o, a, s.center) && (e = s);\n      }), e;\n    }, a(t, \"afterIsInsidePlot\", function (t) {\n      this.polar && (t.options.inverted && ([t.x, t.y] = [t.y, t.x]), t.isInsidePlot = this.pane.some(e => u(t.x, t.y, e.center, e.axis && e.axis.normalizedStartAngleRad, e.axis && e.axis.normalizedEndAngleRad)));\n    }), a(s, \"beforeGetHoverData\", function (t) {\n      let e = this.chart;\n      e.polar ? (e.hoverPane = e.getHoverPane(t), t.filter = function (i) {\n        return i.visible && !(!t.shared && i.directTouch) && p(i.options.enableMouseTracking, !0) && (!e.hoverPane || i.xAxis.pane === e.hoverPane);\n      }) : e.hoverPane = void 0;\n    }), a(s, \"afterGetHoverData\", function (t) {\n      let e = this.chart;\n      t.hoverPoint && t.hoverPoint.plotX && t.hoverPoint.plotY && e.hoverPane && !u(t.hoverPoint.plotX, t.hoverPoint.plotY, e.hoverPane.center) && (t.hoverPoint = void 0);\n    }), i.Pane = c, c;\n  }), i(e, \"Series/AreaRange/AreaRangePoint.js\", [e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e) {\n    let {\n        area: {\n          prototype: {\n            pointClass: i,\n            pointClass: {\n              prototype: s\n            }\n          }\n        }\n      } = t.seriesTypes,\n      {\n        defined: o,\n        isNumber: a,\n        merge: r\n      } = e;\n    return class extends i {\n      constructor() {\n        super(...arguments), this.high = void 0, this.low = void 0, this.options = void 0, this.plotX = void 0, this.series = void 0;\n      }\n      setState() {\n        let t = this.state,\n          e = this.series,\n          i = e.chart.polar;\n        e.options.marker, e.symbol, o(this.plotHigh) || (this.plotHigh = e.yAxis.toPixels(this.high, !0)), o(this.plotLow) || (this.plotLow = this.plotY = e.yAxis.toPixels(this.low, !0)), e.lowerStateMarkerGraphic = e.stateMarkerGraphic, e.stateMarkerGraphic = e.upperStateMarkerGraphic, this.graphic = this.graphics && this.graphics[1], this.plotY = this.plotHigh, i && a(this.plotHighX) && (this.plotX = this.plotHighX), s.setState.apply(this, arguments), this.state = t, this.plotY = this.plotLow, this.graphic = this.graphics && this.graphics[0], i && a(this.plotLowX) && (this.plotX = this.plotLowX), e.upperStateMarkerGraphic = e.stateMarkerGraphic, e.stateMarkerGraphic = e.lowerStateMarkerGraphic, e.lowerStateMarkerGraphic = void 0;\n        let r = e.modifyMarkerSettings();\n        s.setState.apply(this, arguments), e.restoreMarkerSettings(r);\n      }\n      haloPath() {\n        let t = this.series.chart.polar,\n          e = [];\n        return this.plotY = this.plotLow, t && a(this.plotLowX) && (this.plotX = this.plotLowX), this.isInside && (e = s.haloPath.apply(this, arguments)), this.plotY = this.plotHigh, t && a(this.plotHighX) && (this.plotX = this.plotHighX), this.isTopInside && (e = e.concat(s.haloPath.apply(this, arguments))), e;\n      }\n      isValid() {\n        return a(this.low) && a(this.high);\n      }\n    };\n  }), i(e, \"Series/AreaRange/AreaRangeSeries.js\", [e[\"Series/AreaRange/AreaRangePoint.js\"], e[\"Core/Globals.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s) {\n    let {\n        noop: o\n      } = e,\n      {\n        area: a,\n        area: {\n          prototype: r\n        },\n        column: {\n          prototype: n\n        }\n      } = i.seriesTypes,\n      {\n        addEvent: l,\n        defined: h,\n        extend: p,\n        isArray: d,\n        isNumber: c,\n        pick: u,\n        merge: g\n      } = s;\n    class f extends a {\n      constructor() {\n        super(...arguments), this.data = void 0, this.options = void 0, this.points = void 0, this.lowerStateMarkerGraphic = void 0, this.xAxis = void 0;\n      }\n      toYData(t) {\n        return [t.low, t.high];\n      }\n      highToXY(t) {\n        let e = this.chart,\n          i = this.xAxis.postTranslate(t.rectPlotX || 0, this.yAxis.len - (t.plotHigh || 0));\n        t.plotHighX = i.x - e.plotLeft, t.plotHigh = i.y - e.plotTop, t.plotLowX = t.plotX;\n      }\n      getGraphPath(t) {\n        let e = [],\n          i = [],\n          s = r.getGraphPath,\n          o = this.options,\n          a = this.chart.polar,\n          n = a && !1 !== o.connectEnds,\n          l = o.connectNulls,\n          h,\n          p,\n          d,\n          c = o.step;\n        for (h = (t = t || this.points).length; h--;) {\n          p = t[h];\n          let s = a ? {\n            plotX: p.rectPlotX,\n            plotY: p.yBottom,\n            doCurve: !1\n          } : {\n            plotX: p.plotX,\n            plotY: p.plotY,\n            doCurve: !1\n          };\n          p.isNull || n || l || t[h + 1] && !t[h + 1].isNull || i.push(s), d = {\n            polarPlotY: p.polarPlotY,\n            rectPlotX: p.rectPlotX,\n            yBottom: p.yBottom,\n            plotX: u(p.plotHighX, p.plotX),\n            plotY: p.plotHigh,\n            isNull: p.isNull\n          }, i.push(d), e.push(d), p.isNull || n || l || t[h - 1] && !t[h - 1].isNull || i.push(s);\n        }\n        let g = s.call(this, t);\n        c && (!0 === c && (c = \"left\"), o.step = {\n          left: \"right\",\n          center: \"center\",\n          right: \"left\"\n        }[c]);\n        let f = s.call(this, e),\n          b = s.call(this, i);\n        o.step = c;\n        let m = [].concat(g, f);\n        return !this.chart.polar && b[0] && \"M\" === b[0][0] && (b[0] = [\"L\", b[0][1], b[0][2]]), this.graphPath = m, this.areaPath = g.concat(b), m.isArea = !0, m.xMap = g.xMap, this.areaPath.xMap = g.xMap, m;\n      }\n      drawDataLabels() {\n        let t, e, i, s, o;\n        let a = this.points,\n          n = a.length,\n          l = [],\n          h = this.options.dataLabels,\n          c = this.chart.inverted;\n        if (h) {\n          if (d(h) ? (s = h[0] || {\n            enabled: !1\n          }, o = h[1] || {\n            enabled: !1\n          }) : ((s = p({}, h)).x = h.xHigh, s.y = h.yHigh, (o = p({}, h)).x = h.xLow, o.y = h.yLow), s.enabled || this.hasDataLabels?.()) {\n            for (t = n; t--;) if (e = a[t]) {\n              let {\n                plotHigh: o = 0,\n                plotLow: a = 0\n              } = e;\n              i = s.inside ? o < a : o > a, e.y = e.high, e._plotY = e.plotY, e.plotY = o, l[t] = e.dataLabel, e.dataLabel = e.dataLabelUpper, e.below = i, c ? s.align || (s.align = i ? \"right\" : \"left\") : s.verticalAlign || (s.verticalAlign = i ? \"top\" : \"bottom\");\n            }\n            for (this.options.dataLabels = s, r.drawDataLabels && r.drawDataLabels.apply(this, arguments), t = n; t--;) (e = a[t]) && (e.dataLabelUpper = e.dataLabel, e.dataLabel = l[t], delete e.dataLabels, e.y = e.low, e.plotY = e._plotY);\n          }\n          if (o.enabled || this.hasDataLabels?.()) {\n            for (t = n; t--;) if (e = a[t]) {\n              let {\n                plotHigh: t = 0,\n                plotLow: s = 0\n              } = e;\n              i = o.inside ? t < s : t > s, e.below = !i, c ? o.align || (o.align = i ? \"left\" : \"right\") : o.verticalAlign || (o.verticalAlign = i ? \"bottom\" : \"top\");\n            }\n            this.options.dataLabels = o, r.drawDataLabels && r.drawDataLabels.apply(this, arguments);\n          }\n          if (s.enabled) for (t = n; t--;) (e = a[t]) && (e.dataLabels = [e.dataLabelUpper, e.dataLabel].filter(function (t) {\n            return !!t;\n          }));\n          this.options.dataLabels = h;\n        }\n      }\n      alignDataLabel() {\n        n.alignDataLabel.apply(this, arguments);\n      }\n      modifyMarkerSettings() {\n        let t = {\n          marker: this.options.marker,\n          symbol: this.symbol\n        };\n        if (this.options.lowMarker) {\n          let {\n            options: {\n              marker: t,\n              lowMarker: e\n            }\n          } = this;\n          this.options.marker = g(t, e), e.symbol && (this.symbol = e.symbol);\n        }\n        return t;\n      }\n      restoreMarkerSettings(t) {\n        this.options.marker = t.marker, this.symbol = t.symbol;\n      }\n      drawPoints() {\n        let t, e;\n        let i = this.points.length,\n          s = this.modifyMarkerSettings();\n        for (r.drawPoints.apply(this, arguments), this.restoreMarkerSettings(s), t = 0; t < i;) (e = this.points[t]).graphics = e.graphics || [], e.origProps = {\n          plotY: e.plotY,\n          plotX: e.plotX,\n          isInside: e.isInside,\n          negative: e.negative,\n          zone: e.zone,\n          y: e.y\n        }, (e.graphic || e.graphics[0]) && (e.graphics[0] = e.graphic), e.graphic = e.graphics[1], e.plotY = e.plotHigh, h(e.plotHighX) && (e.plotX = e.plotHighX), e.y = u(e.high, e.origProps.y), e.negative = e.y < (this.options.threshold || 0), this.zones.length && (e.zone = e.getZone()), this.chart.polar || (e.isInside = e.isTopInside = void 0 !== e.plotY && e.plotY >= 0 && e.plotY <= this.yAxis.len && e.plotX >= 0 && e.plotX <= this.xAxis.len), t++;\n        for (r.drawPoints.apply(this, arguments), t = 0; t < i;) (e = this.points[t]).graphics = e.graphics || [], (e.graphic || e.graphics[1]) && (e.graphics[1] = e.graphic), e.graphic = e.graphics[0], e.origProps && (p(e, e.origProps), delete e.origProps), t++;\n      }\n      hasMarkerChanged(t, e) {\n        let i = t.lowMarker,\n          s = e.lowMarker || {};\n        return i && (!1 === i.enabled || s.symbol !== i.symbol || s.height !== i.height || s.width !== i.width) || super.hasMarkerChanged(t, e);\n      }\n    }\n    return f.defaultOptions = g(a.defaultOptions, {\n      lineWidth: 1,\n      threshold: null,\n      tooltip: {\n        pointFormat: '<span style=\"color:{series.color}\">●</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'\n      },\n      trackByArea: !0,\n      dataLabels: {\n        align: void 0,\n        verticalAlign: void 0,\n        xLow: 0,\n        xHigh: 0,\n        yLow: 0,\n        yHigh: 0\n      }\n    }), l(f, \"afterTranslate\", function () {\n      \"low,high\" === this.pointArrayMap.join(\",\") && this.points.forEach(t => {\n        let e = t.high,\n          i = t.plotY;\n        t.isNull ? t.plotY = void 0 : (t.plotLow = i, t.plotHigh = c(e) ? this.yAxis.translate(this.dataModify ? this.dataModify.modifyValue(e) : e, !1, !0, void 0, !0) : void 0, this.dataModify && (t.yBottom = t.plotHigh));\n      });\n    }, {\n      order: 0\n    }), l(f, \"afterTranslate\", function () {\n      this.chart.inverted, this.points.forEach(t => {\n        if (this.chart.polar) this.highToXY(t), t.plotLow = t.plotY, t.tooltipPos = [((t.plotHighX || 0) + (t.plotLowX || 0)) / 2, ((t.plotHigh || 0) + (t.plotLow || 0)) / 2];else {\n          let e = t.pos(!1, t.plotLow),\n            i = t.pos(!1, t.plotHigh);\n          e && i && (e[0] = (e[0] + i[0]) / 2, e[1] = (e[1] + i[1]) / 2), t.tooltipPos = e;\n        }\n      });\n    }, {\n      order: 3\n    }), p(f.prototype, {\n      deferTranslatePolar: !0,\n      pointArrayMap: [\"low\", \"high\"],\n      pointClass: t,\n      pointValKey: \"low\",\n      setStackedPoints: o\n    }), i.registerSeriesType(\"arearange\", f), f;\n  }), i(e, \"Series/AreaSplineRange/AreaSplineRangeSeries.js\", [e[\"Series/AreaRange/AreaRangeSeries.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    let {\n        spline: {\n          prototype: s\n        }\n      } = e.seriesTypes,\n      {\n        merge: o,\n        extend: a\n      } = i;\n    class r extends t {\n      constructor() {\n        super(...arguments), this.options = void 0, this.data = void 0, this.points = void 0;\n      }\n    }\n    return r.defaultOptions = o(t.defaultOptions), a(r.prototype, {\n      getPointSpline: s.getPointSpline\n    }), e.registerSeriesType(\"areasplinerange\", r), r;\n  }), i(e, \"Series/BoxPlot/BoxPlotSeriesDefaults.js\", [], function () {\n    return {\n      threshold: null,\n      tooltip: {\n        pointFormat: '<span style=\"color:{point.color}\">●</span> <b>{series.name}</b><br/>Maximum: {point.high}<br/>Upper quartile: {point.q3}<br/>Median: {point.median}<br/>Lower quartile: {point.q1}<br/>Minimum: {point.low}<br/>'\n      },\n      whiskerLength: \"50%\",\n      fillColor: \"#ffffff\",\n      lineWidth: 1,\n      medianWidth: 2,\n      whiskerWidth: 2\n    };\n  }), i(e, \"Series/BoxPlot/BoxPlotSeries.js\", [e[\"Series/BoxPlot/BoxPlotSeriesDefaults.js\"], e[\"Series/Column/ColumnSeries.js\"], e[\"Core/Globals.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s, o) {\n    let {\n        noop: a\n      } = i,\n      {\n        extend: r,\n        merge: n,\n        pick: l\n      } = o;\n    class h extends e {\n      constructor() {\n        super(...arguments), this.data = void 0, this.options = void 0, this.points = void 0;\n      }\n      pointAttribs() {\n        return {};\n      }\n      translate() {\n        let t = this.yAxis,\n          e = this.pointArrayMap;\n        super.translate.apply(this), this.points.forEach(function (i) {\n          e.forEach(function (e) {\n            null !== i[e] && (i[e + \"Plot\"] = t.translate(i[e], 0, 1, 0, 1));\n          }), i.plotHigh = i.highPlot;\n        });\n      }\n      drawPoints() {\n        let t = this.points,\n          e = this.options,\n          i = this.chart,\n          s = i.renderer,\n          o = !1 !== this.doQuartiles,\n          a = this.options.whiskerLength,\n          r,\n          n,\n          h,\n          p,\n          d,\n          c,\n          u,\n          g = 0,\n          f,\n          b,\n          m,\n          y,\n          x,\n          P,\n          v;\n        for (let S of t) {\n          b = S.graphic;\n          let t = b ? \"animate\" : \"attr\",\n            M = S.shapeArgs,\n            L = {},\n            k = {},\n            C = {},\n            w = {},\n            A = S.color || this.color;\n          if (void 0 !== S.plotY) {\n            let N;\n            m = Math.round(M.width), x = (y = Math.floor(M.x)) + m, P = Math.round(m / 2), r = Math.floor(o ? S.q1Plot : S.lowPlot), n = Math.floor(o ? S.q3Plot : S.lowPlot), h = Math.floor(S.highPlot), p = Math.floor(S.lowPlot), b || (S.graphic = b = s.g(\"point\").add(this.group), S.stem = s.path().addClass(\"highcharts-boxplot-stem\").add(b), a && (S.whiskers = s.path().addClass(\"highcharts-boxplot-whisker\").add(b)), o && (S.box = s.path(f).addClass(\"highcharts-boxplot-box\").add(b)), S.medianShape = s.path(c).addClass(\"highcharts-boxplot-median\").add(b)), i.styledMode || (k.stroke = S.stemColor || e.stemColor || A, k[\"stroke-width\"] = l(S.stemWidth, e.stemWidth, e.lineWidth), k.dashstyle = S.stemDashStyle || e.stemDashStyle || e.dashStyle, S.stem.attr(k), a && (C.stroke = S.whiskerColor || e.whiskerColor || A, C[\"stroke-width\"] = l(S.whiskerWidth, e.whiskerWidth, e.lineWidth), C.dashstyle = S.whiskerDashStyle || e.whiskerDashStyle || e.dashStyle, S.whiskers.attr(C)), o && (L.fill = S.fillColor || e.fillColor || A, L.stroke = e.lineColor || A, L[\"stroke-width\"] = e.lineWidth || 0, L.dashstyle = S.boxDashStyle || e.boxDashStyle || e.dashStyle, S.box.attr(L)), w.stroke = S.medianColor || e.medianColor || A, w[\"stroke-width\"] = l(S.medianWidth, e.medianWidth, e.lineWidth), w.dashstyle = S.medianDashStyle || e.medianDashStyle || e.dashStyle, S.medianShape.attr(w)), N = [[\"M\", g = y + P + (u = S.stem.strokeWidth() % 2 / 2), n], [\"L\", g, h], [\"M\", g, r], [\"L\", g, p]], S.stem[t]({\n              d: N\n            }), o && (r = Math.floor(r) + (u = S.box.strokeWidth() % 2 / 2), n = Math.floor(n) + u, y += u, x += u, N = [[\"M\", y, n], [\"L\", y, r], [\"L\", x, r], [\"L\", x, n], [\"L\", y, n], [\"Z\"]], S.box[t]({\n              d: N\n            })), a && (h += u = S.whiskers.strokeWidth() % 2 / 2, p += u, N = [[\"M\", g - (v = /%$/.test(a) ? P * parseFloat(a) / 100 : a / 2), h], [\"L\", g + v, h], [\"M\", g - v, p], [\"L\", g + v, p]], S.whiskers[t]({\n              d: N\n            })), N = [[\"M\", y, d = Math.round(S.medianPlot) + (u = S.medianShape.strokeWidth() % 2 / 2)], [\"L\", x, d]], S.medianShape[t]({\n              d: N\n            });\n          }\n        }\n      }\n      toYData(t) {\n        return [t.low, t.q1, t.median, t.q3, t.high];\n      }\n    }\n    return h.defaultOptions = n(e.defaultOptions, t), r(h.prototype, {\n      pointArrayMap: [\"low\", \"q1\", \"median\", \"q3\", \"high\"],\n      pointValKey: \"high\",\n      drawDataLabels: a,\n      setStackedPoints: a\n    }), s.registerSeriesType(\"boxplot\", h), h;\n  }), i(e, \"Series/Bubble/BubbleLegendDefaults.js\", [], function () {\n    return {\n      borderColor: void 0,\n      borderWidth: 2,\n      className: void 0,\n      color: void 0,\n      connectorClassName: void 0,\n      connectorColor: void 0,\n      connectorDistance: 60,\n      connectorWidth: 1,\n      enabled: !1,\n      labels: {\n        className: void 0,\n        allowOverlap: !1,\n        format: \"\",\n        formatter: void 0,\n        align: \"right\",\n        style: {\n          fontSize: \"0.9em\",\n          color: \"#000000\"\n        },\n        x: 0,\n        y: 0\n      },\n      maxSize: 60,\n      minSize: 10,\n      legendIndex: 0,\n      ranges: {\n        value: void 0,\n        borderColor: void 0,\n        color: void 0,\n        connectorColor: void 0\n      },\n      sizeBy: \"area\",\n      sizeByAbsoluteValue: !1,\n      zIndex: 1,\n      zThreshold: 0\n    };\n  }), i(e, \"Series/Bubble/BubbleLegendItem.js\", [e[\"Core/Color/Color.js\"], e[\"Core/Templating.js\"], e[\"Core/Globals.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s) {\n    let {\n        parse: o\n      } = t,\n      {\n        noop: a\n      } = i,\n      {\n        arrayMax: r,\n        arrayMin: n,\n        isNumber: l,\n        merge: h,\n        pick: p,\n        stableSort: d\n      } = s;\n    return class {\n      constructor(t, e) {\n        this.chart = void 0, this.legend = void 0, this.maxLabel = void 0, this.movementX = void 0, this.ranges = void 0, this.selected = void 0, this.visible = void 0, this.symbols = void 0, this.options = void 0, this.setState = a, this.init(t, e);\n      }\n      init(t, e) {\n        this.options = t, this.visible = !0, this.chart = e.chart, this.legend = e;\n      }\n      addToLegend(t) {\n        t.splice(this.options.legendIndex, 0, this);\n      }\n      drawLegendSymbol(t) {\n        let e;\n        this.chart;\n        let i = p(t.options.itemDistance, 20),\n          s = this.legendItem || {},\n          o = this.options,\n          a = o.ranges,\n          r = o.connectorDistance;\n        if (!a || !a.length || !l(a[0].value)) {\n          t.options.bubbleLegend.autoRanges = !0;\n          return;\n        }\n        d(a, function (t, e) {\n          return e.value - t.value;\n        }), this.ranges = a, this.setOptions(), this.render();\n        let n = this.getMaxLabelSize(),\n          h = this.ranges[0].radius,\n          c = 2 * h;\n        e = (e = r - h + n.width) > 0 ? e : 0, this.maxLabel = n, this.movementX = \"left\" === o.labels.align ? e : 0, s.labelWidth = c + e + i, s.labelHeight = c + n.height / 2;\n      }\n      setOptions() {\n        let t = this.ranges,\n          e = this.options,\n          i = this.chart.series[e.seriesIndex],\n          s = this.legend.baseline,\n          a = {\n            zIndex: e.zIndex,\n            \"stroke-width\": e.borderWidth\n          },\n          r = {\n            zIndex: e.zIndex,\n            \"stroke-width\": e.connectorWidth\n          },\n          n = {\n            align: this.legend.options.rtl || \"left\" === e.labels.align ? \"right\" : \"left\",\n            zIndex: e.zIndex\n          },\n          l = i.options.marker.fillOpacity,\n          d = this.chart.styledMode;\n        t.forEach(function (c, u) {\n          d || (a.stroke = p(c.borderColor, e.borderColor, i.color), a.fill = p(c.color, e.color, 1 !== l ? o(i.color).setOpacity(l).get(\"rgba\") : i.color), r.stroke = p(c.connectorColor, e.connectorColor, i.color)), t[u].radius = this.getRangeRadius(c.value), t[u] = h(t[u], {\n            center: t[0].radius - t[u].radius + s\n          }), d || h(!0, t[u], {\n            bubbleAttribs: h(a),\n            connectorAttribs: h(r),\n            labelAttribs: n\n          });\n        }, this);\n      }\n      getRangeRadius(t) {\n        let e = this.options,\n          i = this.options.seriesIndex,\n          s = this.chart.series[i],\n          o = e.ranges[0].value,\n          a = e.ranges[e.ranges.length - 1].value,\n          r = e.minSize,\n          n = e.maxSize;\n        return s.getRadius.call(this, a, o, r, n, t);\n      }\n      render() {\n        let t = this.legendItem || {},\n          e = this.chart.renderer,\n          i = this.options.zThreshold;\n        for (let s of (this.symbols || (this.symbols = {\n          connectors: [],\n          bubbleItems: [],\n          labels: []\n        }), t.symbol = e.g(\"bubble-legend\"), t.label = e.g(\"bubble-legend-item\").css(this.legend.itemStyle || {}), t.symbol.translateX = 0, t.symbol.translateY = 0, t.symbol.add(t.label), t.label.add(t.group), this.ranges)) s.value >= i && this.renderRange(s);\n        this.hideOverlappingLabels();\n      }\n      renderRange(t) {\n        let e = this.ranges[0],\n          i = this.legend,\n          s = this.options,\n          o = s.labels,\n          a = this.chart,\n          r = a.series[s.seriesIndex],\n          n = a.renderer,\n          l = this.symbols,\n          h = l.labels,\n          p = t.center,\n          d = Math.abs(t.radius),\n          c = s.connectorDistance || 0,\n          u = o.align,\n          g = i.options.rtl,\n          f = s.borderWidth,\n          b = s.connectorWidth,\n          m = e.radius || 0,\n          y = p - d - f / 2 + b / 2,\n          x = (y % 1 ? 1 : .5) - (b % 2 ? 0 : .5),\n          P = n.styledMode,\n          v = g || \"left\" === u ? -c : c;\n        \"center\" === u && (v = 0, s.connectorDistance = 0, t.labelAttribs.align = \"center\"), l.bubbleItems.push(n.circle(m, p + x, d).attr(P ? {} : t.bubbleAttribs).addClass((P ? \"highcharts-color-\" + r.colorIndex + \" \" : \"\") + \"highcharts-bubble-legend-symbol \" + (s.className || \"\")).add(this.legendItem.symbol)), l.connectors.push(n.path(n.crispLine([[\"M\", m, y], [\"L\", m + v, y]], s.connectorWidth)).attr(P ? {} : t.connectorAttribs).addClass((P ? \"highcharts-color-\" + this.options.seriesIndex + \" \" : \"\") + \"highcharts-bubble-legend-connectors \" + (s.connectorClassName || \"\")).add(this.legendItem.symbol));\n        let S = n.text(this.formatLabel(t)).attr(P ? {} : t.labelAttribs).css(P ? {} : o.style).addClass(\"highcharts-bubble-legend-labels \" + (s.labels.className || \"\")).add(this.legendItem.symbol),\n          M = {\n            x: m + v + s.labels.x,\n            y: y + s.labels.y + .4 * S.getBBox().height\n          };\n        S.attr(M), h.push(S), S.placed = !0, S.alignAttr = M;\n      }\n      getMaxLabelSize() {\n        let t, e;\n        let i = this.symbols.labels;\n        return i.forEach(function (i) {\n          e = i.getBBox(!0), t = t ? e.width > t.width ? e : t : e;\n        }), t || {};\n      }\n      formatLabel(t) {\n        let i = this.options,\n          s = i.labels.formatter,\n          o = i.labels.format,\n          {\n            numberFormatter: a\n          } = this.chart;\n        return o ? e.format(o, t) : s ? s.call(t) : a(t.value, 1);\n      }\n      hideOverlappingLabels() {\n        let t = this.chart,\n          e = this.options.labels.allowOverlap,\n          i = this.symbols;\n        !e && i && (t.hideOverlappingLabels(i.labels), i.labels.forEach(function (t, e) {\n          t.newOpacity ? t.newOpacity !== t.oldOpacity && i.connectors[e].show() : i.connectors[e].hide();\n        }));\n      }\n      getRanges() {\n        let t = this.legend.bubbleLegend,\n          e = t.chart.series,\n          i = t.options.ranges,\n          s,\n          o,\n          a = Number.MAX_VALUE,\n          d = -Number.MAX_VALUE;\n        return e.forEach(function (t) {\n          t.isBubble && !t.ignoreSeries && (o = t.zData.filter(l)).length && (a = p(t.options.zMin, Math.min(a, Math.max(n(o), !1 === t.options.displayNegative ? t.options.zThreshold : -Number.MAX_VALUE))), d = p(t.options.zMax, Math.max(d, r(o))));\n        }), s = a === d ? [{\n          value: d\n        }] : [{\n          value: a\n        }, {\n          value: (a + d) / 2\n        }, {\n          value: d,\n          autoRanges: !0\n        }], i.length && i[0].radius && s.reverse(), s.forEach(function (t, e) {\n          i && i[e] && (s[e] = h(i[e], t));\n        }), s;\n      }\n      predictBubbleSizes() {\n        let t = this.chart,\n          e = t.legend.options,\n          i = e.floating,\n          s = \"horizontal\" === e.layout,\n          o = s ? t.legend.lastLineHeight : 0,\n          a = t.plotSizeX,\n          r = t.plotSizeY,\n          n = t.series[this.options.seriesIndex],\n          l = n.getPxExtremes(),\n          h = Math.ceil(l.minPxSize),\n          p = Math.ceil(l.maxPxSize),\n          d,\n          c = n.options.maxSize;\n        return i || !/%$/.test(c) ? d = p : (d = (Math.min(r, a) + o) * (c = parseFloat(c)) / 100 / (c / 100 + 1), (s && r - d >= a || !s && a - d >= r) && (d = p)), [h, Math.ceil(d)];\n      }\n      updateRanges(t, e) {\n        let i = this.legend.options.bubbleLegend;\n        i.minSize = t, i.maxSize = e, i.ranges = this.getRanges();\n      }\n      correctSizes() {\n        let t = this.legend,\n          e = this.chart,\n          i = e.series[this.options.seriesIndex],\n          s = i.getPxExtremes(),\n          o = s.maxPxSize,\n          a = this.options.maxSize;\n        Math.abs(Math.ceil(o) - a) > 1 && (this.updateRanges(this.options.minSize, s.maxPxSize), t.render());\n      }\n    };\n  }), i(e, \"Series/Bubble/BubbleLegendComposition.js\", [e[\"Series/Bubble/BubbleLegendDefaults.js\"], e[\"Series/Bubble/BubbleLegendItem.js\"], e[\"Core/Defaults.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s) {\n    let {\n        setOptions: o\n      } = i,\n      {\n        addEvent: a,\n        objectEach: r,\n        wrap: n\n      } = s,\n      l = [];\n    function h(t, e, i) {\n      let s, o, a;\n      let n = this.legend,\n        l = p(this) >= 0;\n      n && n.options.enabled && n.bubbleLegend && n.options.bubbleLegend.autoRanges && l ? (s = n.bubbleLegend.options, o = n.bubbleLegend.predictBubbleSizes(), n.bubbleLegend.updateRanges(o[0], o[1]), s.placed || (n.group.placed = !1, n.allItems.forEach(t => {\n        (a = t.legendItem || {}).group && (a.group.translateY = void 0);\n      })), n.render(), this.getMargins(), this.axes.forEach(function (t) {\n        t.visible && t.render(), s.placed || (t.setScale(), t.updateNames(), r(t.ticks, function (t) {\n          t.isNew = !0, t.isNewLabel = !0;\n        }));\n      }), s.placed = !0, this.getMargins(), t.call(this, e, i), n.bubbleLegend.correctSizes(), g(n, d(n))) : (t.call(this, e, i), n && n.options.enabled && n.bubbleLegend && (n.render(), g(n, d(n))));\n    }\n    function p(t) {\n      let e = t.series,\n        i = 0;\n      for (; i < e.length;) {\n        if (e[i] && e[i].isBubble && e[i].visible && e[i].zData.length) return i;\n        i++;\n      }\n      return -1;\n    }\n    function d(t) {\n      let e = t.allItems,\n        i = [],\n        s = e.length,\n        o,\n        a,\n        r,\n        n = 0,\n        l = 0;\n      for (n = 0; n < s; n++) if (a = e[n].legendItem || {}, r = (e[n + 1] || {}).legendItem || {}, a.labelHeight && (e[n].itemHeight = a.labelHeight), e[n] === e[s - 1] || a.y !== r.y) {\n        for (i.push({\n          height: 0\n        }), o = i[i.length - 1]; l <= n; l++) e[l].itemHeight > o.height && (o.height = e[l].itemHeight);\n        o.step = n;\n      }\n      return i;\n    }\n    function c(t) {\n      let i = this.bubbleLegend,\n        s = this.options,\n        o = s.bubbleLegend,\n        a = p(this.chart);\n      i && i.ranges && i.ranges.length && (o.ranges.length && (o.autoRanges = !!o.ranges[0].autoRanges), this.destroyItem(i)), a >= 0 && s.enabled && o.enabled && (o.seriesIndex = a, this.bubbleLegend = new e(o, this), this.bubbleLegend.addToLegend(t.allItems));\n    }\n    function u(t) {\n      let e;\n      if (t.defaultPrevented) return !1;\n      let i = this.chart,\n        s = this.visible,\n        o = this.chart.legend;\n      o && o.bubbleLegend && (this.visible = !s, this.ignoreSeries = s, e = p(i) >= 0, o.bubbleLegend.visible !== e && (o.update({\n        bubbleLegend: {\n          enabled: e\n        }\n      }), o.bubbleLegend.visible = e), this.visible = s);\n    }\n    function g(t, e) {\n      let i = t.allItems,\n        s = t.options.rtl,\n        o,\n        a,\n        r,\n        n,\n        l = 0;\n      i.forEach((t, i) => {\n        (n = t.legendItem || {}).group && (o = n.group.translateX || 0, a = n.y || 0, ((r = t.movementX) || s && t.ranges) && (r = s ? o - t.options.maxSize / 2 : o + r, n.group.attr({\n          translateX: r\n        })), i > e[l].step && l++, n.group.attr({\n          translateY: Math.round(a + e[l].height / 2)\n        }), n.y = a + e[l].height / 2);\n      });\n    }\n    return {\n      compose: function (e, i, r) {\n        s.pushUnique(l, e) && (o({\n          legend: {\n            bubbleLegend: t\n          }\n        }), n(e.prototype, \"drawChartBox\", h)), s.pushUnique(l, i) && a(i, \"afterGetAllItems\", c), s.pushUnique(l, r) && a(r, \"legendItemClick\", u);\n      }\n    };\n  }), i(e, \"Series/Bubble/BubblePoint.js\", [e[\"Core/Series/Point.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    let {\n        seriesTypes: {\n          scatter: {\n            prototype: {\n              pointClass: s\n            }\n          }\n        }\n      } = e,\n      {\n        extend: o\n      } = i;\n    class a extends s {\n      constructor() {\n        super(...arguments), this.options = void 0, this.series = void 0;\n      }\n      haloPath(e) {\n        return t.prototype.haloPath.call(this, 0 === e ? 0 : (this.marker && this.marker.radius || 0) + e);\n      }\n    }\n    return o(a.prototype, {\n      ttBelow: !1\n    }), a;\n  }), i(e, \"Series/Bubble/BubbleSeries.js\", [e[\"Series/Bubble/BubbleLegendComposition.js\"], e[\"Series/Bubble/BubblePoint.js\"], e[\"Core/Color/Color.js\"], e[\"Core/Globals.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s, o, a) {\n    let {\n        parse: r\n      } = i,\n      {\n        noop: n\n      } = s,\n      {\n        series: l,\n        seriesTypes: {\n          column: {\n            prototype: h\n          },\n          scatter: p\n        }\n      } = o,\n      {\n        addEvent: d,\n        arrayMax: c,\n        arrayMin: u,\n        clamp: g,\n        extend: f,\n        isNumber: b,\n        merge: m,\n        pick: y\n      } = a,\n      x = [];\n    function P() {\n      let t = this.len,\n        e = (this.chart, this.isXAxis),\n        i = e ? \"xData\" : \"yData\",\n        s = this.min,\n        o = this.max - s,\n        a = 0,\n        r = t,\n        n = t / o,\n        l;\n      this.series.forEach(t => {\n        if (t.bubblePadding && t.reserveSpace()) {\n          this.allowZoomOutside = !0, l = !0;\n          let h = t[i];\n          if (e && ((t.onPoint || t).getRadii(0, 0, t), t.onPoint && (t.radii = t.onPoint.radii)), o > 0) {\n            let e = h.length;\n            for (; e--;) if (b(h[e]) && this.dataMin <= h[e] && h[e] <= this.max) {\n              let i = t.radii && t.radii[e] || 0;\n              a = Math.min((h[e] - s) * n - i, a), r = Math.max((h[e] - s) * n + i, r);\n            }\n          }\n        }\n      }), l && o > 0 && !this.logarithmic && (r -= t, n *= (t + Math.max(0, a) - Math.min(r, t)) / t, [[\"min\", \"userMin\", a], [\"max\", \"userMax\", r]].forEach(t => {\n        void 0 === y(this.options[t[0]], this[t[1]]) && (this[t[0]] += t[2] / n);\n      }));\n    }\n    class v extends p {\n      constructor() {\n        super(...arguments), this.data = void 0, this.maxPxSize = void 0, this.minPxSize = void 0, this.options = void 0, this.points = void 0, this.radii = void 0, this.yData = void 0, this.zData = void 0;\n      }\n      static compose(e, i, s, o) {\n        t.compose(i, s, o), a.pushUnique(x, e) && (e.prototype.beforePadding = P);\n      }\n      animate(t) {\n        !t && this.points.length < this.options.animationLimit && this.points.forEach(function (t) {\n          let {\n            graphic: e\n          } = t;\n          e && e.width && (this.hasRendered || e.attr({\n            x: t.plotX,\n            y: t.plotY,\n            width: 1,\n            height: 1\n          }), e.animate(this.markerAttribs(t), this.options.animation));\n        }, this);\n      }\n      getRadii() {\n        let t = this.zData,\n          e = this.yData,\n          i = [],\n          s,\n          o,\n          a,\n          r = this.chart.bubbleZExtremes,\n          {\n            minPxSize: n,\n            maxPxSize: l\n          } = this.getPxExtremes();\n        if (!r) {\n          let t,\n            e = Number.MAX_VALUE,\n            i = -Number.MAX_VALUE;\n          this.chart.series.forEach(s => {\n            if (s.bubblePadding && s.reserveSpace()) {\n              let o = (s.onPoint || s).getZExtremes();\n              o && (e = Math.min(y(e, o.zMin), o.zMin), i = Math.max(y(i, o.zMax), o.zMax), t = !0);\n            }\n          }), t ? (r = {\n            zMin: e,\n            zMax: i\n          }, this.chart.bubbleZExtremes = r) : r = {\n            zMin: 0,\n            zMax: 0\n          };\n        }\n        for (o = 0, s = t.length; o < s; o++) a = t[o], i.push(this.getRadius(r.zMin, r.zMax, n, l, a, e && e[o]));\n        this.radii = i;\n      }\n      getRadius(t, e, i, s, o, a) {\n        let r = this.options,\n          n = \"width\" !== r.sizeBy,\n          l = r.zThreshold,\n          h = e - t,\n          p = .5;\n        if (null === a || null === o) return null;\n        if (b(o)) {\n          if (r.sizeByAbsoluteValue && (o = Math.abs(o - l), e = h = Math.max(e - l, Math.abs(t - l)), t = 0), o < t) return i / 2 - 1;\n          h > 0 && (p = (o - t) / h);\n        }\n        return n && p >= 0 && (p = Math.sqrt(p)), Math.ceil(i + p * (s - i)) / 2;\n      }\n      hasData() {\n        return !!this.processedXData.length;\n      }\n      pointAttribs(t, e) {\n        let i = this.options.marker,\n          s = i.fillOpacity,\n          o = l.prototype.pointAttribs.call(this, t, e);\n        return 1 !== s && (o.fill = r(o.fill).setOpacity(s).get(\"rgba\")), o;\n      }\n      translate() {\n        super.translate.call(this), this.getRadii(), this.translateBubble();\n      }\n      translateBubble() {\n        let {\n            data: t,\n            options: e,\n            radii: i\n          } = this,\n          {\n            minPxSize: s\n          } = this.getPxExtremes(),\n          o = t.length;\n        for (; o--;) {\n          let a = t[o],\n            r = i ? i[o] : 0;\n          \"z\" === this.zoneAxis && (a.negative = (a.z || 0) < (e.zThreshold || 0)), b(r) && r >= s / 2 ? (a.marker = f(a.marker, {\n            radius: r,\n            width: 2 * r,\n            height: 2 * r\n          }), a.dlBox = {\n            x: a.plotX - r,\n            y: a.plotY - r,\n            width: 2 * r,\n            height: 2 * r\n          }) : (a.shapeArgs = a.plotY = a.dlBox = void 0, a.isInside = !1);\n        }\n      }\n      getPxExtremes() {\n        let t = Math.min(this.chart.plotWidth, this.chart.plotHeight),\n          e = e => {\n            let i;\n            return \"string\" == typeof e && (i = /%$/.test(e), e = parseInt(e, 10)), i ? t * e / 100 : e;\n          },\n          i = e(y(this.options.minSize, 8)),\n          s = Math.max(e(y(this.options.maxSize, \"20%\")), i);\n        return {\n          minPxSize: i,\n          maxPxSize: s\n        };\n      }\n      getZExtremes() {\n        let t = this.options,\n          e = (this.zData || []).filter(b);\n        if (e.length) {\n          let i = y(t.zMin, g(u(e), !1 === t.displayNegative ? t.zThreshold || 0 : -Number.MAX_VALUE, Number.MAX_VALUE)),\n            s = y(t.zMax, c(e));\n          if (b(i) && b(s)) return {\n            zMin: i,\n            zMax: s\n          };\n        }\n      }\n    }\n    return v.defaultOptions = m(p.defaultOptions, {\n      dataLabels: {\n        formatter: function () {\n          let {\n              numberFormatter: t\n            } = this.series.chart,\n            {\n              z: e\n            } = this.point;\n          return b(e) ? t(e, -1) : \"\";\n        },\n        inside: !0,\n        verticalAlign: \"middle\"\n      },\n      animationLimit: 250,\n      marker: {\n        lineColor: null,\n        lineWidth: 1,\n        fillOpacity: .5,\n        radius: null,\n        states: {\n          hover: {\n            radiusPlus: 0\n          }\n        },\n        symbol: \"circle\"\n      },\n      minSize: 8,\n      maxSize: \"20%\",\n      softThreshold: !1,\n      states: {\n        hover: {\n          halo: {\n            size: 5\n          }\n        }\n      },\n      tooltip: {\n        pointFormat: \"({point.x}, {point.y}), Size: {point.z}\"\n      },\n      turboThreshold: 0,\n      zThreshold: 0,\n      zoneAxis: \"z\"\n    }), f(v.prototype, {\n      alignDataLabel: h.alignDataLabel,\n      applyZones: n,\n      bubblePadding: !0,\n      isBubble: !0,\n      pointArrayMap: [\"y\", \"z\"],\n      pointClass: e,\n      parallelArrays: [\"x\", \"y\", \"z\"],\n      trackerGroups: [\"group\", \"dataLabelsGroup\"],\n      specialGroup: \"group\",\n      zoneAxis: \"z\"\n    }), d(v, \"updatedData\", t => {\n      delete t.target.chart.bubbleZExtremes;\n    }), d(v, \"remove\", t => {\n      delete t.target.chart.bubbleZExtremes;\n    }), o.registerSeriesType(\"bubble\", v), v;\n  }), i(e, \"Series/ColumnRange/ColumnRangePoint.js\", [e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e) {\n    let {\n        seriesTypes: {\n          column: {\n            prototype: {\n              pointClass: {\n                prototype: i\n              }\n            }\n          },\n          arearange: {\n            prototype: {\n              pointClass: s\n            }\n          }\n        }\n      } = t,\n      {\n        extend: o,\n        isNumber: a\n      } = e;\n    class r extends s {\n      constructor() {\n        super(...arguments), this.options = void 0, this.series = void 0;\n      }\n      isValid() {\n        return a(this.low);\n      }\n    }\n    return o(r.prototype, {\n      setState: i.setState\n    }), r;\n  }), i(e, \"Series/ColumnRange/ColumnRangeSeries.js\", [e[\"Series/ColumnRange/ColumnRangePoint.js\"], e[\"Core/Globals.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s) {\n    let {\n        noop: o\n      } = e,\n      {\n        seriesTypes: {\n          arearange: a,\n          column: r,\n          column: {\n            prototype: n\n          }\n        }\n      } = i,\n      {\n        addEvent: l,\n        clamp: h,\n        extend: p,\n        isNumber: d,\n        merge: c,\n        pick: u\n      } = s;\n    class g extends a {\n      setOptions() {\n        return c(!0, arguments[0], {\n          stacking: void 0\n        }), a.prototype.setOptions.apply(this, arguments);\n      }\n      translate() {\n        return n.translate.apply(this);\n      }\n      pointAttribs() {\n        return n.pointAttribs.apply(this, arguments);\n      }\n      translate3dPoints() {\n        return n.translate3dPoints.apply(this, arguments);\n      }\n      translate3dShapes() {\n        return n.translate3dShapes.apply(this, arguments);\n      }\n      afterColumnTranslate() {\n        let t, e, i, s;\n        let o = this.yAxis,\n          a = this.xAxis,\n          r = a.startAngleRad,\n          n = this.chart,\n          l = this.xAxis.isRadial,\n          p = Math.max(n.chartWidth, n.chartHeight) + 999;\n        this.points.forEach(g => {\n          let f = g.shapeArgs || {},\n            b = this.options.minPointLength,\n            m = g.plotY,\n            y = o.translate(g.high, 0, 1, 0, 1);\n          if (d(y) && d(m)) {\n            if (g.plotHigh = h(y, -p, p), g.plotLow = h(m, -p, p), s = g.plotHigh, Math.abs(t = u(g.rectPlotY, g.plotY) - g.plotHigh) < b ? (e = b - t, t += e, s -= e / 2) : t < 0 && (t *= -1, s -= t), l && this.polar) i = g.barX + r, g.shapeType = \"arc\", g.shapeArgs = this.polar.arc(s + t, s, i, i + g.pointWidth);else {\n              f.height = t, f.y = s;\n              let {\n                x: e = 0,\n                width: i = 0\n              } = f;\n              g.shapeArgs = c(g.shapeArgs, this.crispCol(e, s, i, t)), g.tooltipPos = n.inverted ? [o.len + o.pos - n.plotLeft - s - t / 2, a.len + a.pos - n.plotTop - e - i / 2, t] : [a.left - n.plotLeft + e + i / 2, o.pos - n.plotTop + s + t / 2, t];\n            }\n          }\n        });\n      }\n    }\n    return g.defaultOptions = c(r.defaultOptions, a.defaultOptions, {\n      borderRadius: {\n        where: \"all\"\n      },\n      pointRange: null,\n      marker: null,\n      states: {\n        hover: {\n          halo: !1\n        }\n      }\n    }), l(g, \"afterColumnTranslate\", function () {\n      g.prototype.afterColumnTranslate.apply(this);\n    }, {\n      order: 5\n    }), p(g.prototype, {\n      directTouch: !0,\n      pointClass: t,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"],\n      adjustForMissingColumns: n.adjustForMissingColumns,\n      animate: n.animate,\n      crispCol: n.crispCol,\n      drawGraph: o,\n      drawPoints: n.drawPoints,\n      getSymbol: o,\n      drawTracker: n.drawTracker,\n      getColumnMetrics: n.getColumnMetrics\n    }), i.registerSeriesType(\"columnrange\", g), g;\n  }), i(e, \"Series/ColumnPyramid/ColumnPyramidSeriesDefaults.js\", [], function () {\n    return {};\n  }), i(e, \"Series/ColumnPyramid/ColumnPyramidSeries.js\", [e[\"Series/ColumnPyramid/ColumnPyramidSeriesDefaults.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    let {\n        column: s\n      } = e.seriesTypes,\n      {\n        clamp: o,\n        merge: a,\n        pick: r\n      } = i;\n    class n extends s {\n      constructor() {\n        super(...arguments), this.data = void 0, this.options = void 0, this.points = void 0;\n      }\n      translate() {\n        let t = this.chart,\n          e = this.options,\n          i = this.dense = this.closestPointRange * this.xAxis.transA < 2,\n          s = this.borderWidth = r(e.borderWidth, i ? 0 : 1),\n          a = this.yAxis,\n          n = e.threshold,\n          l = r(e.minPointLength, 5),\n          h = this.getColumnMetrics(),\n          p = h.width,\n          d = this.pointXOffset = h.offset,\n          c = this.translatedThreshold = a.getThreshold(n),\n          u = this.barW = Math.max(p, 1 + 2 * s);\n        for (let i of (t.inverted && (c -= .5), e.pointPadding && (u = Math.ceil(u)), super.translate(), this.points)) {\n          let s = r(i.yBottom, c),\n            g = 999 + Math.abs(s),\n            f = o(i.plotY, -g, a.len + g),\n            b = u / 2,\n            m = Math.min(f, s),\n            y = Math.max(f, s) - m,\n            x = i.plotX + d,\n            P,\n            v,\n            S,\n            M,\n            L,\n            k,\n            C,\n            w,\n            A,\n            N,\n            T,\n            X;\n          e.centerInCategory && (x = this.adjustForMissingColumns(x, p, i, h)), i.barX = x, i.pointWidth = p, i.tooltipPos = t.inverted ? [a.len + a.pos - t.plotLeft - f, this.xAxis.len - x - b, y] : [x + b, f + a.pos - t.plotTop, y], P = n + (i.total || i.y), \"percent\" === e.stacking && (P = n + (i.y < 0) ? -100 : 100), S = a.toPixels(P, !0), M = (v = t.plotHeight - S - (t.plotHeight - c)) ? b * (m - S) / v : 0, L = v ? b * (m + y - S) / v : 0, C = x - M + b, w = x + M + b, A = x + L + b, N = x - L + b, T = m - l, X = m + y, i.y < 0 && (T = m, X = m + y + l), t.inverted && (k = a.width - m, v = S - (a.width - c), M = b * (S - k) / v, L = b * (S - (k - y)) / v, w = (C = x + b + M) - 2 * M, A = x - L + b, N = x + L + b, T = m, X = m + y - l, i.y < 0 && (X = m + y + l)), i.shapeType = \"path\", i.shapeArgs = {\n            x: C,\n            y: T,\n            width: w - C,\n            height: y,\n            d: [[\"M\", C, T], [\"L\", w, T], [\"L\", A, X], [\"L\", N, X], [\"Z\"]]\n          };\n        }\n      }\n    }\n    return n.defaultOptions = a(s.defaultOptions, t), e.registerSeriesType(\"columnpyramid\", n), n;\n  }), i(e, \"Series/ErrorBar/ErrorBarSeriesDefaults.js\", [], function () {\n    return {\n      color: \"#000000\",\n      grouping: !1,\n      linkedTo: \":previous\",\n      tooltip: {\n        pointFormat: '<span style=\"color:{point.color}\">●</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'\n      },\n      whiskerWidth: null\n    };\n  }), i(e, \"Series/ErrorBar/ErrorBarSeries.js\", [e[\"Series/BoxPlot/BoxPlotSeries.js\"], e[\"Series/Column/ColumnSeries.js\"], e[\"Series/ErrorBar/ErrorBarSeriesDefaults.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s, o) {\n    let {\n        arearange: a\n      } = s.seriesTypes,\n      {\n        addEvent: r,\n        merge: n,\n        extend: l\n      } = o;\n    class h extends t {\n      constructor() {\n        super(...arguments), this.data = void 0, this.options = void 0, this.points = void 0;\n      }\n      getColumnMetrics() {\n        return this.linkedParent && this.linkedParent.columnMetrics || e.prototype.getColumnMetrics.call(this);\n      }\n      drawDataLabels() {\n        let t = this.pointValKey;\n        if (a) for (let e of (a.prototype.drawDataLabels.call(this), this.data)) e.y = e[t];\n      }\n      toYData(t) {\n        return [t.low, t.high];\n      }\n    }\n    return h.defaultOptions = n(t.defaultOptions, i), r(h, \"afterTranslate\", function () {\n      for (let t of this.points) t.plotLow = t.plotY;\n    }, {\n      order: 0\n    }), l(h.prototype, {\n      pointArrayMap: [\"low\", \"high\"],\n      pointValKey: \"high\",\n      doQuartiles: !1\n    }), s.registerSeriesType(\"errorbar\", h), h;\n  }), i(e, \"Series/Gauge/GaugePoint.js\", [e[\"Core/Series/SeriesRegistry.js\"]], function (t) {\n    let {\n      series: {\n        prototype: {\n          pointClass: e\n        }\n      }\n    } = t;\n    return class extends e {\n      constructor() {\n        super(...arguments), this.options = void 0, this.series = void 0, this.shapeArgs = void 0;\n      }\n      setState(t) {\n        this.state = t;\n      }\n    };\n  }), i(e, \"Series/Gauge/GaugeSeries.js\", [e[\"Series/Gauge/GaugePoint.js\"], e[\"Core/Globals.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s) {\n    let {\n        noop: o\n      } = e,\n      {\n        series: a,\n        seriesTypes: {\n          column: r\n        }\n      } = i,\n      {\n        clamp: n,\n        isNumber: l,\n        extend: h,\n        merge: p,\n        pick: d,\n        pInt: c,\n        defined: u\n      } = s;\n    class g extends a {\n      constructor() {\n        super(...arguments), this.data = void 0, this.points = void 0, this.options = void 0, this.yAxis = void 0;\n      }\n      translate() {\n        let t = this.yAxis,\n          e = this.options,\n          i = t.center;\n        this.generatePoints(), this.points.forEach(s => {\n          let o = p(e.dial, s.dial),\n            a = c(o.radius) * i[2] / 200,\n            r = c(o.baseLength) * a / 100,\n            h = c(o.rearLength) * a / 100,\n            d = o.baseWidth,\n            g = o.topWidth,\n            f = e.overshoot,\n            b = t.startAngleRad + t.translate(s.y, void 0, void 0, void 0, !0);\n          (l(f) || !1 === e.wrap) && (f = l(f) ? f / 180 * Math.PI : 0, b = n(b, t.startAngleRad - f, t.endAngleRad + f)), b = 180 * b / Math.PI, s.shapeType = \"path\";\n          let m = o.path || [[\"M\", -h, -d / 2], [\"L\", r, -d / 2], [\"L\", a, -g / 2], [\"L\", a, g / 2], [\"L\", r, d / 2], [\"L\", -h, d / 2], [\"Z\"]];\n          s.shapeArgs = {\n            d: m,\n            translateX: i[0],\n            translateY: i[1],\n            rotation: b\n          }, s.plotX = i[0], s.plotY = i[1], u(s.y) && t.max - t.min && (s.percentage = (s.y - t.min) / (t.max - t.min) * 100);\n        });\n      }\n      drawPoints() {\n        let t = this,\n          e = t.chart,\n          i = t.yAxis.center,\n          s = t.pivot,\n          o = t.options,\n          a = o.pivot,\n          r = e.renderer;\n        t.points.forEach(i => {\n          let s = i.graphic,\n            a = i.shapeArgs,\n            n = a.d,\n            l = p(o.dial, i.dial);\n          s ? (s.animate(a), a.d = n) : i.graphic = r[i.shapeType](a).addClass(\"highcharts-dial\").add(t.group), e.styledMode || i.graphic[s ? \"animate\" : \"attr\"]({\n            stroke: l.borderColor,\n            \"stroke-width\": l.borderWidth,\n            fill: l.backgroundColor\n          });\n        }), s ? s.animate({\n          translateX: i[0],\n          translateY: i[1]\n        }) : a && (t.pivot = r.circle(0, 0, a.radius).attr({\n          zIndex: 2\n        }).addClass(\"highcharts-pivot\").translate(i[0], i[1]).add(t.group), e.styledMode || t.pivot.attr({\n          fill: a.backgroundColor,\n          stroke: a.borderColor,\n          \"stroke-width\": a.borderWidth\n        }));\n      }\n      animate(t) {\n        let e = this;\n        t || e.points.forEach(t => {\n          let i = t.graphic;\n          i && (i.attr({\n            rotation: 180 * e.yAxis.startAngleRad / Math.PI\n          }), i.animate({\n            rotation: t.shapeArgs.rotation\n          }, e.options.animation));\n        });\n      }\n      render() {\n        this.group = this.plotGroup(\"group\", \"series\", this.visible ? \"inherit\" : \"hidden\", this.options.zIndex, this.chart.seriesGroup), a.prototype.render.call(this), this.group.clip(this.chart.clipRect);\n      }\n      setData(t, e) {\n        a.prototype.setData.call(this, t, !1), this.processData(), this.generatePoints(), d(e, !0) && this.chart.redraw();\n      }\n      hasData() {\n        return !!this.points.length;\n      }\n    }\n    return g.defaultOptions = p(a.defaultOptions, {\n      dataLabels: {\n        borderColor: \"#cccccc\",\n        borderRadius: 3,\n        borderWidth: 1,\n        crop: !1,\n        defer: !1,\n        enabled: !0,\n        verticalAlign: \"top\",\n        y: 15,\n        zIndex: 2\n      },\n      dial: {\n        backgroundColor: \"#000000\",\n        baseLength: \"70%\",\n        baseWidth: 3,\n        borderColor: \"#cccccc\",\n        borderWidth: 0,\n        radius: \"80%\",\n        rearLength: \"10%\",\n        topWidth: 1\n      },\n      pivot: {\n        radius: 5,\n        borderWidth: 0,\n        borderColor: \"#cccccc\",\n        backgroundColor: \"#000000\"\n      },\n      tooltip: {\n        headerFormat: \"\"\n      },\n      showInLegend: !1\n    }), h(g.prototype, {\n      angular: !0,\n      directTouch: !0,\n      drawGraph: o,\n      drawTracker: r.prototype.drawTracker,\n      fixedBox: !0,\n      forceDL: !0,\n      noSharedTooltip: !0,\n      pointClass: t,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"]\n    }), i.registerSeriesType(\"gauge\", g), g;\n  }), i(e, \"Series/DragNodesComposition.js\", [e[\"Core/Utilities.js\"]], function (t) {\n    let {\n        addEvent: e\n      } = t,\n      i = [];\n    function s() {\n      let t, i, s;\n      let o = this;\n      o.container && (t = e(o.container, \"mousedown\", t => {\n        let a = o.hoverPoint;\n        a && a.series && a.series.hasDraggableNodes && a.series.options.draggable && (a.series.onMouseDown(a, t), i = e(o.container, \"mousemove\", t => a && a.series && a.series.onMouseMove(a, t)), s = e(o.container.ownerDocument, \"mouseup\", t => (i(), s(), a && a.series && a.series.onMouseUp(a, t))));\n      })), e(o, \"destroy\", function () {\n        t();\n      });\n    }\n    return {\n      compose: function (o) {\n        t.pushUnique(i, o) && e(o, \"load\", s);\n      },\n      onMouseDown: function (t, e) {\n        let i = this.chart.pointer.normalize(e);\n        t.fixedPosition = {\n          chartX: i.chartX,\n          chartY: i.chartY,\n          plotX: t.plotX,\n          plotY: t.plotY\n        }, t.inDragMode = !0;\n      },\n      onMouseMove: function (t, e) {\n        if (t.fixedPosition && t.inDragMode) {\n          let i, s;\n          let o = this.chart,\n            a = o.pointer.normalize(e),\n            r = t.fixedPosition.chartX - a.chartX,\n            n = t.fixedPosition.chartY - a.chartY,\n            l = o.graphLayoutsLookup;\n          (Math.abs(r) > 5 || Math.abs(n) > 5) && (i = t.fixedPosition.plotX - r, s = t.fixedPosition.plotY - n, o.isInsidePlot(i, s) && (t.plotX = i, t.plotY = s, t.hasDragged = !0, this.redrawHalo(t), l.forEach(t => {\n            t.restartSimulation();\n          })));\n        }\n      },\n      onMouseUp: function (t, e) {\n        t.fixedPosition && (t.hasDragged && (this.layout.enableSimulation ? this.layout.start() : this.chart.redraw()), t.inDragMode = t.hasDragged = !1, this.options.fixedDraggable || delete t.fixedPosition);\n      },\n      redrawHalo: function (t) {\n        t && this.halo && this.halo.attr({\n          d: t.haloPath(this.options.states.hover.halo.size)\n        });\n      }\n    };\n  }), i(e, \"Series/GraphLayoutComposition.js\", [e[\"Core/Animation/AnimationUtilities.js\"], e[\"Core/Utilities.js\"]], function (t, e) {\n    let {\n        setAnimation: i\n      } = t,\n      {\n        addEvent: s\n      } = e,\n      o = [];\n    function a() {\n      this.graphLayoutsLookup && (this.graphLayoutsLookup.forEach(t => {\n        t.updateSimulation();\n      }), this.redraw());\n    }\n    function r() {\n      this.graphLayoutsLookup && (this.graphLayoutsLookup.forEach(t => {\n        t.updateSimulation(!1);\n      }), this.redraw());\n    }\n    function n() {\n      this.graphLayoutsLookup && this.graphLayoutsLookup.forEach(t => {\n        t.stop();\n      });\n    }\n    function l() {\n      let t,\n        e = !1,\n        s = i => {\n          i.maxIterations-- && isFinite(i.temperature) && !i.isStable() && !i.enableSimulation && (i.beforeStep && i.beforeStep(), i.step(), t = !1, e = !0);\n        };\n      if (this.graphLayoutsLookup) {\n        for (i(!1, this), this.graphLayoutsLookup.forEach(t => t.start()); !t;) t = !0, this.graphLayoutsLookup.forEach(s);\n        e && this.series.forEach(t => {\n          t && t.layout && t.render();\n        });\n      }\n    }\n    return {\n      compose: function (t) {\n        e.pushUnique(o, t) && (s(t, \"afterPrint\", a), s(t, \"beforePrint\", r), s(t, \"predraw\", n), s(t, \"render\", l));\n      },\n      integrations: {},\n      layouts: {}\n    };\n  }), i(e, \"Series/PackedBubble/PackedBubblePoint.js\", [e[\"Core/Chart/Chart.js\"], e[\"Core/Series/Point.js\"], e[\"Core/Series/SeriesRegistry.js\"]], function (t, e, i) {\n    let {\n      seriesTypes: {\n        bubble: {\n          prototype: {\n            pointClass: s\n          }\n        }\n      }\n    } = i;\n    return class extends s {\n      constructor() {\n        super(...arguments), this.degree = NaN, this.mass = NaN, this.radius = NaN, this.options = void 0, this.series = void 0, this.value = null;\n      }\n      destroy() {\n        return this.series.layout && this.series.layout.removeElementFromCollection(this, this.series.layout.nodes), e.prototype.destroy.apply(this, arguments);\n      }\n      firePointEvent() {\n        let t = this.series,\n          i = t.options;\n        if (this.isParentNode && i.parentNode) {\n          let t = i.allowPointSelect;\n          i.allowPointSelect = i.parentNode.allowPointSelect, e.prototype.firePointEvent.apply(this, arguments), i.allowPointSelect = t;\n        } else e.prototype.firePointEvent.apply(this, arguments);\n      }\n      select() {\n        let i = this.series,\n          s = i.chart;\n        this.isParentNode ? (s.getSelectedPoints = s.getSelectedParentNodes, e.prototype.select.apply(this, arguments), s.getSelectedPoints = t.prototype.getSelectedPoints) : e.prototype.select.apply(this, arguments);\n      }\n    };\n  }), i(e, \"Series/PackedBubble/PackedBubbleSeriesDefaults.js\", [e[\"Core/Utilities.js\"]], function (t) {\n    let {\n      isNumber: e\n    } = t;\n    return {\n      minSize: \"10%\",\n      maxSize: \"50%\",\n      sizeBy: \"area\",\n      zoneAxis: \"y\",\n      crisp: !1,\n      tooltip: {\n        pointFormat: \"Value: {point.value}\"\n      },\n      draggable: !0,\n      useSimulation: !0,\n      parentNode: {\n        allowPointSelect: !1\n      },\n      dataLabels: {\n        formatter: function () {\n          let {\n              numberFormatter: t\n            } = this.series.chart,\n            {\n              value: i\n            } = this.point;\n          return e(i) ? t(i, -1) : \"\";\n        },\n        parentNodeFormatter: function () {\n          return this.name;\n        },\n        parentNodeTextPath: {\n          enabled: !0\n        },\n        padding: 0,\n        style: {\n          transition: \"opacity 2000ms\"\n        }\n      },\n      layoutAlgorithm: {\n        initialPositions: \"circle\",\n        initialPositionRadius: 20,\n        bubblePadding: 5,\n        parentNodeLimit: !1,\n        seriesInteraction: !0,\n        dragBetweenSeries: !1,\n        parentNodeOptions: {\n          maxIterations: 400,\n          gravitationalConstant: .03,\n          maxSpeed: 50,\n          initialPositionRadius: 100,\n          seriesInteraction: !0,\n          marker: {\n            fillColor: null,\n            fillOpacity: 1,\n            lineWidth: null,\n            lineColor: null,\n            symbol: \"circle\"\n          }\n        },\n        enableSimulation: !0,\n        type: \"packedbubble\",\n        integration: \"packedbubble\",\n        maxIterations: 1e3,\n        splitSeries: !1,\n        maxSpeed: 5,\n        gravitationalConstant: .01,\n        friction: -.981\n      }\n    };\n  }), i(e, \"Series/Networkgraph/VerletIntegration.js\", [], function () {\n    return {\n      attractive: function (t, e, i) {\n        let s = t.getMass(),\n          o = -i.x * e * this.diffTemperature,\n          a = -i.y * e * this.diffTemperature;\n        t.fromNode.fixedPosition || (t.fromNode.plotX -= o * s.fromNode / t.fromNode.degree, t.fromNode.plotY -= a * s.fromNode / t.fromNode.degree), t.toNode.fixedPosition || (t.toNode.plotX += o * s.toNode / t.toNode.degree, t.toNode.plotY += a * s.toNode / t.toNode.degree);\n      },\n      attractiveForceFunction: function (t, e) {\n        return (e - t) / t;\n      },\n      barycenter: function () {\n        let t = this.options.gravitationalConstant,\n          e = this.barycenter.xFactor,\n          i = this.barycenter.yFactor;\n        e = (e - (this.box.left + this.box.width) / 2) * t, i = (i - (this.box.top + this.box.height) / 2) * t, this.nodes.forEach(function (t) {\n          t.fixedPosition || (t.plotX -= e / t.mass / t.degree, t.plotY -= i / t.mass / t.degree);\n        });\n      },\n      getK: function (t) {\n        return Math.pow(t.box.width * t.box.height / t.nodes.length, .5);\n      },\n      integrate: function (t, e) {\n        let i = -t.options.friction,\n          s = t.options.maxSpeed,\n          o = e.prevX,\n          a = e.prevY,\n          r = (e.plotX + e.dispX - o) * i,\n          n = (e.plotY + e.dispY - a) * i,\n          l = Math.abs,\n          h = l(r) / (r || 1),\n          p = l(n) / (n || 1);\n        r = h * Math.min(s, Math.abs(r)), n = p * Math.min(s, Math.abs(n)), e.prevX = e.plotX + e.dispX, e.prevY = e.plotY + e.dispY, e.plotX += r, e.plotY += n, e.temperature = t.vectorLength({\n          x: r,\n          y: n\n        });\n      },\n      repulsive: function (t, e, i) {\n        let s = e * this.diffTemperature / t.mass / t.degree;\n        t.fixedPosition || (t.plotX += i.x * s, t.plotY += i.y * s);\n      },\n      repulsiveForceFunction: function (t, e) {\n        return (e - t) / t * (e > t ? 1 : 0);\n      }\n    };\n  }), i(e, \"Series/PackedBubble/PackedBubbleIntegration.js\", [e[\"Core/Globals.js\"], e[\"Series/Networkgraph/VerletIntegration.js\"]], function (t, e) {\n    let {\n        noop: i\n      } = t,\n      s = {\n        barycenter: function () {\n          let t, e;\n          let i = this.options.gravitationalConstant,\n            s = this.box,\n            o = this.nodes;\n          for (let a of o) this.options.splitSeries && !a.isParentNode ? (t = a.series.parentNode.plotX, e = a.series.parentNode.plotY) : (t = s.width / 2, e = s.height / 2), a.fixedPosition || (a.plotX -= (a.plotX - t) * i / (a.mass * Math.sqrt(o.length)), a.plotY -= (a.plotY - e) * i / (a.mass * Math.sqrt(o.length)));\n        },\n        getK: i,\n        integrate: e.integrate,\n        repulsive: function (t, e, i, s) {\n          let o = e * this.diffTemperature / t.mass / t.degree,\n            a = i.x * o,\n            r = i.y * o;\n          t.fixedPosition || (t.plotX += a, t.plotY += r), s.fixedPosition || (s.plotX -= a, s.plotY -= r);\n        },\n        repulsiveForceFunction: function (t, e, i, s) {\n          return Math.min(t, (i.marker.radius + s.marker.radius) / 2);\n        }\n      };\n    return s;\n  }), i(e, \"Series/Networkgraph/EulerIntegration.js\", [], function () {\n    return {\n      attractive: function (t, e, i, s) {\n        let o = t.getMass(),\n          a = i.x / s * e,\n          r = i.y / s * e;\n        t.fromNode.fixedPosition || (t.fromNode.dispX -= a * o.fromNode / t.fromNode.degree, t.fromNode.dispY -= r * o.fromNode / t.fromNode.degree), t.toNode.fixedPosition || (t.toNode.dispX += a * o.toNode / t.toNode.degree, t.toNode.dispY += r * o.toNode / t.toNode.degree);\n      },\n      attractiveForceFunction: function (t, e) {\n        return t * t / e;\n      },\n      barycenter: function () {\n        let t = this.options.gravitationalConstant,\n          e = this.barycenter.xFactor,\n          i = this.barycenter.yFactor;\n        this.nodes.forEach(function (s) {\n          if (!s.fixedPosition) {\n            let o = s.getDegree(),\n              a = o * (1 + o / 2);\n            s.dispX += (e - s.plotX) * t * a / s.degree, s.dispY += (i - s.plotY) * t * a / s.degree;\n          }\n        });\n      },\n      getK: function (t) {\n        return Math.pow(t.box.width * t.box.height / t.nodes.length, .3);\n      },\n      integrate: function (t, e) {\n        let i;\n        e.dispX += e.dispX * t.options.friction, e.dispY += e.dispY * t.options.friction, 0 !== (i = e.temperature = t.vectorLength({\n          x: e.dispX,\n          y: e.dispY\n        })) && (e.plotX += e.dispX / i * Math.min(Math.abs(e.dispX), t.temperature), e.plotY += e.dispY / i * Math.min(Math.abs(e.dispY), t.temperature));\n      },\n      repulsive: function (t, e, i, s) {\n        t.dispX += i.x / s * e / t.degree, t.dispY += i.y / s * e / t.degree;\n      },\n      repulsiveForceFunction: function (t, e) {\n        return e * e / t;\n      }\n    };\n  }), i(e, \"Series/Networkgraph/QuadTreeNode.js\", [], function () {\n    class t {\n      constructor(t) {\n        this.body = !1, this.isEmpty = !1, this.isInternal = !1, this.nodes = [], this.box = t, this.boxSize = Math.min(t.width, t.height);\n      }\n      divideBox() {\n        let e = this.box.width / 2,\n          i = this.box.height / 2;\n        this.nodes[0] = new t({\n          left: this.box.left,\n          top: this.box.top,\n          width: e,\n          height: i\n        }), this.nodes[1] = new t({\n          left: this.box.left + e,\n          top: this.box.top,\n          width: e,\n          height: i\n        }), this.nodes[2] = new t({\n          left: this.box.left + e,\n          top: this.box.top + i,\n          width: e,\n          height: i\n        }), this.nodes[3] = new t({\n          left: this.box.left,\n          top: this.box.top + i,\n          width: e,\n          height: i\n        });\n      }\n      getBoxPosition(t) {\n        let e = t.plotX < this.box.left + this.box.width / 2,\n          i = t.plotY < this.box.top + this.box.height / 2;\n        return e ? i ? 0 : 3 : i ? 1 : 2;\n      }\n      insert(e, i) {\n        let s;\n        this.isInternal ? this.nodes[this.getBoxPosition(e)].insert(e, i - 1) : (this.isEmpty = !1, this.body ? i ? (this.isInternal = !0, this.divideBox(), !0 !== this.body && (this.nodes[this.getBoxPosition(this.body)].insert(this.body, i - 1), this.body = !0), this.nodes[this.getBoxPosition(e)].insert(e, i - 1)) : ((s = new t({\n          top: e.plotX || NaN,\n          left: e.plotY || NaN,\n          width: .1,\n          height: .1\n        })).body = e, s.isInternal = !1, this.nodes.push(s)) : (this.isInternal = !1, this.body = e));\n      }\n      updateMassAndCenter() {\n        let t = 0,\n          e = 0,\n          i = 0;\n        if (this.isInternal) {\n          for (let s of this.nodes) s.isEmpty || (t += s.mass, e += s.plotX * s.mass, i += s.plotY * s.mass);\n          e /= t, i /= t;\n        } else this.body && (t = this.body.mass, e = this.body.plotX, i = this.body.plotY);\n        this.mass = t, this.plotX = e, this.plotY = i;\n      }\n    }\n    return t;\n  }), i(e, \"Series/Networkgraph/QuadTree.js\", [e[\"Series/Networkgraph/QuadTreeNode.js\"]], function (t) {\n    return class {\n      constructor(e, i, s, o) {\n        this.box = {\n          left: e,\n          top: i,\n          width: s,\n          height: o\n        }, this.maxDepth = 25, this.root = new t(this.box), this.root.isInternal = !0, this.root.isRoot = !0, this.root.divideBox();\n      }\n      calculateMassAndCenter() {\n        this.visitNodeRecursive(null, null, function (t) {\n          t.updateMassAndCenter();\n        });\n      }\n      insertNodes(t) {\n        for (let e of t) this.root.insert(e, this.maxDepth);\n      }\n      visitNodeRecursive(t, e, i) {\n        let s;\n        if (t || (t = this.root), t === this.root && e && (s = e(t)), !1 !== s) {\n          for (let o of t.nodes) {\n            if (o.isInternal) {\n              if (e && (s = e(o)), !1 === s) continue;\n              this.visitNodeRecursive(o, e, i);\n            } else o.body && e && e(o.body);\n            i && i(o);\n          }\n          t === this.root && i && i(t);\n        }\n      }\n    };\n  }), i(e, \"Series/Networkgraph/ReingoldFruchtermanLayout.js\", [e[\"Series/Networkgraph/EulerIntegration.js\"], e[\"Core/Globals.js\"], e[\"Series/GraphLayoutComposition.js\"], e[\"Series/Networkgraph/QuadTree.js\"], e[\"Core/Utilities.js\"], e[\"Series/Networkgraph/VerletIntegration.js\"]], function (t, e, i, s, o, a) {\n    let {\n        win: r\n      } = e,\n      {\n        clamp: n,\n        defined: l,\n        isFunction: h,\n        fireEvent: p,\n        pick: d\n      } = o;\n    class c {\n      constructor() {\n        this.attractiveForce = void 0, this.box = {}, this.currentStep = 0, this.initialRendering = !0, this.integration = void 0, this.links = [], this.nodes = [], this.options = void 0, this.quadTree = void 0, this.repulsiveForce = void 0, this.series = [], this.simulation = !1;\n      }\n      static compose(e) {\n        i.compose(e), i.integrations.euler = t, i.integrations.verlet = a, i.layouts[\"reingold-fruchterman\"] = c;\n      }\n      init(t) {\n        this.options = t, this.nodes = [], this.links = [], this.series = [], this.box = {\n          x: 0,\n          y: 0,\n          width: 0,\n          height: 0\n        }, this.setInitialRendering(!0), this.integration = i.integrations[t.integration], this.enableSimulation = t.enableSimulation, this.attractiveForce = d(t.attractiveForce, this.integration.attractiveForceFunction), this.repulsiveForce = d(t.repulsiveForce, this.integration.repulsiveForceFunction), this.approximation = t.approximation;\n      }\n      updateSimulation(t) {\n        this.enableSimulation = d(t, this.options.enableSimulation);\n      }\n      start() {\n        let t = this.series,\n          e = this.options;\n        this.currentStep = 0, this.forces = t[0] && t[0].forces || [], this.chart = t[0] && t[0].chart, this.initialRendering && (this.initPositions(), t.forEach(function (t) {\n          t.finishedAnimating = !0, t.render();\n        })), this.setK(), this.resetSimulation(e), this.enableSimulation && this.step();\n      }\n      step() {\n        let t = this.series;\n        for (let t of (this.currentStep++, \"barnes-hut\" === this.approximation && (this.createQuadTree(), this.quadTree.calculateMassAndCenter()), this.forces || [])) this[t + \"Forces\"](this.temperature);\n        if (this.applyLimits(), this.temperature = this.coolDown(this.startTemperature, this.diffTemperature, this.currentStep), this.prevSystemTemperature = this.systemTemperature, this.systemTemperature = this.getSystemTemperature(), this.enableSimulation) {\n          for (let e of t) e.chart && e.render();\n          this.maxIterations-- && isFinite(this.temperature) && !this.isStable() ? (this.simulation && r.cancelAnimationFrame(this.simulation), this.simulation = r.requestAnimationFrame(() => this.step())) : (this.simulation = !1, this.series.forEach(t => {\n            p(t, \"afterSimulation\");\n          }));\n        }\n      }\n      stop() {\n        this.simulation && r.cancelAnimationFrame(this.simulation);\n      }\n      setArea(t, e, i, s) {\n        this.box = {\n          left: t,\n          top: e,\n          width: i,\n          height: s\n        };\n      }\n      setK() {\n        this.k = this.options.linkLength || this.integration.getK(this);\n      }\n      addElementsToCollection(t, e) {\n        for (let i of t) -1 === e.indexOf(i) && e.push(i);\n      }\n      removeElementFromCollection(t, e) {\n        let i = e.indexOf(t);\n        -1 !== i && e.splice(i, 1);\n      }\n      clear() {\n        this.nodes.length = 0, this.links.length = 0, this.series.length = 0, this.resetSimulation();\n      }\n      resetSimulation() {\n        this.forcedStop = !1, this.systemTemperature = 0, this.setMaxIterations(), this.setTemperature(), this.setDiffTemperature();\n      }\n      restartSimulation() {\n        this.simulation ? this.resetSimulation() : (this.setInitialRendering(!1), this.enableSimulation ? this.start() : this.setMaxIterations(1), this.chart && this.chart.redraw(), this.setInitialRendering(!0));\n      }\n      setMaxIterations(t) {\n        this.maxIterations = d(t, this.options.maxIterations);\n      }\n      setTemperature() {\n        this.temperature = this.startTemperature = Math.sqrt(this.nodes.length);\n      }\n      setDiffTemperature() {\n        this.diffTemperature = this.startTemperature / (this.options.maxIterations + 1);\n      }\n      setInitialRendering(t) {\n        this.initialRendering = t;\n      }\n      createQuadTree() {\n        this.quadTree = new s(this.box.left, this.box.top, this.box.width, this.box.height), this.quadTree.insertNodes(this.nodes);\n      }\n      initPositions() {\n        let t = this.options.initialPositions;\n        if (h(t)) for (let e of (t.call(this), this.nodes)) l(e.prevX) || (e.prevX = e.plotX), l(e.prevY) || (e.prevY = e.plotY), e.dispX = 0, e.dispY = 0;else \"circle\" === t ? this.setCircularPositions() : this.setRandomPositions();\n      }\n      setCircularPositions() {\n        let t;\n        let e = this.box,\n          i = this.nodes,\n          s = i.length + 1,\n          o = 2 * Math.PI / s,\n          a = i.filter(function (t) {\n            return 0 === t.linksTo.length;\n          }),\n          r = {},\n          n = this.options.initialPositionRadius,\n          l = t => {\n            for (let e of t.linksFrom || []) r[e.toNode.id] || (r[e.toNode.id] = !0, h.push(e.toNode), l(e.toNode));\n          },\n          h = [];\n        for (let t of a) h.push(t), l(t);\n        if (h.length) for (let t of i) -1 === h.indexOf(t) && h.push(t);else h = i;\n        for (let i = 0, s = h.length; i < s; ++i) (t = h[i]).plotX = t.prevX = d(t.plotX, e.width / 2 + n * Math.cos(i * o)), t.plotY = t.prevY = d(t.plotY, e.height / 2 + n * Math.sin(i * o)), t.dispX = 0, t.dispY = 0;\n      }\n      setRandomPositions() {\n        let t;\n        let e = this.box,\n          i = this.nodes,\n          s = i.length + 1,\n          o = t => {\n            let e = t * t / Math.PI;\n            return e - Math.floor(e);\n          };\n        for (let a = 0, r = i.length; a < r; ++a) (t = i[a]).plotX = t.prevX = d(t.plotX, e.width * o(a)), t.plotY = t.prevY = d(t.plotY, e.height * o(s + a)), t.dispX = 0, t.dispY = 0;\n      }\n      force(t, ...e) {\n        this.integration[t].apply(this, e);\n      }\n      barycenterForces() {\n        this.getBarycenter(), this.force(\"barycenter\");\n      }\n      getBarycenter() {\n        let t = 0,\n          e = 0,\n          i = 0;\n        for (let s of this.nodes) e += s.plotX * s.mass, i += s.plotY * s.mass, t += s.mass;\n        return this.barycenter = {\n          x: e,\n          y: i,\n          xFactor: e / t,\n          yFactor: i / t\n        }, this.barycenter;\n      }\n      barnesHutApproximation(t, e) {\n        let i, s;\n        let o = this.getDistXY(t, e),\n          a = this.vectorLength(o);\n        return t !== e && 0 !== a && (e.isInternal ? e.boxSize / a < this.options.theta && 0 !== a ? (s = this.repulsiveForce(a, this.k), this.force(\"repulsive\", t, s * e.mass, o, a), i = !1) : i = !0 : (s = this.repulsiveForce(a, this.k), this.force(\"repulsive\", t, s * e.mass, o, a))), i;\n      }\n      repulsiveForces() {\n        if (\"barnes-hut\" === this.approximation) for (let t of this.nodes) this.quadTree.visitNodeRecursive(null, e => this.barnesHutApproximation(t, e));else {\n          let t, e, i;\n          for (let s of this.nodes) for (let o of this.nodes) s === o || s.fixedPosition || (i = this.getDistXY(s, o), 0 !== (e = this.vectorLength(i)) && (t = this.repulsiveForce(e, this.k), this.force(\"repulsive\", s, t * o.mass, i, e)));\n        }\n      }\n      attractiveForces() {\n        let t, e, i;\n        for (let s of this.links) s.fromNode && s.toNode && (t = this.getDistXY(s.fromNode, s.toNode), 0 !== (e = this.vectorLength(t)) && (i = this.attractiveForce(e, this.k), this.force(\"attractive\", s, i, t, e)));\n      }\n      applyLimits() {\n        let t = this.nodes;\n        for (let e of t) {\n          if (e.fixedPosition) return;\n          this.integration.integrate(this, e), this.applyLimitBox(e, this.box), e.dispX = 0, e.dispY = 0;\n        }\n      }\n      applyLimitBox(t, e) {\n        let i = t.radius;\n        t.plotX = n(t.plotX, e.left + i, e.width - i), t.plotY = n(t.plotY, e.top + i, e.height - i);\n      }\n      coolDown(t, e, i) {\n        return t - e * i;\n      }\n      isStable() {\n        return 1e-5 > Math.abs(this.systemTemperature - this.prevSystemTemperature) || this.temperature <= 0;\n      }\n      getSystemTemperature() {\n        let t = 0;\n        for (let e of this.nodes) t += e.temperature;\n        return t;\n      }\n      vectorLength(t) {\n        return Math.sqrt(t.x * t.x + t.y * t.y);\n      }\n      getDistR(t, e) {\n        let i = this.getDistXY(t, e);\n        return this.vectorLength(i);\n      }\n      getDistXY(t, e) {\n        let i = t.plotX - e.plotX,\n          s = t.plotY - e.plotY;\n        return {\n          x: i,\n          y: s,\n          absX: Math.abs(i),\n          absY: Math.abs(s)\n        };\n      }\n    }\n    return c;\n  }), i(e, \"Series/PackedBubble/PackedBubbleLayout.js\", [e[\"Series/GraphLayoutComposition.js\"], e[\"Series/PackedBubble/PackedBubbleIntegration.js\"], e[\"Series/Networkgraph/ReingoldFruchtermanLayout.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s) {\n    let {\n        addEvent: o,\n        pick: a\n      } = s,\n      r = [];\n    function n() {\n      let t = this.series,\n        e = [];\n      return t.forEach(t => {\n        t.parentNode && t.parentNode.selected && e.push(t.parentNode);\n      }), e;\n    }\n    function l() {\n      this.allDataPoints && delete this.allDataPoints;\n    }\n    class h extends i {\n      constructor() {\n        super(...arguments), this.index = NaN, this.nodes = [], this.options = void 0, this.series = [];\n      }\n      static compose(a) {\n        if (i.compose(a), t.integrations.packedbubble = e, t.layouts.packedbubble = h, s.pushUnique(r, a)) {\n          o(a, \"beforeRedraw\", l);\n          let t = a.prototype;\n          t.getSelectedParentNodes = n;\n        }\n      }\n      beforeStep() {\n        this.options.marker && this.series.forEach(t => {\n          t && t.calculateParentRadius();\n        });\n      }\n      isStable() {\n        let t = Math.abs(this.prevSystemTemperature - this.systemTemperature),\n          e = 10 * this.systemTemperature / Math.sqrt(this.nodes.length);\n        return 1 > Math.abs(e) && t < 1e-5 || this.temperature <= 0;\n      }\n      setCircularPositions() {\n        let t = this.box,\n          e = this.nodes,\n          i = e.length + 1,\n          s = 2 * Math.PI / i,\n          o = this.options.initialPositionRadius,\n          r,\n          n,\n          l = 0;\n        for (let i of e) this.options.splitSeries && !i.isParentNode ? (r = i.series.parentNode.plotX, n = i.series.parentNode.plotY) : (r = t.width / 2, n = t.height / 2), i.plotX = i.prevX = a(i.plotX, r + o * Math.cos(i.index || l * s)), i.plotY = i.prevY = a(i.plotY, n + o * Math.sin(i.index || l * s)), i.dispX = 0, i.dispY = 0, l++;\n      }\n      repulsiveForces() {\n        let t, e, i;\n        let s = this,\n          o = s.options.bubblePadding;\n        s.nodes.forEach(a => {\n          a.degree = a.mass, a.neighbours = 0, s.nodes.forEach(r => {\n            t = 0, a !== r && !a.fixedPosition && (s.options.seriesInteraction || a.series === r.series) && (i = s.getDistXY(a, r), (e = s.vectorLength(i) - (a.marker.radius + r.marker.radius + o)) < 0 && (a.degree += .01, a.neighbours++, t = s.repulsiveForce(-e / Math.sqrt(a.neighbours), s.k, a, r)), s.force(\"repulsive\", a, t * r.mass, i, r, e));\n          });\n        });\n      }\n      applyLimitBox(t, e) {\n        let i, s;\n        this.options.splitSeries && !t.isParentNode && this.options.parentNodeLimit && (i = this.getDistXY(t, t.series.parentNode), (s = t.series.parentNodeRadius - t.marker.radius - this.vectorLength(i)) < 0 && s > -2 * t.marker.radius && (t.plotX -= .01 * i.x, t.plotY -= .01 * i.y)), super.applyLimitBox(t, e);\n      }\n    }\n    return t.layouts.packedbubble = h, h;\n  }), i(e, \"Series/SimulationSeriesUtilities.js\", [e[\"Core/Utilities.js\"], e[\"Core/Animation/AnimationUtilities.js\"]], function (t, e) {\n    let {\n        syncTimeout: i\n      } = t,\n      {\n        animObject: s\n      } = e;\n    return {\n      initDataLabels: function () {\n        let t = this.options.dataLabels;\n        if (!this.dataLabelsGroup) {\n          let e = this.initDataLabelsGroup();\n          return !this.chart.styledMode && t?.style && e.css(t.style), e.attr({\n            opacity: 0\n          }), this.visible && e.show(), e;\n        }\n        return this.dataLabelsGroup.attr({\n          opacity: 1\n        }), this.dataLabelsGroup;\n      },\n      initDataLabelsDefer: function () {\n        let t = this.options.dataLabels;\n        t?.defer && this.options.layoutAlgorithm?.enableSimulation ? i(() => {\n          this.deferDataLabels = !1;\n        }, t ? s(t.animation).defer : 0) : this.deferDataLabels = !1;\n      }\n    };\n  }), i(e, \"Series/PackedBubble/PackedBubbleSeries.js\", [e[\"Core/Color/Color.js\"], e[\"Series/DragNodesComposition.js\"], e[\"Series/GraphLayoutComposition.js\"], e[\"Core/Globals.js\"], e[\"Series/PackedBubble/PackedBubblePoint.js\"], e[\"Series/PackedBubble/PackedBubbleSeriesDefaults.js\"], e[\"Series/PackedBubble/PackedBubbleLayout.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Series/SimulationSeriesUtilities.js\"], e[\"Core/Utilities.js\"], e[\"Core/Animation/AnimationUtilities.js\"]], function (t, e, i, s, o, a, r, n, l, h, p) {\n    let {\n        parse: d\n      } = t,\n      {\n        noop: c\n      } = s,\n      {\n        series: {\n          prototype: u\n        },\n        seriesTypes: {\n          bubble: g\n        }\n      } = n,\n      {\n        initDataLabels: f,\n        initDataLabelsDefer: b\n      } = l,\n      {\n        addEvent: m,\n        clamp: y,\n        defined: x,\n        extend: P,\n        fireEvent: v,\n        isArray: S,\n        isNumber: M,\n        merge: L,\n        pick: k,\n        syncTimeout: C\n      } = h,\n      {\n        animObject: w\n      } = p;\n    class A extends g {\n      constructor() {\n        super(...arguments), this.chart = void 0, this.data = void 0, this.layout = void 0, this.options = void 0, this.parentNodeMass = 0, this.points = void 0, this.xData = void 0, this.deferDataLabels = !0;\n      }\n      static compose(t, i, s, o) {\n        g.compose(t, i, s, o), e.compose(i), r.compose(i);\n      }\n      accumulateAllPoints() {\n        let t;\n        let e = this.chart,\n          i = [];\n        for (let s of e.series) if (s.is(\"packedbubble\") && s.reserveSpace()) {\n          t = s.yData || [];\n          for (let e = 0; e < t.length; e++) i.push([null, null, t[e], s.index, e, {\n            id: e,\n            marker: {\n              radius: 0\n            }\n          }]);\n        }\n        return i;\n      }\n      addLayout() {\n        let t = this.options.layoutAlgorithm = this.options.layoutAlgorithm || {},\n          e = t.type || \"packedbubble\",\n          s = this.chart.options.chart,\n          o = this.chart.graphLayoutsStorage,\n          a = this.chart.graphLayoutsLookup,\n          r;\n        o || (this.chart.graphLayoutsStorage = o = {}, this.chart.graphLayoutsLookup = a = []), (r = o[e]) || (t.enableSimulation = x(s.forExport) ? !s.forExport : t.enableSimulation, o[e] = r = new i.layouts[e](), r.init(t), a.splice(r.index, 0, r)), this.layout = r, this.points.forEach(t => {\n          t.mass = 2, t.degree = 1, t.collisionNmb = 1;\n        }), r.setArea(0, 0, this.chart.plotWidth, this.chart.plotHeight), r.addElementsToCollection([this], r.series), r.addElementsToCollection(this.points, r.nodes);\n      }\n      addSeriesLayout() {\n        let t = this.options.layoutAlgorithm = this.options.layoutAlgorithm || {},\n          e = t.type || \"packedbubble\",\n          s = this.chart.graphLayoutsStorage,\n          o = this.chart.graphLayoutsLookup,\n          a = L(t, t.parentNodeOptions, {\n            enableSimulation: this.layout.options.enableSimulation\n          }),\n          r = s[e + \"-series\"];\n        r || (s[e + \"-series\"] = r = new i.layouts[e](), r.init(a), o.splice(r.index, 0, r)), this.parentNodeLayout = r, this.createParentNodes();\n      }\n      calculateParentRadius() {\n        let t = this.seriesBox();\n        this.parentNodeRadius = y(Math.sqrt(2 * this.parentNodeMass / Math.PI) + 20, 20, t ? Math.max(Math.sqrt(Math.pow(t.width, 2) + Math.pow(t.height, 2)) / 2 + 20, 20) : Math.sqrt(2 * this.parentNodeMass / Math.PI) + 20), this.parentNode && (this.parentNode.marker.radius = this.parentNode.radius = this.parentNodeRadius);\n      }\n      calculateZExtremes() {\n        let t = this.chart,\n          e = t.series,\n          i = this.options.zMin,\n          s = this.options.zMax,\n          o = 1 / 0,\n          a = -1 / 0;\n        return i && s ? [i, s] : (e.forEach(t => {\n          t.yData.forEach(t => {\n            x(t) && (t > a && (a = t), t < o && (o = t));\n          });\n        }), [i = k(i, o), s = k(s, a)]);\n      }\n      checkOverlap(t, e) {\n        let i = t[0] - e[0],\n          s = t[1] - e[1],\n          o = t[2] + e[2];\n        return Math.sqrt(i * i + s * s) - Math.abs(o) < -.001;\n      }\n      createParentNodes() {\n        let t = this.pointClass,\n          e = this.chart,\n          i = this.parentNodeLayout,\n          s = this.layout.options,\n          o,\n          a = this.parentNode,\n          r = {\n            radius: this.parentNodeRadius,\n            lineColor: this.color,\n            fillColor: d(this.color).brighten(.4).get()\n          };\n        s.parentNodeOptions && (r = L(s.parentNodeOptions.marker || {}, r)), this.parentNodeMass = 0, this.points.forEach(t => {\n          this.parentNodeMass += Math.PI * Math.pow(t.marker.radius, 2);\n        }), this.calculateParentRadius(), i.nodes.forEach(t => {\n          t.seriesIndex === this.index && (o = !0);\n        }), i.setArea(0, 0, e.plotWidth, e.plotHeight), o || (a || (a = new t().init(this, {\n          mass: this.parentNodeRadius / 2,\n          marker: r,\n          dataLabels: {\n            inside: !1\n          },\n          states: {\n            normal: {\n              marker: r\n            },\n            hover: {\n              marker: r\n            }\n          },\n          dataLabelOnNull: !0,\n          degree: this.parentNodeRadius,\n          isParentNode: !0,\n          seriesIndex: this.index\n        })), this.parentNode && (a.plotX = this.parentNode.plotX, a.plotY = this.parentNode.plotY), this.parentNode = a, i.addElementsToCollection([this], i.series), i.addElementsToCollection([a], i.nodes));\n      }\n      deferLayout() {\n        let t = this.options.layoutAlgorithm;\n        this.visible && (this.addLayout(), t.splitSeries && this.addSeriesLayout());\n      }\n      destroy() {\n        this.chart.graphLayoutsLookup && this.chart.graphLayoutsLookup.forEach(t => {\n          t.removeElementFromCollection(this, t.series);\n        }, this), this.parentNode && this.parentNodeLayout && (this.parentNodeLayout.removeElementFromCollection(this.parentNode, this.parentNodeLayout.nodes), this.parentNode.dataLabel && (this.parentNode.dataLabel = this.parentNode.dataLabel.destroy())), u.destroy.apply(this, arguments);\n      }\n      drawDataLabels() {\n        !this.deferDataLabels && (u.drawDataLabels.call(this, this.points), this.parentNode && (this.parentNode.formatPrefix = \"parentNode\", u.drawDataLabels.call(this, [this.parentNode])));\n      }\n      drawGraph() {\n        if (!this.layout || !this.layout.options.splitSeries) return;\n        let t = this.chart,\n          e = this.layout.options.parentNodeOptions.marker,\n          i = {\n            fill: e.fillColor || d(this.color).brighten(.4).get(),\n            opacity: e.fillOpacity,\n            stroke: e.lineColor || this.color,\n            \"stroke-width\": k(e.lineWidth, this.options.lineWidth)\n          },\n          s = {};\n        this.parentNodesGroup = this.plotGroup(\"parentNodesGroup\", \"parentNode\", this.visible ? \"inherit\" : \"hidden\", .1, t.seriesGroup), this.group?.attr({\n          zIndex: 2\n        }), this.calculateParentRadius(), this.parentNode && x(this.parentNode.plotX) && x(this.parentNode.plotY) && x(this.parentNodeRadius) && (s = L({\n          x: this.parentNode.plotX - this.parentNodeRadius,\n          y: this.parentNode.plotY - this.parentNodeRadius,\n          width: 2 * this.parentNodeRadius,\n          height: 2 * this.parentNodeRadius\n        }, i), this.parentNode.graphic || (this.graph = this.parentNode.graphic = t.renderer.symbol(i.symbol).add(this.parentNodesGroup)), this.parentNode.graphic.attr(s));\n      }\n      drawTracker() {\n        let t;\n        let e = this.parentNode;\n        super.drawTracker(), e && (t = S(e.dataLabels) ? e.dataLabels : e.dataLabel ? [e.dataLabel] : [], e.graphic && (e.graphic.element.point = e), t.forEach(t => {\n          t.div ? t.div.point = e : t.element.point = e;\n        }));\n      }\n      getPointRadius() {\n        let t, e, i, s;\n        let o = this.chart,\n          a = o.plotWidth,\n          r = o.plotHeight,\n          n = this.options,\n          l = n.useSimulation,\n          h = Math.min(a, r),\n          p = {},\n          d = [],\n          c = o.allDataPoints || [],\n          u = c.length;\n        [\"minSize\", \"maxSize\"].forEach(t => {\n          let e = parseInt(n[t], 10),\n            i = /%$/.test(n[t]);\n          p[t] = i ? h * e / 100 : e * Math.sqrt(u);\n        }), o.minRadius = t = p.minSize / Math.sqrt(u), o.maxRadius = e = p.maxSize / Math.sqrt(u);\n        let g = l ? this.calculateZExtremes() : [t, e];\n        c.forEach((o, a) => {\n          i = l ? y(o[2], g[0], g[1]) : o[2], 0 === (s = this.getRadius(g[0], g[1], t, e, i)) && (s = null), c[a][2] = s, d.push(s);\n        }), this.radii = d;\n      }\n      init() {\n        return u.init.apply(this, arguments), b.call(this), this.eventsToUnbind.push(m(this, \"updatedData\", function () {\n          this.chart.series.forEach(t => {\n            t.type === this.type && (t.isDirty = !0);\n          }, this);\n        })), this;\n      }\n      onMouseUp(t) {\n        if (t.fixedPosition && !t.removed) {\n          let i;\n          let s = this.layout,\n            o = this.parentNodeLayout;\n          o && s.options.dragBetweenSeries && o.nodes.forEach(e => {\n            t && t.marker && e !== t.series.parentNode && (i = s.getDistXY(t, e), s.vectorLength(i) - e.marker.radius - t.marker.radius < 0 && (e.series.addPoint(L(t.options, {\n              plotX: t.plotX,\n              plotY: t.plotY\n            }), !1), s.removeElementFromCollection(t, s.nodes), t.remove()));\n          }), e.onMouseUp.apply(this, arguments);\n        }\n      }\n      placeBubbles(t) {\n        let e = this.checkOverlap,\n          i = this.positionBubble,\n          s = [],\n          o = 1,\n          a = 0,\n          r = 0,\n          n,\n          l = [],\n          h,\n          p = t.sort((t, e) => e[2] - t[2]);\n        if (p.length) {\n          if (s.push([[0, 0, p[0][2], p[0][3], p[0][4]]]), p.length > 1) for (s.push([[0, 0 - p[1][2] - p[0][2], p[1][2], p[1][3], p[1][4]]]), h = 2; h < p.length; h++) p[h][2] = p[h][2] || 1, e(n = i(s[o][a], s[o - 1][r], p[h]), s[o][0]) ? (s.push([]), r = 0, s[o + 1].push(i(s[o][a], s[o][0], p[h])), o++, a = 0) : o > 1 && s[o - 1][r + 1] && e(n, s[o - 1][r + 1]) ? (r++, s[o].push(i(s[o][a], s[o - 1][r], p[h])), a++) : (a++, s[o].push(n));\n          this.chart.stages = s, this.chart.rawPositions = [].concat.apply([], s), this.resizeRadius(), l = this.chart.rawPositions;\n        }\n        return l;\n      }\n      pointAttribs(t, e) {\n        let i = this.options,\n          s = t && t.isParentNode,\n          o = i.marker;\n        s && i.layoutAlgorithm && i.layoutAlgorithm.parentNodeOptions && (o = i.layoutAlgorithm.parentNodeOptions.marker);\n        let a = o.fillOpacity,\n          r = u.pointAttribs.call(this, t, e);\n        return 1 !== a && (r[\"fill-opacity\"] = a), r;\n      }\n      positionBubble(t, e, i) {\n        let s = Math.pow,\n          o = (0, Math.sqrt)(s(t[0] - e[0], 2) + s(t[1] - e[1], 2)),\n          a = (0, Math.acos)((s(o, 2) + s(i[2] + e[2], 2) - s(i[2] + t[2], 2)) / (2 * (i[2] + e[2]) * o)),\n          r = (0, Math.asin)((0, Math.abs)(t[0] - e[0]) / o),\n          n = t[1] - e[1] < 0 ? 0 : Math.PI,\n          l = (t[0] - e[0]) * (t[1] - e[1]) < 0 ? 1 : -1,\n          h = n + a + r * l,\n          p = e[0] + (e[2] + i[2]) * Math.sin(h),\n          d = e[1] - (e[2] + i[2]) * Math.cos(h);\n        return [p, d, i[2], i[3], i[4]];\n      }\n      render() {\n        let t = [];\n        u.render.apply(this, arguments), !this.options.dataLabels.allowOverlap && (this.data.forEach(e => {\n          S(e.dataLabels) && e.dataLabels.forEach(e => {\n            t.push(e);\n          });\n        }), this.options.useSimulation && this.chart.hideOverlappingLabels(t));\n      }\n      resizeRadius() {\n        let t, e, i, s, o;\n        let a = this.chart,\n          r = a.rawPositions,\n          n = Math.min,\n          l = Math.max,\n          h = a.plotLeft,\n          p = a.plotTop,\n          d = a.plotHeight,\n          c = a.plotWidth;\n        for (let a of (t = i = Number.POSITIVE_INFINITY, e = s = Number.NEGATIVE_INFINITY, r)) o = a[2], t = n(t, a[0] - o), e = l(e, a[0] + o), i = n(i, a[1] - o), s = l(s, a[1] + o);\n        let u = [e - t, s - i],\n          g = [(c - h) / u[0], (d - p) / u[1]],\n          f = n.apply([], g);\n        if (Math.abs(f - 1) > 1e-10) {\n          for (let t of r) t[2] *= f;\n          this.placeBubbles(r);\n        } else a.diffY = d / 2 + p - i - (s - i) / 2, a.diffX = c / 2 + h - t - (e - t) / 2;\n      }\n      seriesBox() {\n        let t;\n        let e = this.chart,\n          i = this.data,\n          s = Math.max,\n          o = Math.min,\n          a = [e.plotLeft, e.plotLeft + e.plotWidth, e.plotTop, e.plotTop + e.plotHeight];\n        return i.forEach(e => {\n          x(e.plotX) && x(e.plotY) && e.marker.radius && (t = e.marker.radius, a[0] = o(a[0], e.plotX - t), a[1] = s(a[1], e.plotX + t), a[2] = o(a[2], e.plotY - t), a[3] = s(a[3], e.plotY + t));\n        }), M(a.width / a.height) ? a : null;\n      }\n      setVisible() {\n        let t = this;\n        u.setVisible.apply(t, arguments), t.parentNodeLayout && t.graph ? t.visible ? (t.graph.show(), t.parentNode.dataLabel && t.parentNode.dataLabel.show()) : (t.graph.hide(), t.parentNodeLayout.removeElementFromCollection(t.parentNode, t.parentNodeLayout.nodes), t.parentNode.dataLabel && t.parentNode.dataLabel.hide()) : t.layout && (t.visible ? t.layout.addElementsToCollection(t.points, t.layout.nodes) : t.points.forEach(e => {\n          t.layout.removeElementFromCollection(e, t.layout.nodes);\n        }));\n      }\n      translate() {\n        let t, e, i;\n        let s = this.chart,\n          o = this.data,\n          a = this.index,\n          r = this.options.useSimulation;\n        for (let n of (this.processedXData = this.xData, this.generatePoints(), x(s.allDataPoints) || (s.allDataPoints = this.accumulateAllPoints(), this.getPointRadius()), r ? i = s.allDataPoints : (i = this.placeBubbles(s.allDataPoints), this.options.draggable = !1), i)) n[3] === a && (t = o[n[4]], e = k(n[2], void 0), r || (t.plotX = n[0] - s.plotLeft + s.diffX, t.plotY = n[1] - s.plotTop + s.diffY), M(e) && (t.marker = P(t.marker, {\n          radius: e,\n          width: 2 * e,\n          height: 2 * e\n        }), t.radius = e));\n        r && this.deferLayout(), v(this, \"afterTranslate\");\n      }\n    }\n    return A.defaultOptions = L(g.defaultOptions, a), P(A.prototype, {\n      pointClass: o,\n      axisTypes: [],\n      directTouch: !0,\n      forces: [\"barycenter\", \"repulsive\"],\n      hasDraggableNodes: !0,\n      isCartesian: !1,\n      noSharedTooltip: !0,\n      pointArrayMap: [\"value\"],\n      pointValKey: \"value\",\n      requireSorting: !1,\n      trackerGroups: [\"group\", \"dataLabelsGroup\", \"parentNodesGroup\"],\n      initDataLabels: f,\n      alignDataLabel: u.alignDataLabel,\n      indexateNodes: c,\n      onMouseDown: e.onMouseDown,\n      onMouseMove: e.onMouseMove,\n      redrawHalo: e.redrawHalo,\n      searchPoint: c\n    }), n.registerSeriesType(\"packedbubble\", A), A;\n  }), i(e, \"Series/Polygon/PolygonSeriesDefaults.js\", [], function () {\n    return {\n      marker: {\n        enabled: !1,\n        states: {\n          hover: {\n            enabled: !1\n          }\n        }\n      },\n      stickyTracking: !1,\n      tooltip: {\n        followPointer: !0,\n        pointFormat: \"\"\n      },\n      trackByArea: !0,\n      legendSymbol: \"rectangle\"\n    };\n  }), i(e, \"Series/Polygon/PolygonSeries.js\", [e[\"Core/Globals.js\"], e[\"Series/Polygon/PolygonSeriesDefaults.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s) {\n    let {\n        noop: o\n      } = t,\n      {\n        area: a,\n        line: r,\n        scatter: n\n      } = i.seriesTypes,\n      {\n        extend: l,\n        merge: h\n      } = s;\n    class p extends n {\n      constructor() {\n        super(...arguments), this.data = void 0, this.options = void 0, this.points = void 0;\n      }\n      getGraphPath() {\n        let t = r.prototype.getGraphPath.call(this),\n          e = t.length + 1;\n        for (; e--;) (e === t.length || \"M\" === t[e][0]) && e > 0 && t.splice(e, 0, [\"Z\"]);\n        return this.areaPath = t, t;\n      }\n      drawGraph() {\n        this.options.fillColor = this.color, a.prototype.drawGraph.call(this);\n      }\n    }\n    return p.defaultOptions = h(n.defaultOptions, e), l(p.prototype, {\n      type: \"polygon\",\n      drawTracker: r.prototype.drawTracker,\n      setStackedPoints: o\n    }), i.registerSeriesType(\"polygon\", p), p;\n  }), i(e, \"Core/Axis/RadialAxis.js\", [e[\"Core/Axis/AxisDefaults.js\"], e[\"Core/Defaults.js\"], e[\"Core/Globals.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s) {\n    var o;\n    let {\n        defaultOptions: a\n      } = e,\n      {\n        noop: r\n      } = i,\n      {\n        addEvent: n,\n        correctFloat: l,\n        defined: h,\n        extend: p,\n        fireEvent: d,\n        merge: c,\n        pick: u,\n        relativeLength: g,\n        wrap: f\n      } = s;\n    return function (e) {\n      let i = [],\n        o = {\n          gridLineWidth: 1,\n          labels: {\n            align: void 0,\n            x: 0,\n            y: void 0,\n            style: {\n              textOverflow: \"none\"\n            }\n          },\n          maxPadding: 0,\n          minPadding: 0,\n          showLastLabel: !1,\n          tickLength: 0\n        },\n        b = {\n          labels: {\n            align: \"center\",\n            distance: -25,\n            x: 0,\n            y: void 0\n          },\n          minorGridLineWidth: 0,\n          minorTickInterval: \"auto\",\n          minorTickLength: 10,\n          minorTickPosition: \"inside\",\n          minorTickWidth: 1,\n          tickLength: 10,\n          tickPosition: \"inside\",\n          tickWidth: 2,\n          title: {\n            rotation: 0\n          },\n          zIndex: 2\n        },\n        m = {\n          gridLineInterpolation: \"circle\",\n          gridLineWidth: 1,\n          labels: {\n            align: \"right\",\n            x: -3,\n            y: -2\n          },\n          showLastLabel: !1,\n          title: {\n            x: 4,\n            text: null,\n            rotation: 90\n          }\n        };\n      function y() {\n        this.autoConnect = this.isCircular && void 0 === u(this.userMax, this.options.max) && l(this.endAngleRad - this.startAngleRad) === l(2 * Math.PI), !this.isCircular && this.chart.inverted && this.max++, this.autoConnect && (this.max += this.categories && 1 || this.pointRange || this.closestPointRange || 0);\n      }\n      function x() {\n        return () => {\n          if (this.isRadial && this.tickPositions && this.options.labels && !0 !== this.options.labels.allowOverlap) return this.tickPositions.map(t => this.ticks[t] && this.ticks[t].label).filter(t => !!t);\n        };\n      }\n      function P() {\n        return r;\n      }\n      function v(t, e, i) {\n        let s = this.pane.center,\n          o = t.value,\n          a,\n          r,\n          n;\n        return this.isCircular ? (h(o) ? t.point && (t.point.shapeArgs || {}).start && (o = this.chart.inverted ? this.translate(t.point.rectPlotY, !0) : t.point.x) : (r = t.chartX || 0, n = t.chartY || 0, o = this.translate(Math.atan2(n - i, r - e) - this.startAngleRad, !0)), r = (a = this.getPosition(o)).x, n = a.y) : (h(o) || (r = t.chartX, n = t.chartY), h(r) && h(n) && (i = s[1] + this.chart.plotTop, o = this.translate(Math.min(Math.sqrt(Math.pow(r - e, 2) + Math.pow(n - i, 2)), s[2] / 2) - s[3] / 2, !0))), [o, r || 0, n || 0];\n      }\n      function S(t, e, i) {\n        let s = this.pane.center,\n          o = this.chart,\n          a = this.left || 0,\n          r = this.top || 0,\n          n,\n          l = u(e, s[2] / 2 - this.offset),\n          h;\n        return void 0 === i && (i = this.horiz ? 0 : this.center && -this.center[3] / 2), i && (l += i), this.isCircular || void 0 !== e ? ((h = this.chart.renderer.symbols.arc(a + s[0], r + s[1], l, l, {\n          start: this.startAngleRad,\n          end: this.endAngleRad,\n          open: !0,\n          innerR: 0\n        })).xBounds = [a + s[0]], h.yBounds = [r + s[1] - l]) : (n = this.postTranslate(this.angleRad, l), h = [[\"M\", this.center[0] + o.plotLeft, this.center[1] + o.plotTop], [\"L\", n.x, n.y]]), h;\n      }\n      function M() {\n        let t = this.constructor.prototype;\n        t.getOffset.call(this), this.chart.axisOffset[this.side] = 0;\n      }\n      function L(t, e, i) {\n        let s = this.chart,\n          o = t => {\n            if (\"string\" == typeof t) {\n              let e = parseInt(t, 10);\n              return d.test(t) && (e = e * n / 100), e;\n            }\n            return t;\n          },\n          a = this.center,\n          r = this.startAngleRad,\n          n = a[2] / 2,\n          l = Math.min(this.offset, 0),\n          h = this.left || 0,\n          p = this.top || 0,\n          d = /%$/,\n          c = this.isCircular,\n          g,\n          f,\n          b,\n          m,\n          y,\n          x,\n          P = u(o(i.outerRadius), n),\n          v = o(i.innerRadius),\n          S = u(o(i.thickness), 10);\n        if (\"polygon\" === this.options.gridLineInterpolation) x = this.getPlotLinePath({\n          value: t\n        }).concat(this.getPlotLinePath({\n          value: e,\n          reverse: !0\n        }));else {\n          t = Math.max(t, this.min), e = Math.min(e, this.max);\n          let o = this.translate(t),\n            n = this.translate(e);\n          c || (P = o || 0, v = n || 0), \"circle\" !== i.shape && c ? (g = r + (o || 0), f = r + (n || 0)) : (g = -Math.PI / 2, f = 1.5 * Math.PI, y = !0), P -= l, S -= l, x = s.renderer.symbols.arc(h + a[0], p + a[1], P, P, {\n            start: Math.min(g, f),\n            end: Math.max(g, f),\n            innerR: u(v, P - S),\n            open: y\n          }), c && (b = (f + g) / 2, m = h + a[0] + a[2] / 2 * Math.cos(b), x.xBounds = b > -Math.PI / 2 && b < Math.PI / 2 ? [m, s.plotWidth] : [0, m], x.yBounds = [p + a[1] + a[2] / 2 * Math.sin(b)], x.yBounds[0] += b > -Math.PI && b < 0 || b > Math.PI ? -10 : 10);\n        }\n        return x;\n      }\n      function k(t) {\n        let e = this.pane.center,\n          i = this.chart,\n          s = i.inverted,\n          o = t.reverse,\n          a = this.pane.options.background ? this.pane.options.background[0] || this.pane.options.background : {},\n          r = a.innerRadius || \"0%\",\n          n = a.outerRadius || \"100%\",\n          l = e[0] + i.plotLeft,\n          h = e[1] + i.plotTop,\n          p = this.height,\n          d = t.isCrosshair,\n          c = e[3] / 2,\n          u = t.value,\n          f,\n          b,\n          m,\n          y,\n          x,\n          P,\n          v,\n          S,\n          M,\n          L = this.getPosition(u),\n          k = L.x,\n          C = L.y;\n        if (d && (u = (S = this.getCrosshairPosition(t, l, h))[0], k = S[1], C = S[2]), this.isCircular) b = Math.sqrt(Math.pow(k - l, 2) + Math.pow(C - h, 2)), m = \"string\" == typeof r ? g(r, 1) : r / b, y = \"string\" == typeof n ? g(n, 1) : n / b, e && c && (m < (f = c / b) && (m = f), y < f && (y = f)), M = [[\"M\", l + m * (k - l), h - m * (h - C)], [\"L\", k - (1 - y) * (k - l), C + (1 - y) * (h - C)]];else if ((u = this.translate(u)) && (u < 0 || u > p) && (u = 0), \"circle\" === this.options.gridLineInterpolation) M = this.getLinePath(0, u, c);else if (M = [], i[s ? \"yAxis\" : \"xAxis\"].forEach(t => {\n          t.pane === this.pane && (x = t);\n        }), x) {\n          v = x.tickPositions, x.autoConnect && (v = v.concat([v[0]])), o && (v = v.slice().reverse()), u && (u += c);\n          for (let t = 0; t < v.length; t++) P = x.getPosition(v[t], u), M.push(t ? [\"L\", P.x, P.y] : [\"M\", P.x, P.y]);\n        }\n        return M;\n      }\n      function C(t, e) {\n        let i = this.translate(t);\n        return this.postTranslate(this.isCircular ? i : this.angleRad, u(this.isCircular ? e : i < 0 ? 0 : i, this.center[2] / 2) - this.offset);\n      }\n      function w() {\n        let t = this.center,\n          e = this.chart,\n          i = this.options.title;\n        return {\n          x: e.plotLeft + t[0] + (i.x || 0),\n          y: e.plotTop + t[1] - {\n            high: .5,\n            middle: .25,\n            low: 0\n          }[i.align] * t[2] + (i.y || 0)\n        };\n      }\n      function A(t) {\n        t.beforeSetTickPositions = y, t.createLabelCollector = x, t.getCrosshairPosition = v, t.getLinePath = S, t.getOffset = M, t.getPlotBandPath = L, t.getPlotLinePath = k, t.getPosition = C, t.getTitlePosition = w, t.postTranslate = D, t.setAxisSize = E, t.setAxisTranslation = z, t.setOptions = O;\n      }\n      function N() {\n        let t = this.chart,\n          e = this.options,\n          i = t.angular && this.isXAxis,\n          s = this.pane,\n          o = s && s.options;\n        if (!i && s && (t.angular || t.polar)) {\n          let t = 2 * Math.PI,\n            i = (u(o.startAngle, 0) - 90) * Math.PI / 180,\n            s = (u(o.endAngle, u(o.startAngle, 0) + 360) - 90) * Math.PI / 180;\n          this.angleRad = (e.angle || 0) * Math.PI / 180, this.startAngleRad = i, this.endAngleRad = s, this.offset = e.offset || 0;\n          let a = (i % t + t) % t,\n            r = (s % t + t) % t;\n          a > Math.PI && (a -= t), r > Math.PI && (r -= t), this.normalizedStartAngleRad = a, this.normalizedEndAngleRad = r;\n        }\n      }\n      function T(t) {\n        this.isRadial && (t.align = void 0, t.preventDefault());\n      }\n      function X() {\n        if (this.chart && this.chart.labelCollectors) {\n          let t = this.labelCollector ? this.chart.labelCollectors.indexOf(this.labelCollector) : -1;\n          t >= 0 && this.chart.labelCollectors.splice(t, 1);\n        }\n      }\n      function Y(e) {\n        let i;\n        let s = this.chart,\n          a = s.inverted,\n          n = s.angular,\n          l = s.polar,\n          h = this.isXAxis,\n          p = this.coll,\n          d = e.userOptions.pane || 0,\n          u = this.pane = s.pane && s.pane[d];\n        if (\"colorAxis\" === p) {\n          this.isRadial = !1;\n          return;\n        }\n        n ? (n && h ? (this.isHidden = !0, this.createLabelCollector = P, this.getOffset = r, this.redraw = B, this.render = B, this.setScale = r, this.setCategories = r, this.setTitle = r) : A(this), (i = !h) && (this.defaultPolarOptions = b)) : l && (A(this), i = this.horiz, this.defaultPolarOptions = i ? o : c(\"xAxis\" === p ? t.defaultXAxisOptions : t.defaultYAxisOptions, m), a && \"yAxis\" === p && (this.defaultPolarOptions.stackLabels = t.defaultYAxisOptions.stackLabels, this.defaultPolarOptions.reversedStacks = !0)), n || l ? (this.isRadial = !0, this.labelCollector || (this.labelCollector = this.createLabelCollector()), this.labelCollector && s.labelCollectors.push(this.labelCollector)) : this.isRadial = !1, u && i && (u.axis = this), this.isCircular = i;\n      }\n      function R() {\n        this.isRadial && this.beforeSetTickPositions();\n      }\n      function I(t) {\n        let e = this.label;\n        if (!e) return;\n        let i = this.axis,\n          s = e.getBBox(),\n          o = i.options.labels,\n          a = (i.translate(this.pos) + i.startAngleRad + Math.PI / 2) / Math.PI * 180 % 360,\n          r = Math.round(a),\n          n = h(o.y) ? 0 : -(.3 * s.height),\n          l = o.y,\n          p,\n          d = 20,\n          c = o.align,\n          f = \"end\",\n          b = r < 0 ? r + 360 : r,\n          m = b,\n          y = 0,\n          x = 0;\n        i.isRadial && (p = i.getPosition(this.pos, i.center[2] / 2 + g(u(o.distance, -25), i.center[2] / 2, -i.center[2] / 2)), \"auto\" === o.rotation ? e.attr({\n          rotation: a\n        }) : h(l) || (l = i.chart.renderer.fontMetrics(e).b - s.height / 2), h(c) || (i.isCircular ? (s.width > i.len * i.tickInterval / (i.max - i.min) && (d = 0), c = a > d && a < 180 - d ? \"left\" : a > 180 + d && a < 360 - d ? \"right\" : \"center\") : c = \"center\", e.attr({\n          align: c\n        })), \"auto\" === c && 2 === i.tickPositions.length && i.isCircular && (b > 90 && b < 180 ? b = 180 - b : b > 270 && b <= 360 && (b = 540 - b), m > 180 && m <= 360 && (m = 360 - m), (i.pane.options.startAngle === r || i.pane.options.startAngle === r + 360 || i.pane.options.startAngle === r - 360) && (f = \"start\"), c = r >= -90 && r <= 90 || r >= -360 && r <= -270 || r >= 270 && r <= 360 ? \"start\" === f ? \"right\" : \"left\" : \"start\" === f ? \"left\" : \"right\", m > 70 && m < 110 && (c = \"center\"), b < 15 || b >= 180 && b < 195 ? y = .3 * s.height : b >= 15 && b <= 35 ? y = \"start\" === f ? 0 : .75 * s.height : b >= 195 && b <= 215 ? y = \"start\" === f ? .75 * s.height : 0 : b > 35 && b <= 90 ? y = \"start\" === f ? -(.25 * s.height) : s.height : b > 215 && b <= 270 && (y = \"start\" === f ? s.height : -(.25 * s.height)), m < 15 ? x = \"start\" === f ? -(.15 * s.height) : .15 * s.height : m > 165 && m <= 180 && (x = \"start\" === f ? .15 * s.height : -(.15 * s.height)), e.attr({\n          align: c\n        }), e.translate(x, y + n)), t.pos.x = p.x + (o.x || 0), t.pos.y = p.y + (l || 0));\n      }\n      function j(t) {\n        this.axis.getPosition && p(t.pos, this.axis.getPosition(this.pos));\n      }\n      function D(t, e) {\n        let i = this.chart,\n          s = this.center;\n        return t = this.startAngleRad + t, {\n          x: i.plotLeft + s[0] + Math.cos(t) * e,\n          y: i.plotTop + s[1] + Math.sin(t) * e\n        };\n      }\n      function B() {\n        this.isDirty = !1;\n      }\n      function E() {\n        let t, e;\n        let i = this.constructor.prototype;\n        i.setAxisSize.call(this), this.isRadial && (this.pane.updateCenter(this), t = this.center = this.pane.center.slice(), this.isCircular ? this.sector = this.endAngleRad - this.startAngleRad : (e = this.postTranslate(this.angleRad, t[3] / 2), t[0] = e.x - this.chart.plotLeft, t[1] = e.y - this.chart.plotTop), this.len = this.width = this.height = (t[2] - t[3]) * u(this.sector, 1) / 2);\n      }\n      function z() {\n        let t = this.constructor.prototype;\n        t.setAxisTranslation.call(this), this.center && (this.isCircular ? this.transA = (this.endAngleRad - this.startAngleRad) / (this.max - this.min || 1) : this.transA = (this.center[2] - this.center[3]) / 2 / (this.max - this.min || 1), this.isXAxis ? this.minPixelPadding = this.transA * this.minPointOffset : this.minPixelPadding = 0);\n      }\n      function O(t) {\n        let e = this.options = c(this.constructor.defaultOptions, this.defaultPolarOptions, a[this.coll], t);\n        e.plotBands || (e.plotBands = []), d(this, \"afterSetOptions\");\n      }\n      function W(t, e, i, s, o, a, r) {\n        let n;\n        let l = this.axis;\n        return l.isRadial ? [\"M\", e, i, \"L\", (n = l.getPosition(this.pos, l.center[2] / 2 + s)).x, n.y] : t.call(this, e, i, s, o, a, r);\n      }\n      e.compose = function (t, e) {\n        return s.pushUnique(i, t) && (n(t, \"afterInit\", N), n(t, \"autoLabelAlign\", T), n(t, \"destroy\", X), n(t, \"init\", Y), n(t, \"initialAxisTranslation\", R)), s.pushUnique(i, e) && (n(e, \"afterGetLabelPosition\", I), n(e, \"afterGetPosition\", j), f(e.prototype, \"getMarkPath\", W)), t;\n      };\n    }(o || (o = {})), o;\n  }), i(e, \"Series/PolarComposition.js\", [e[\"Core/Animation/AnimationUtilities.js\"], e[\"Core/Globals.js\"], e[\"Core/Series/Series.js\"], e[\"Extensions/Pane.js\"], e[\"Core/Axis/RadialAxis.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s, o, a) {\n    let {\n        animObject: r\n      } = t,\n      {\n        addEvent: n,\n        defined: l,\n        find: h,\n        isNumber: p,\n        merge: d,\n        pick: c,\n        relativeLength: u,\n        splat: g,\n        uniqueKey: f,\n        wrap: b\n      } = a,\n      m = [];\n    function y() {\n      (this.pane || []).forEach(t => {\n        t.render();\n      });\n    }\n    function x(t) {\n      let e = t.args[0].xAxis,\n        i = t.args[0].yAxis,\n        s = t.args[0].chart;\n      e && i && (\"polygon\" === i.gridLineInterpolation ? (e.startOnTick = !0, e.endOnTick = !0) : \"polygon\" === e.gridLineInterpolation && s.inverted && (i.startOnTick = !0, i.endOnTick = !0));\n    }\n    function P() {\n      this.pane || (this.pane = []), this.options.pane = g(this.options.pane), this.options.pane.forEach(t => {\n        new s(t, this);\n      }, this);\n    }\n    function v(t) {\n      let e = t.args.marker,\n        i = this.chart.xAxis[0],\n        s = this.chart.yAxis[0],\n        o = this.chart.inverted,\n        a = o ? s : i,\n        r = o ? i : s;\n      if (this.chart.polar) {\n        t.preventDefault();\n        let i = (e.attr ? e.attr(\"start\") : e.start) - a.startAngleRad,\n          s = e.attr ? e.attr(\"r\") : e.r,\n          o = (e.attr ? e.attr(\"end\") : e.end) - a.startAngleRad,\n          n = e.attr ? e.attr(\"innerR\") : e.innerR;\n        t.result.x = i + a.pos, t.result.width = o - i, t.result.y = r.len + r.pos - n, t.result.height = n - s;\n      }\n    }\n    function S(t) {\n      let e = this.chart;\n      if (e.polar && e.hoverPane && e.hoverPane.axis) {\n        t.preventDefault();\n        let i = e.hoverPane.center,\n          s = this.mouseDownX || 0,\n          o = this.mouseDownY || 0,\n          a = t.args.chartY,\n          r = t.args.chartX,\n          n = 2 * Math.PI,\n          l = e.hoverPane.axis.startAngleRad,\n          h = e.hoverPane.axis.endAngleRad,\n          p = e.inverted ? e.xAxis[0] : e.yAxis[0],\n          d = {},\n          c = \"arc\";\n        if (d.x = i[0] + e.plotLeft, d.y = i[1] + e.plotTop, this.zoomHor) {\n          let t = l > 0 ? h - l : Math.abs(l) + Math.abs(h),\n            u = Math.atan2(o - e.plotTop - i[1], s - e.plotLeft - i[0]) - l,\n            g = Math.atan2(a - e.plotTop - i[1], r - e.plotLeft - i[0]) - l;\n          if (d.r = i[2] / 2, d.innerR = i[3] / 2, u <= 0 && (u += n), g <= 0 && (g += n), g < u && (g = [u, u = g][0]), t < n) {\n            let e = h + (n - t) / 2;\n            l + g > e && (g = u, u = l <= 0 ? l : 0);\n          }\n          let f = d.start = Math.max(u + l, l),\n            b = d.end = Math.min(g + l, h);\n          if (\"polygon\" === p.options.gridLineInterpolation) {\n            let t = e.hoverPane.axis,\n              s = (t.tickInterval, f - t.startAngleRad + t.pos),\n              o = p.getPlotLinePath({\n                value: p.max\n              }),\n              a = t.toValue(s),\n              r = t.toValue(s + (b - f));\n            if (a < t.getExtremes().min) {\n              let {\n                min: e,\n                max: i\n              } = t.getExtremes();\n              a = i - (e - a);\n            }\n            if (r < t.getExtremes().min) {\n              let {\n                min: e,\n                max: i\n              } = t.getExtremes();\n              r = i - (e - r);\n            }\n            r < a && (r = [a, a = r][0]), (o = C(o, a, r, t)).push([\"L\", i[0] + e.plotLeft, e.plotTop + i[1]]), d.d = o, c = \"path\";\n          }\n        }\n        if (this.zoomVert) {\n          let t = e.inverted ? e.xAxis[0] : e.yAxis[0],\n            n = Math.sqrt(Math.pow(s - e.plotLeft - i[0], 2) + Math.pow(o - e.plotTop - i[1], 2)),\n            p = Math.sqrt(Math.pow(r - e.plotLeft - i[0], 2) + Math.pow(a - e.plotTop - i[1], 2));\n          if (p < n && (n = [p, p = n][0]), p > i[2] / 2 && (p = i[2] / 2), n < i[3] / 2 && (n = i[3] / 2), this.zoomHor || (d.start = l, d.end = h), d.r = p, d.innerR = n, \"polygon\" === t.options.gridLineInterpolation) {\n            let e = t.toValue(t.len + t.pos - n),\n              i = t.toValue(t.len + t.pos - p),\n              s = t.getPlotLinePath({\n                value: i\n              }).concat(t.getPlotLinePath({\n                value: e,\n                reverse: !0\n              }));\n            d.d = s, c = \"path\";\n          }\n        }\n        if (this.zoomHor && this.zoomVert && \"polygon\" === p.options.gridLineInterpolation) {\n          let t = e.hoverPane.axis,\n            i = d.start || 0,\n            s = d.end || 0,\n            o = i - t.startAngleRad + t.pos,\n            a = t.toValue(o),\n            r = t.toValue(o + (s - i));\n          if (d.d instanceof Array) {\n            let t = d.d.slice(0, d.d.length / 2),\n              i = d.d.slice(d.d.length / 2, d.d.length);\n            i = [...i].reverse();\n            let s = e.hoverPane.axis;\n            t = C(t, a, r, s), (i = C(i, a, r, s)) && (i[0][0] = \"L\"), i = [...i].reverse(), d.d = t.concat(i), c = \"path\";\n          }\n        }\n        t.attrs = d, t.shapeType = c;\n      }\n    }\n    function M() {\n      let t = this.chart;\n      t.polar && (this.polar = new j(this), t.inverted && (this.isRadialSeries = !0, this.is(\"column\") && (this.isRadialBar = !0)));\n    }\n    function L() {\n      if (this.chart.polar && this.xAxis) {\n        let {\n            xAxis: t,\n            yAxis: i\n          } = this,\n          s = this.chart;\n        this.kdByAngle = s.tooltip && s.tooltip.shared, this.kdByAngle ? this.searchPoint = k : this.options.findNearestPointBy = \"xy\";\n        let o = this.points,\n          a = o.length;\n        for (; a--;) this.is(\"column\") || this.is(\"columnrange\") || this.polar.toXY(o[a]), s.hasParallelCoordinates || this.yAxis.reversed || (c(o[a].y, Number.MIN_VALUE) < i.min || o[a].x < t.min || o[a].x > t.max ? (o[a].isNull = !0, o[a].plotY = NaN) : o[a].isNull = o[a].isValid && !o[a].isValid());\n        this.hasClipCircleSetter || (this.hasClipCircleSetter = !!this.eventsToUnbind.push(n(this, \"afterRender\", function () {\n          let t;\n          s.polar && !1 !== this.options.clip && (t = this.yAxis.pane.center, this.clipCircle ? this.clipCircle.animate({\n            x: t[0],\n            y: t[1],\n            r: t[2] / 2,\n            innerR: t[3] / 2\n          }) : this.clipCircle = function (t, e, i, s, o) {\n            let a = f(),\n              r = t.createElement(\"clipPath\").attr({\n                id: a\n              }).add(t.defs),\n              n = o ? t.arc(e, i, s, o, 0, 2 * Math.PI).add(r) : t.circle(e, i, s).add(r);\n            return n.id = a, n.clipPath = r, n;\n          }(s.renderer, t[0], t[1], t[2] / 2, t[3] / 2), this.group.clip(this.clipCircle), this.setClip = e.noop);\n        })));\n      }\n    }\n    function k(t) {\n      let e = this.chart,\n        i = this.xAxis,\n        s = i.pane && i.pane.center,\n        o = t.chartX - (s && s[0] || 0) - e.plotLeft,\n        a = t.chartY - (s && s[1] || 0) - e.plotTop;\n      return this.searchKDTree({\n        clientX: 180 + Math.atan2(o, a) * (-180 / Math.PI)\n      });\n    }\n    function C(t, e, i, s) {\n      let o = s.tickInterval,\n        a = s.tickPositions,\n        r = h(a, t => t >= i),\n        n = h([...a].reverse(), t => t <= e);\n      return l(r) || (r = a[a.length - 1]), l(n) || (n = a[0], r += o, t[0][0] = \"L\", t.unshift(t[t.length - 3])), (t = t.slice(a.indexOf(n), a.indexOf(r) + 1))[0][0] = \"M\", t;\n    }\n    function w(t, e) {\n      return h(this.pane || [], function (t) {\n        return t.options.id === e;\n      }) || t.call(this, e);\n    }\n    function A(t, e, s, o, a, r) {\n      let n, l, h;\n      let p = this.chart,\n        u = c(o.inside, !!this.options.stacking);\n      if (p.polar) {\n        if (n = e.rectPlotX / Math.PI * 180, p.inverted) this.forceDL = p.isInsidePlot(e.plotX, e.plotY), u && e.shapeArgs ? (l = e.shapeArgs, a = d(a, {\n          x: (h = this.yAxis.postTranslate(((l.start || 0) + (l.end || 0)) / 2 - this.xAxis.startAngleRad, e.barX + e.pointWidth / 2)).x - p.plotLeft,\n          y: h.y - p.plotTop\n        })) : e.tooltipPos && (a = d(a, {\n          x: e.tooltipPos[0],\n          y: e.tooltipPos[1]\n        })), o.align = c(o.align, \"center\"), o.verticalAlign = c(o.verticalAlign, \"middle\");else {\n          var g;\n          null === (g = o).align && (g.align = n > 20 && n < 160 ? \"left\" : n > 200 && n < 340 ? \"right\" : \"center\"), null === g.verticalAlign && (g.verticalAlign = n < 45 || n > 315 ? \"bottom\" : n > 135 && n < 225 ? \"top\" : \"middle\"), o = g;\n        }\n        i.prototype.alignDataLabel.call(this, e, s, o, a, r), this.isRadialBar && e.shapeArgs && e.shapeArgs.start === e.shapeArgs.end ? s.hide() : s.show();\n      } else t.call(this, e, s, o, a, r);\n    }\n    function N() {\n      let t = this.options,\n        e = t.stacking,\n        i = this.chart,\n        s = this.xAxis,\n        o = this.yAxis,\n        r = o.reversed,\n        n = o.center,\n        h = s.startAngleRad,\n        d = s.endAngleRad,\n        c = d - h,\n        g = t.threshold,\n        f = 0,\n        b,\n        m,\n        y,\n        x,\n        P,\n        v = 0,\n        S = 0,\n        M,\n        L,\n        k,\n        C,\n        w,\n        A,\n        N,\n        T;\n      if (s.isRadial) for (y = (b = this.points).length, x = o.translate(o.min), P = o.translate(o.max), g = t.threshold || 0, i.inverted && p(g) && l(f = o.translate(g)) && (f < 0 ? f = 0 : f > c && (f = c), this.translatedThreshold = f + h); y--;) {\n        if (A = (m = b[y]).barX, L = m.x, k = m.y, m.shapeType = \"arc\", i.inverted) {\n          m.plotY = o.translate(k), e && o.stacking ? (w = o.stacking.stacks[(k < 0 ? \"-\" : \"\") + this.stackKey], this.visible && w && w[L] && !m.isNull && (C = w[L].points[this.getStackIndicator(void 0, L, this.index).key], v = o.translate(C[0]), S = o.translate(C[1]), l(v) && (v = a.clamp(v, 0, c)))) : (v = f, S = m.plotY), v > S && (S = [v, v = S][0]), r ? S > x ? S = x : v < P ? v = P : (v > x || S < P) && (v = S = c) : v < x ? v = x : S > P ? S = P : (S < x || v > P) && (v = S = 0), o.min > o.max && (v = S = r ? c : 0), v += h, S += h, n && (m.barX = A += n[3] / 2), N = Math.max(A, 0), T = Math.max(A + m.pointWidth, 0);\n          let i = t.borderRadius,\n            s = \"object\" == typeof i ? i.radius : i,\n            p = u(s || 0, T - N);\n          m.shapeArgs = {\n            x: n[0],\n            y: n[1],\n            r: T,\n            innerR: N,\n            start: v,\n            end: S,\n            borderRadius: p\n          }, m.opacity = v === S ? 0 : void 0, m.plotY = (l(this.translatedThreshold) && (v < this.translatedThreshold ? v : S)) - h;\n        } else v = A + h, m.shapeArgs = this.polar.arc(m.yBottom, m.plotY, v, v + m.pointWidth), m.shapeArgs.borderRadius = 0;\n        this.polar.toXY(m), i.inverted ? (M = o.postTranslate(m.rectPlotY, A + m.pointWidth / 2), m.tooltipPos = [M.x - i.plotLeft, M.y - i.plotTop]) : m.tooltipPos = [m.plotX, m.plotY], n && (m.ttBelow = m.plotY > n[1]);\n      }\n    }\n    function T(t, e) {\n      let i, s;\n      let o = this;\n      if (this.chart.polar) {\n        e = e || this.points;\n        for (let t = 0; t < e.length; t++) if (!e[t].isNull) {\n          i = t;\n          break;\n        }\n        !1 !== this.options.connectEnds && void 0 !== i && (this.connectEnds = !0, e.splice(e.length, 0, e[i]), s = !0), e.forEach(t => {\n          void 0 === t.polarPlotY && o.polar.toXY(t);\n        });\n      }\n      let a = t.apply(this, [].slice.call(arguments, 1));\n      return s && e.pop(), a;\n    }\n    function X(t, e) {\n      let i = this.chart,\n        s = {\n          xAxis: [],\n          yAxis: []\n        };\n      return i.polar ? i.axes.forEach(t => {\n        if (\"colorAxis\" === t.coll) return;\n        let o = t.isXAxis,\n          a = t.center,\n          r = e.chartX - a[0] - i.plotLeft,\n          n = e.chartY - a[1] - i.plotTop;\n        s[o ? \"xAxis\" : \"yAxis\"].push({\n          axis: t,\n          value: t.translate(o ? Math.PI - Math.atan2(r, n) : Math.sqrt(Math.pow(r, 2) + Math.pow(n, 2)), !0)\n        });\n      }) : s = t.call(this, e), s;\n    }\n    function Y(t, e) {\n      this.chart.polar || t.call(this, e);\n    }\n    function R(t, i) {\n      let s = this,\n        o = this.chart,\n        a = this.group,\n        n = this.markerGroup,\n        l = this.xAxis && this.xAxis.center,\n        h = o.plotLeft,\n        p = o.plotTop,\n        d = this.options.animation,\n        u,\n        g,\n        f,\n        b,\n        m,\n        y;\n      o.polar ? s.isRadialBar ? i || (s.startAngleRad = c(s.translatedThreshold, s.xAxis.startAngleRad), e.seriesTypes.pie.prototype.animate.call(s, i)) : (d = r(d), s.is(\"column\") ? i || (g = l[3] / 2, s.points.forEach(t => {\n        f = t.graphic, m = (b = t.shapeArgs) && b.r, y = b && b.innerR, f && b && (f.attr({\n          r: g,\n          innerR: g\n        }), f.animate({\n          r: m,\n          innerR: y\n        }, s.options.animation));\n      })) : i ? (u = {\n        translateX: l[0] + h,\n        translateY: l[1] + p,\n        scaleX: .001,\n        scaleY: .001\n      }, a.attr(u), n && n.attr(u)) : (u = {\n        translateX: h,\n        translateY: p,\n        scaleX: 1,\n        scaleY: 1\n      }, a.animate(u, d), n && n.animate(u, d))) : t.call(this, i);\n    }\n    function I(t, e, i, s) {\n      let o, a;\n      if (this.chart.polar) {\n        if (s) {\n          a = function t(e, i, s, o) {\n            let a, r, n, l, h, p;\n            let d = o ? 1 : 0;\n            a = i >= 0 && i <= e.length - 1 ? i : i < 0 ? e.length - 1 + i : 0;\n            let c = a - 1 < 0 ? e.length - (1 + d) : a - 1,\n              u = a + 1 > e.length - 1 ? d : a + 1,\n              g = e[c],\n              f = e[u],\n              b = g.plotX,\n              m = g.plotY,\n              y = f.plotX,\n              x = f.plotY,\n              P = e[a].plotX,\n              v = e[a].plotY;\n            r = (1.5 * P + b) / 2.5, n = (1.5 * v + m) / 2.5, l = (1.5 * P + y) / 2.5, h = (1.5 * v + x) / 2.5;\n            let S = Math.sqrt(Math.pow(r - P, 2) + Math.pow(n - v, 2)),\n              M = Math.sqrt(Math.pow(l - P, 2) + Math.pow(h - v, 2)),\n              L = Math.atan2(n - v, r - P),\n              k = Math.atan2(h - v, l - P);\n            p = Math.PI / 2 + (L + k) / 2, Math.abs(L - p) > Math.PI / 2 && (p -= Math.PI), r = P + Math.cos(p) * S, n = v + Math.sin(p) * S, l = P + Math.cos(Math.PI + p) * M, h = v + Math.sin(Math.PI + p) * M;\n            let C = {\n              rightContX: l,\n              rightContY: h,\n              leftContX: r,\n              leftContY: n,\n              plotX: P,\n              plotY: v\n            };\n            return s && (C.prevPointCont = t(e, c, !1, o)), C;\n          }(e, s, !0, this.connectEnds);\n          let t = a.prevPointCont && a.prevPointCont.rightContX,\n            i = a.prevPointCont && a.prevPointCont.rightContY;\n          o = [\"C\", p(t) ? t : a.plotX, p(i) ? i : a.plotY, p(a.leftContX) ? a.leftContX : a.plotX, p(a.leftContY) ? a.leftContY : a.plotY, a.plotX, a.plotY];\n        } else o = [\"M\", i.plotX, i.plotY];\n      } else o = t.call(this, e, i, s);\n      return o;\n    }\n    class j {\n      static compose(t, e, i, s, r, l, h, p, d) {\n        if (o.compose(t, r), a.pushUnique(m, e)) {\n          n(e, \"afterDrawChartBox\", y), n(e, \"getAxes\", P), n(e, \"init\", x);\n          let t = e.prototype;\n          b(t, \"get\", w);\n        }\n        if (a.pushUnique(m, i)) {\n          let t = i.prototype;\n          b(t, \"getCoordinates\", X), b(t, \"pinch\", Y), n(i, \"getSelectionMarkerAttrs\", S), n(i, \"getSelectionBox\", v);\n        }\n        if (a.pushUnique(m, s)) {\n          n(s, \"afterInit\", M), n(s, \"afterTranslate\", L, {\n            order: 2\n          }), n(s, \"afterColumnTranslate\", N, {\n            order: 4\n          });\n          let t = s.prototype;\n          b(t, \"animate\", R);\n        }\n        if (h && a.pushUnique(m, h)) {\n          let t = h.prototype;\n          b(t, \"alignDataLabel\", A), b(t, \"animate\", R);\n        }\n        if (p && a.pushUnique(m, p)) {\n          let t = p.prototype;\n          b(t, \"getGraphPath\", T);\n        }\n        if (d && a.pushUnique(m, d)) {\n          let t = d.prototype;\n          if (b(t, \"getPointSpline\", I), l && a.pushUnique(m, l)) {\n            let e = l.prototype;\n            e.getPointSpline = t.getPointSpline;\n          }\n        }\n      }\n      constructor(t) {\n        this.series = t;\n      }\n      arc(t, e, i, s) {\n        let o = this.series,\n          a = o.xAxis.center,\n          r = o.yAxis.len,\n          n = a[3] / 2,\n          l = r - e + n,\n          h = r - c(t, r) + n;\n        return o.yAxis.reversed && (l < 0 && (l = n), h < 0 && (h = n)), {\n          x: a[0],\n          y: a[1],\n          r: l,\n          innerR: h,\n          start: i,\n          end: s\n        };\n      }\n      toXY(t) {\n        let e = this.series,\n          i = e.chart,\n          s = e.xAxis,\n          o = e.yAxis,\n          a = t.plotX,\n          r = i.inverted,\n          n = t.y,\n          l = t.plotY,\n          h = r ? a : o.len - l,\n          d;\n        if (r && e && !e.isRadialBar && (t.plotY = l = p(n) ? o.translate(n) : 0), t.rectPlotX = a, t.rectPlotY = l, o.center && (h += o.center[3] / 2), p(l)) {\n          let e = r ? o.postTranslate(l, h) : s.postTranslate(a, h);\n          t.plotX = t.polarPlotX = e.x - i.plotLeft, t.plotY = t.polarPlotY = e.y - i.plotTop;\n        }\n        e.kdByAngle ? ((d = (a / Math.PI * 180 + s.pane.options.startAngle) % 360) < 0 && (d += 360), t.clientX = d) : t.clientX = t.plotX;\n      }\n    }\n    return j;\n  }), i(e, \"Core/Axis/WaterfallAxis.js\", [e[\"Core/Axis/Stacking/StackItem.js\"], e[\"Core/Utilities.js\"]], function (t, e) {\n    var i;\n    let {\n      addEvent: s,\n      objectEach: o,\n      pushUnique: a\n    } = e;\n    return function (e) {\n      let i = [];\n      function r() {\n        let t = this.waterfall.stacks;\n        t && (t.changed = !1, delete t.alreadyChanged);\n      }\n      function n() {\n        let t = this.options.stackLabels;\n        t && t.enabled && this.waterfall.stacks && this.waterfall.renderStackTotals();\n      }\n      function l() {\n        this.waterfall || (this.waterfall = new p(this));\n      }\n      function h() {\n        let t = this.axes,\n          e = this.series;\n        for (let i of e) if (i.options.stacking) {\n          for (let e of t) e.isXAxis || (e.waterfall.stacks.changed = !0);\n          break;\n        }\n      }\n      e.compose = function (t, e) {\n        a(i, t) && (s(t, \"init\", l), s(t, \"afterBuildStacks\", r), s(t, \"afterRender\", n)), a(i, e) && s(e, \"beforeRedraw\", h);\n      };\n      class p {\n        constructor(t) {\n          this.axis = t, this.stacks = {\n            changed: !1\n          };\n        }\n        renderStackTotals() {\n          let e = this.axis,\n            i = e.waterfall.stacks,\n            s = e.stacking && e.stacking.stackTotalGroup,\n            a = new t(e, e.options.stackLabels || {}, !1, 0, void 0);\n          this.dummyStackItem = a, s && o(i, e => {\n            o(e, (e, i) => {\n              a.total = e.stackTotal, a.x = +i, e.label && (a.label = e.label), t.prototype.render.call(a, s), e.label = a.label, delete a.label;\n            });\n          }), a.total = null;\n        }\n      }\n      e.Composition = p;\n    }(i || (i = {})), i;\n  }), i(e, \"Series/Waterfall/WaterfallPoint.js\", [e[\"Series/Column/ColumnSeries.js\"], e[\"Core/Series/Point.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    let {\n      isNumber: s\n    } = i;\n    class o extends t.prototype.pointClass {\n      constructor() {\n        super(...arguments), this.options = void 0, this.series = void 0;\n      }\n      getClassName() {\n        let t = e.prototype.getClassName.call(this);\n        return this.isSum ? t += \" highcharts-sum\" : this.isIntermediateSum && (t += \" highcharts-intermediate-sum\"), t;\n      }\n      isValid() {\n        return s(this.y) || this.isSum || !!this.isIntermediateSum;\n      }\n    }\n    return o;\n  }), i(e, \"Series/Waterfall/WaterfallSeriesDefaults.js\", [], function () {\n    return {\n      dataLabels: {\n        inside: !0\n      },\n      lineWidth: 1,\n      lineColor: \"#333333\",\n      dashStyle: \"Dot\",\n      borderColor: \"#333333\",\n      states: {\n        hover: {\n          lineWidthPlus: 0\n        }\n      }\n    };\n  }), i(e, \"Series/Waterfall/WaterfallSeries.js\", [e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"], e[\"Core/Axis/WaterfallAxis.js\"], e[\"Series/Waterfall/WaterfallPoint.js\"], e[\"Series/Waterfall/WaterfallSeriesDefaults.js\"]], function (t, e, i, s, o) {\n    let {\n        column: a,\n        line: r\n      } = t.seriesTypes,\n      {\n        addEvent: n,\n        arrayMax: l,\n        arrayMin: h,\n        correctFloat: p,\n        extend: d,\n        isNumber: c,\n        merge: u,\n        objectEach: g,\n        pick: f\n      } = e;\n    function b(t, e) {\n      return Object.hasOwnProperty.call(t, e);\n    }\n    class m extends a {\n      constructor() {\n        super(...arguments), this.chart = void 0, this.data = void 0, this.options = void 0, this.points = void 0, this.stackedYNeg = void 0, this.stackedYPos = void 0, this.stackKey = void 0, this.xData = void 0, this.yAxis = void 0, this.yData = void 0;\n      }\n      generatePoints() {\n        a.prototype.generatePoints.apply(this);\n        for (let t = 0, e = this.points.length; t < e; t++) {\n          let e = this.points[t],\n            i = this.processedYData[t];\n          c(i) && (e.isIntermediateSum || e.isSum) && (e.y = p(i));\n        }\n      }\n      processData(t) {\n        let e, i, s, o, a, r;\n        let n = this.options,\n          l = this.yData,\n          h = n.data,\n          d = l.length,\n          c = n.threshold || 0;\n        s = i = o = a = 0;\n        for (let t = 0; t < d; t++) r = l[t], e = h && h[t] ? h[t] : {}, \"sum\" === r || e.isSum ? l[t] = p(s) : \"intermediateSum\" === r || e.isIntermediateSum ? (l[t] = p(i), i = 0) : (s += r, i += r), o = Math.min(s, o), a = Math.max(s, a);\n        super.processData.call(this, t), n.stacking || (this.dataMin = o + c, this.dataMax = a);\n      }\n      toYData(t) {\n        return t.isSum ? \"sum\" : t.isIntermediateSum ? \"intermediateSum\" : t.y;\n      }\n      updateParallelArrays(t, e) {\n        super.updateParallelArrays.call(this, t, e), (\"sum\" === this.yData[0] || \"intermediateSum\" === this.yData[0]) && (this.yData[0] = null);\n      }\n      pointAttribs(t, e) {\n        let i = this.options.upColor;\n        i && !t.options.color && c(t.y) && (t.color = t.y > 0 ? i : void 0);\n        let s = a.prototype.pointAttribs.call(this, t, e);\n        return delete s.dashstyle, s;\n      }\n      getGraphPath() {\n        return [[\"M\", 0, 0]];\n      }\n      getCrispPath() {\n        let t = this.data.filter(t => c(t.y)),\n          e = this.yAxis,\n          i = t.length,\n          s = Math.round(this.graph.strokeWidth()) % 2 / 2,\n          o = Math.round(this.borderWidth) % 2 / 2,\n          a = this.xAxis.reversed,\n          r = this.yAxis.reversed,\n          n = this.options.stacking,\n          l = [];\n        for (let h = 1; h < i; h++) {\n          if (!(this.options.connectNulls || c(this.data[t[h].index - 1].y))) continue;\n          let i = t[h].box,\n            p = t[h - 1],\n            d = p.y || 0,\n            u = t[h - 1].box;\n          if (!i || !u) continue;\n          let g = e.waterfall.stacks[this.stackKey],\n            f = d > 0 ? -u.height : 0;\n          if (g && u && i) {\n            let t;\n            let d = g[h - 1];\n            if (n) {\n              let i = d.connectorThreshold;\n              t = Math.round(e.translate(i, !1, !0, !1, !0) + (r ? f : 0)) - s;\n            } else t = u.y + p.minPointLengthOffset + o - s;\n            l.push([\"M\", (u.x || 0) + (a ? 0 : u.width || 0), t], [\"L\", (i.x || 0) + (a && i.width || 0), t]);\n          }\n          if (u && l.length && (!n && d < 0 && !r || d > 0 && r)) {\n            let t = l[l.length - 2];\n            t && \"number\" == typeof t[2] && (t[2] += u.height || 0);\n            let e = l[l.length - 1];\n            e && \"number\" == typeof e[2] && (e[2] += u.height || 0);\n          }\n        }\n        return l;\n      }\n      drawGraph() {\n        r.prototype.drawGraph.call(this), this.graph && this.graph.attr({\n          d: this.getCrispPath()\n        });\n      }\n      setStackedPoints(t) {\n        let e = this.options,\n          i = t.waterfall?.stacks,\n          s = e.threshold || 0,\n          o = this.stackKey,\n          a = this.xData,\n          r = a.length,\n          n = s,\n          l = n,\n          h,\n          p = 0,\n          d = 0,\n          c = 0,\n          u,\n          g,\n          f,\n          b,\n          m,\n          y,\n          x,\n          P,\n          v = (t, e, i, s) => {\n            if (h) {\n              if (u) for (; i < u; i++) h.stackState[i] += s;else h.stackState[0] = t, u = h.stackState.length;\n              h.stackState.push(h.stackState[u - 1] + e);\n            }\n          };\n        if (t.stacking && i && this.reserveSpace()) {\n          P = i.changed, (x = i.alreadyChanged) && 0 > x.indexOf(o) && (P = !0), i[o] || (i[o] = {});\n          let t = i[o];\n          if (t) for (let i = 0; i < r; i++) (!t[y = a[i]] || P) && (t[y] = {\n            negTotal: 0,\n            posTotal: 0,\n            stackTotal: 0,\n            threshold: 0,\n            stateIndex: 0,\n            stackState: [],\n            label: P && t[y] ? t[y].label : void 0\n          }), h = t[y], (m = this.yData[i]) >= 0 ? h.posTotal += m : h.negTotal += m, b = e.data[i], g = h.absolutePos = h.posTotal, f = h.absoluteNeg = h.negTotal, h.stackTotal = g + f, u = h.stackState.length, b && b.isIntermediateSum ? (v(c, d, 0, c), c = d, d = s, n ^= l, l ^= n, n ^= l) : b && b.isSum ? (v(s, p, u, 0), n = s) : (v(n, m, 0, p), b && (p += m, d += m)), h.stateIndex++, h.threshold = n, n += h.stackTotal;\n          i.changed = !1, i.alreadyChanged || (i.alreadyChanged = []), i.alreadyChanged.push(o);\n        }\n      }\n      getExtremes() {\n        let t, e, i;\n        let s = this.options.stacking;\n        return s ? (t = this.yAxis.waterfall.stacks, e = this.stackedYNeg = [], i = this.stackedYPos = [], \"overlap\" === s ? g(t[this.stackKey], function (t) {\n          e.push(h(t.stackState)), i.push(l(t.stackState));\n        }) : g(t[this.stackKey], function (t) {\n          e.push(t.negTotal + t.threshold), i.push(t.posTotal + t.threshold);\n        }), {\n          dataMin: h(e),\n          dataMax: l(i)\n        }) : {\n          dataMin: this.dataMin,\n          dataMax: this.dataMax\n        };\n      }\n    }\n    return m.defaultOptions = u(a.defaultOptions, o), m.compose = i.compose, d(m.prototype, {\n      getZonesGraphs: r.prototype.getZonesGraphs,\n      pointValKey: \"y\",\n      showLine: !0,\n      pointClass: s\n    }), n(m, \"afterColumnTranslate\", function () {\n      let {\n          options: t,\n          points: e,\n          yAxis: i\n        } = this,\n        s = f(t.minPointLength, 5),\n        o = s / 2,\n        a = t.threshold || 0,\n        r = t.stacking,\n        n = i.waterfall.stacks[this.stackKey],\n        l = a,\n        h = a,\n        p,\n        g,\n        m,\n        y;\n      for (let t = 0; t < e.length; t++) {\n        let f = e[t],\n          x = this.processedYData[t],\n          P = f.shapeArgs,\n          v = d({\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n          }, P || {});\n        f.box = v;\n        let S = [0, x],\n          M = f.y || 0;\n        if (r) {\n          if (n) {\n            let e = n[t];\n            \"overlap\" === r ? (g = e.stackState[e.stateIndex--], p = M >= 0 ? g : g - M, b(e, \"absolutePos\") && delete e.absolutePos, b(e, \"absoluteNeg\") && delete e.absoluteNeg) : (M >= 0 ? (g = e.threshold + e.posTotal, e.posTotal -= M, p = g) : (g = e.threshold + e.negTotal, e.negTotal -= M, p = g - M), !e.posTotal && c(e.absolutePos) && b(e, \"absolutePos\") && (e.posTotal = e.absolutePos, delete e.absolutePos), !e.negTotal && c(e.absoluteNeg) && b(e, \"absoluteNeg\") && (e.negTotal = e.absoluteNeg, delete e.absoluteNeg)), f.isSum || (e.connectorThreshold = e.threshold + e.stackTotal), i.reversed ? (m = M >= 0 ? p - M : p + M, y = p) : (m = p, y = p - M), f.below = m <= a, v.y = i.translate(m, !1, !0, !1, !0), v.height = Math.abs(v.y - i.translate(y, !1, !0, !1, !0));\n            let s = i.waterfall.dummyStackItem;\n            s && (s.x = t, s.label = n[t].label, s.setOffset(this.pointXOffset || 0, this.barW || 0, this.stackedYNeg[t], this.stackedYPos[t], void 0, this.xAxis));\n          }\n        } else p = Math.max(h, h + M) + S[0], v.y = i.translate(p, !1, !0, !1, !0), f.isSum ? (v.y = i.translate(S[1], !1, !0, !1, !0), v.height = Math.min(i.translate(S[0], !1, !0, !1, !0), i.len) - v.y, f.below = S[1] <= a) : f.isIntermediateSum ? (M >= 0 ? (m = S[1] + l, y = l) : (m = l, y = S[1] + l), i.reversed && (m ^= y, y ^= m, m ^= y), v.y = i.translate(m, !1, !0, !1, !0), v.height = Math.abs(v.y - Math.min(i.translate(y, !1, !0, !1, !0), i.len)), l += S[1], f.below = m <= a) : (v.height = x > 0 ? i.translate(h, !1, !0, !1, !0) - v.y : i.translate(h, !1, !0, !1, !0) - i.translate(h - x, !1, !0, !1, !0), h += x, f.below = h < a), v.height < 0 && (v.y += v.height, v.height *= -1);\n        f.plotY = v.y = Math.round(v.y || 0) - this.borderWidth % 2 / 2, v.height = Math.max(Math.round(v.height || 0), .001), f.yBottom = v.y + v.height, v.height <= s && !f.isNull ? (v.height = s, v.y -= o, f.plotY = v.y, M < 0 ? f.minPointLengthOffset = -o : f.minPointLengthOffset = o) : (f.isNull && (v.width = 0), f.minPointLengthOffset = 0);\n        let L = f.plotY + (f.negative ? v.height : 0);\n        f.below && (f.plotY += v.height), f.tooltipPos && (this.chart.inverted ? f.tooltipPos[0] = i.len - L : f.tooltipPos[1] = L), f.isInside = this.isPointInside(f), u(!0, f.shapeArgs, v);\n      }\n    }, {\n      order: 2\n    }), t.registerSeriesType(\"waterfall\", m), m;\n  }), i(e, \"masters/highcharts-more.src.js\", [e[\"Core/Globals.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Series/Bubble/BubbleSeries.js\"], e[\"Series/PackedBubble/PackedBubbleSeries.js\"], e[\"Series/PolarComposition.js\"], e[\"Series/Waterfall/WaterfallSeries.js\"]], function (t, e, i, s, o, a) {\n    i.compose(t.Axis, t.Chart, t.Legend, t.Series), s.compose(t.Axis, t.Chart, t.Legend, t.Series), o.compose(t.Axis, t.Chart, t.Pointer, t.Series, t.Tick, e.seriesTypes.areasplinerange, e.seriesTypes.column, e.seriesTypes.line, e.seriesTypes.spline), a.compose(t.Axis, t.Chart);\n  });\n}); //# sourceMappingURL=highcharts-more.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}